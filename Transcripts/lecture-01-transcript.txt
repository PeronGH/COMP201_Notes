[SIDE CONVERSATIONS] OK. OK. Good morning. Good morning. Good morning. My name is-- [SIDE CONVERSATIONS] OK. Thank you. OK. My name is Sebastian Coop. I'm the module leader for this module. I'll be also teaching it with Henry, who's just introduced himself. This is software engineering about building large-scale systems. This subject is not largely focused on programming. There were a little bit of coding in it, but that's not its main focus. Its main focus is requirements, design, testing, and project management. It's all the stuff that we wrap around programming you to make it work. In the same way that a-- if you did a course on building engineering, you wouldn't be spending a lot of time learning bricklaying, even though coding is more complex than bricklaying. But that's a sort of-- you have to learn to build the architecture. And then within that architecture, then you can put the components that are the actual code itself. So we're going to introduce the module today. And there is the materials. All the materials for this subject are on Canvas. So on Canvas are all these PowerPoint slides. All the lectures will be streamed on Canvas so you'll be able to look at them. So even if you're off sake or you want to look at them later on, you'll be able to catch these lectures again. All the tutorials are on Canvas. There is some source code on Canvas. There is some links on Canvas. There's a whole load of different resources. So instead of going over that line by line on Canvas, I'll let you explore that in your own time. And then if you've got any questions, you can just get back to me. So that's the best thing, rather than me going over the Canvas line by line. But today's thing, I'm going to introduce the module. So first thing I want to start off with is just to discuss this term software engineering. So software itself is instructions and data. So for something like a neural net, for example, if the neural net isn't trained to do anything, doesn't have any data in it, it's absolutely useless. Doesn't actually do anything. You need to actually put all the weights in the neural net before it can do something. So the software itself involves some kind of data to help drive the software in a context. So there is code and there is data that make up what software is in a broad sense. And the real example of that, you can see in terms of software and data design, is to think of OO programming. Because if I think of a class, it has all the attributes in the class, which is the data, the structure of the data. And then it has the methods, which is the code. They're all wrapped into one thing. That's the cool thing about object-oriented programming. It puts them in one thing. That's an important thing about OO. But making software, if you think of it as engineering, it has to be in this way, in a structured and disciplined manner. So not just in a random way, not just people just throwing stuff, not just me taking a-- let's say I've got 10 developers and I've got 500 page spec, and tearing the first 50 pages and giving them to the first developer. That wouldn't make any sense, would it? And give the last 50 pages to the last developer. I mean, how does that work? The last 50 pages is probably just like the index page and some other stuff. You wouldn't do that, would you? It wouldn't make any sense at all. So you have to have some sensible approach for doing this. So why do we want to do this? Why do we want to have this engineering approach to producing our software? Because we already have our programming, just to do our programming. Because to develop software systems, and software systems of any decent size, is a difficult thing to do. So if you've got a little bit of code, and I asked you to do a simple bubble sort of array of integers or something, I'm sure you could probably do it. It may take you a while and whatever, but it's very doable. If you're including something asked to produce an operating system, and it has to support all these different sorts of hardware, and it has to work over a network, and it has to support all these different protocols, and it has to have encryption, and it has to have bio login, or whatever you want, or two-factor authentication, and it has to work in different platforms and different performance requirements, now it's starting to get really difficult. It's starting to get a really big problem that needs managing. So the system is harder, often because it's bigger, you have more developers, the product is a lot larger, it gets a more difficult thing to do. It's also difficult because the problems it's solving become more difficult. So anything to do with artificial intelligence, these large language models, things like image identification, these are considered hard problems. They're not actually trivial. So when you do a small bit of programming, you think, well, and you get a little bit good at it, maybe it's quite difficult at first, and then you suddenly start to get a little bit better, the experience can be a bit misleading. So if we think of building a bridge, maybe if I'm just building a little bridge over a stream, I can just put a wooden plank over. If I'm building a bridge over the river Severn, that's quite a famous bridge in the UK, it's a suspension bridge, it's a rather beautiful bridge, that requires a lot of thought about how that's going to work in terms of the loading requirements of that, in terms of how it's going to respond in different weathers, how it's going to respond in different temperatures, what sort of materials are you going to use, how are you going to secure the bridge underneath, what you're going to go in terms of the foundations. It's a really, really big job. Not just building the thing, but designing the thing. We're going to look at that designing and building, so we're going to look at that sort of two steps. In general, the difficulty with all software is it's highly complex. OK? So even though there's millions of lines of code, the problem is not just the number of lines of code. Internally, the software can have billions and trillions and quadrillions of different internal states. Because every time I put an if-then statement in a code, that possibly multiplies the number of internal states of the code by two. OK? And I put in 10 of them. I've multiplied the number of internal states by 1,024. I put in 20 if-then's. I've got possibly a million different ways of passing through those 20 if-then's. As I add, because it's sort of complex stuff software, it has internal state, and it has complex internal logic, then it becomes very, very complex as I add in more lines of code. So it's not-- the numbers-- the amount of internal possible states the code has is many, many, many orders of magnitude than millions. Starting to get into billions and trillions. Testing that, making sure it works is difficult. So we want to manage this complexity. We want to reduce the amount of ways the software can misbehave. And we want to deal with it in smaller units that we can understand. So very much like nobody could understand all the 40 million lines of Windows XP in their head at once, we're going to have to actually deal with problems we can understand. We're going to break that up into lots and lots of different smaller problems that we're going to manage. And that's what we're going to do when we design and produce software. So we need to manage that and deal with that complexity, because software very often fails. And the failure can be very, very serious. So if we think of software controlling a safety critical system, a Tesla car now has a self-drive function. OK, if that fails-- well, it does fail. We'll have a look at an example of how it fails in a bit. But if that fails, the results can be catastrophic. If this is driving a car, it's life and death, isn't it? You know, they could kill people. They protect sensitive information. If you have your information and you tell a doctor about a problem you've got, you do not want that information to be on Facebook tomorrow. OK? That would be dreadful. That would be a really-- and it could also be very expensive for the clinic, because you'd get a hot shot lawyer to sue them for millions because you'd be made to look a fool or whatever, and depending. It could be a massive issue. Sensitive data and also money. Cars, software system handles trillions and trillions of pounds of money every day. If they go wrong, you can either have that money disappear in some weird random way, or it just gets siphoned off. Somebody steals it. So in terms of what software engineering must do, it must have produced software which has a low chance of faulting. So that doesn't mean that it has a zero chance of faulting. It doesn't mean that it has no bugs in it, because it's quite possible that it has one bug in it, and another bit of the software works out that there was an error in that code and fixes it. OK, so it's actually possible for software to have a number of bugs and actually never fault at all. So a fault is not the same as a bug. A fault is where the software behaves in a way that is not externally that is problematic. You know it's not as it should behave. So we also, apart from having a low chance of faulting, we need to try and prove that it has a low chance of faulting. So we're going to be looking at testing the software, and we're going to look at how we test it. [VIDEO PLAYBACK] - In terms of what we do in software engineering, it's broken up into four main blocks, and our module is broken up into four main blocks. So the first thing we're going to look at in the lectures is requirements engineering. And that's what the product could do, because if you don't know what it should do, then how are you going to actually work out what to do? So the first thing to do is ask the question, what are requirements doing? Many software systems fail because the requirements are not well written. It's a killer of a lot of products. Then we have to design it. So if you're thinking of your user interface, you want a nice user interface, you want it to look pleasant, you want it to be easy to use. If you want it to be easily accessible for people with visual problems, you might want to put in things that will make that easier, accessibility functions. You want to look at the software internal design of the software in terms of its data and the module. So what classes are we going to have? What data? What attributes? What database tables are we going to have? In each database tables, what rows and what columns? What are the headers in the columns? What are the types going to be? What are the constraints going to be on the data? Is the data some index data? Does it have to be unique? Does it have to be related to some other data? Is the data duplicated anyway across the schema? These are all sort of complex questions to ask in the design. Then we want to code it up and test it. So coding and testing and validation, I've wrapped those up because very often when you're coding, you're testing. You should be. So you should be doing some coding, some testing, some coding, some testing, then integrate together, then more testing and coding. Overall, you're going to do that process and you're going to manage it correctly. Because if you manage it incorrectly, things are going to overrun. You're going to end up-- somebody's going to go off sick who's like a really critical member of the team. And you didn't have somebody to back them up. And you didn't think about that. And then suddenly, everything else is held back because you depended on that person in the process being there. And they went to another organization. So it's complex, managing the process. So we're going to be looking at these in detail. So three hours a week, we're going to-- all these lectures are streamed onto Canvas. If you can't get to a lecture, you'll be able to catch up with it on Canvas. And you'll be able to use the Canvas things to do revision or whatever. So all the streams will be there. So one hour a week seminar tutorial starts next week. So don't turn up this week. Well, you can turn up. But you can just turn up on the-- but there won't be a tutor there. There won't be a demonstrator. And there is some practical work, which is three assignments. The breakdown between the exam and the coursework is 60/40. The examination is a multiple choice test that is done in person in the examination form. The practical is one hour a week. You can use those. So I have put some practical sheets up there to help you, to guide you in terms of the things you have to know to help you do the coursework and to help you revise for the exam. You do not have to do those lab sheets. But those lab sheets are there to get you going, to bootstrap you. So you're not just working from nothing. So they've got some useful questions. And I can also release some sort of answers for them. I do have some answers. But the main focus of the practical session is to start to think about doing your coursework, to use it. So you'll be in the session. You'll be doing your coursework. And you go, oh, I'm a bit confused about this. I'll ask the demonstrator. Or I'll ask me or Henry or whoever's running that lab. The assignments themselves broken into these three blocks. So the first assignment, which has been posted online, is some user case analysis for a building security system. So that's what it is for. It's for a fire alarm, burglar alarm system. So all included in one. So that's been posted online. You can start today, if you like. You can read it. It's written in English. It's not written in Java or anything. So it's understandable. And you should be able to, by having a bit of a read of it, have an idea of what it's about. You should be able to do some prep. It's not that technical in that sense. But there are some things that are relevant to it that we're going to introduce in these early lectures. So I will have an introductory session about that. The first deadline is in November. So yeah, you've got a little bit of time. It shouldn't take too long. It shouldn't take too long. There is assignment one. So it says assignment one. It's 1.1 and 1.2. It's a little, little assignment, a very small programming assignment. Because we were asked to put this in because otherwise, none of the semester one, year two modules had any programming in. So it's just to keep you doing a little bit of programming, to keep your head thinking of code. And then assignment two, modeling with UML, that's the easy assignment. It's usually, most people find that pretty easy. The first two, the first one requires thought and work. It's not super hard. But it requires you to think a bit. It's a bit deeper. Assignment two doesn't require as much thought as assignment one. Requirements are always hard. Requirements are difficult. So it's worth noting. Recommended course textbooks. OK, so Ian Somerville, Software Engineering. It's a very thick book. So maybe get it from the library. You might not want it hanging around the house. It's very useful if you've got a door that you want to stop falling out. It's a good book, but it's a bit long. So what I mean is, he's tried to do everything in one book. So it's a little bit heavy going. A bit more useful is this little one by Stevens and Pooley about using UML. So that, again, I'm pretty sure that's in the library. It looks very old, but it's rather nicely written. In terms of UML notation, just follow what we do on the slides. And that's fine for the assignments. That's plenty. That's not a problem. OK, so we're going to be introducing Software Engineering early on. And then I'm going to be looking at models and requirements. In fact, software models are part of software requirements. So you'll see that sort of part of that. At the stage where Henry starts to take over, he'll be looking at more software design, OK? Now we break it up into modules. Then we'll be doing some how we test our software, how we work out whether it's compliant with the spec, and also in agreement with what the users want. And then we'll look at managing the whole project overall. So what is software? Software is in any of these things. So you've got software in cars now, very, very common. They all have these engine management things. And the software in the car sits in the car. And it works out that you've got a sensor gone wrong in the engine. And it will tell the engineer that. And they plug this thing in, and it says it's sensor 3.8. And they go and they fix it in about two minutes. It's incredibly-- it's very, very cost saving. Because they can do that without scrabbling around, checking every other sensor. It'll tell them which one it is. OK, so it's really nice stuff. Software in your mobile device, in your washing machine to make sure that it washes efficiently, that it works out, that it's got a heavier load. It can feel that. It can have sensors to work out whether it has to do it a bit more or a bit less. There's loads of things that it can use for that. In your DVD player, obviously, there's a microcontroller. There's some software. There's some software that decompresses the image from MPEG into a format that they could be sent out on the signal line. There's a lot of software in a DVD player. Even though they're like 20 equipment each, they're a very cheap thing. It's a mass-produced item. The software in there is quite deep. There's some really complex stuff. Software in airplanes, yeah. Software to do the in-flight entertainment, even fly-by-wire now, which is a bit dodgy, but mostly works. Any modern developed nation depends for a large amount of its activities on software. OK, so it's a really, really core activity. That's why there's a lot of jobs developing software because software is part of a modern economy. It's really important. Healthcare, legal things, there's so much that relies on software. Most systems now have some degree of software control. And software engineering, which we're going to be doing in this topic, is associated with producing professionally software. So theories, methods, tools, anything that goes into that. And there is safety-critical software. And you can easily tell that software is safety-critical because if it fails, there's a risk of loss of life or physical injury or harm, anything like that. So evidently, air traffic control, if that goes wrong, very serious matter. Medical software, if that goes wrong, it's going to kill somebody, isn't it? It's not going to be very safe. Nuclear reactor, if that goes wrong, well, horrible, isn't it? Like me. So there's some frequently asked questions, which hopefully you know the answer to most of these-- some of these, anyway. You might know what is software. We're going to answer that. What is a software process? So maybe some of you will have a bit more of an idea of what that is by the end of today's lecture. What is software engineering? Hopefully you're getting a bit more of an idea. And the software process model, which we're going to introduce. It's worth noting now, because we're living in an age of increasingly application of AI, that the software itself, in terms of machine learning, consists of a network which is trained with a number of internal weights. So the network itself doesn't really do very much until it is trained with the appropriate weights. Because a network, you can have the same network applied to many different problems, depending on its training. So the training, in terms of the net, is the software, because it's the thing that changes. So when you have a net that's been developed, it's developed once in terms of its structure. And then the training is the weights that go into it. So weirdly, when you deal with a net, like a neural net, the training is the data that you end up with. That's the thing that tells it what it's going to do differently than any other neural net. So if I take this neural net and take the same neural net with different training, it can do a completely different thing. One of them might work out what brand of shoes you're wearing. OK, because it looks at your shoes and go, that's a Nike, whatever, whatever, because it's trained in a particular way. Another one might look and work out what type of jacket or what type of dog you've got. You look at it, you go, it's a Beagle, or it's a Chihuahua, or whatever. You can get them to do that. So depending on the training, it makes different software. In terms of the implications for us, in terms of running software, because the model is so extremely hard to understand, down to every node level, because it's so horribly complex, is that how you analyze those are probabilistic. So you say, we get a 95% chance of working. So it's very different than standard software, where we say, well, we think we've done all these tests. And we say, pass this test 100%, pass this test 100%. With this, you'd say, we pass to a 98% level. We can do 98% of all training shoes and work out what make and model they are. OK, so it's a different type of quality assurance in AI than in other types of analysis, because it's somewhat complex. There's a lot of different software products. So you can have games. So some of you might want to get into game development. You can have software that runs the servers, receiving requests and sending stuff back. Software that manages a database. So it might be a relational database. It might be a non-relational type databases, like Mongo, stuff like that. You've got every computer language you work with is software. So Java is software. It's got two bits to it. It's got the Java compiler, which takes all your code and analyzes it and produces byte code. And then you've got the Java virtual machine, which is an interpreter, which takes that byte code and executes it and runs through it all. You've got crypto coin software, apps, et cetera. Associated with that also are the documentation of the software. So we have to produce to produce a proper piece of software. We often have to support it with some documentation. So software engineering is a disciplined approach to producing that software. So you, if you're being a software engineer, you have to adopt this approach. So you have to have an organized approach to work. You have to work out what you're going to do first, second, third, fourth. And you have to consider how you're going to do that, what the problem is. You're going to need to do your requirements, the development constraints, and work with what programming language you've got available. But there is-- the best way to see it in terms of software engineering is think of the types of habits and the types of things that good software engineers tend to do. So this tells you something about the process of software engineering. So a good software engineer tries to not keep making the same mistake multiple times. So if you're making errors or faults and you find they're happening again and again, then it's worth documenting your mistakes. Keep a log book. You should be using approaches that have been done before. You need to be able to work in teams and communicate well with other people as a software engineer because you very rarely are going to spend your life working on your own. You're going to have to work with other people. You're going to have to be spending a lot of time testing your code and producing code which can be easily understood by other people if you're a good software engineer. That's really important. So make sure you're able to communicate your ideas. And this final one, which is really hard, predict your own productivity. If I ask you to do a problem in software, you say it's going to take three days. Hopefully, it takes three days. Hopefully, you don't finish it in a day and spend two days going down the pub. What you're meant to do is you should have said one day then, really. And then hopefully, you don't take five days to do it. You have to be able to work out that. That's really tricky. And in general, being a good software engineer is not easy. And it takes time. So do not despair if you're struggling with some project work or some development work while they're at the university. It takes time and effort to get up to that level. It is a really complex and highly skilled job to be a good software engineer. It requires effort and skills and application. There's plenty of software failures. So I listed a few up here, some more recently. And I've got some more recent examples, too. The thing is about a lot of these is they're not all to do with failures of the software. Some of them are down to vulnerabilities in the software. So this one, Colonial Pipeline, is a company. They got locked down. It actually shut down their fuel pipeline to the eastern USA. It actually shut down a lot of-- fuel could not move from one part of the United States to the other. And it was an attack which was resulting in their software being vulnerable to attack. So obviously, the software might have been totally bug free, but not be hard enough, hardened enough against general attacks. Tesla recall vehicles down to software faults. So because software's in vehicles all the time, there are faults in this. Have you ever heard of this? This is Log4j. It's a logging API, which is very widely used by lots of people. It's an open source API, so anybody can use it. And obviously, lots of people do use it. And then because lots of people do use it, it means that one attack on it, if it's then vulnerable, can leave many, many systems vulnerable, because they're relying on that being a good piece of software. And then here's some examples of software which is critical. So this Therac-25 was a radiation machine. Somebody died with this one. So that was a serious fault. The software process and the software process that we describe in this module are the things that you need to do to develop or evolve your software. So that means you produce the first version or produce subsequent versions of the software. In general, it's broken into these four parts. So the first is the requirements production. So that's what we're going to do in the first few weeks here. We're going to look at requirements. The next one is the development of the software. So we have to do design and implement it. So you're going to work out-- if we're doing OO, we're going to work out what classes we've got. We're going to work out what tables we have in our database, what algorithms we need to design. And then the validation is checking that the software is what you actually want and then evolving it, changing it as it moves forward. So generally, the software, apart from just performing and being usable, has to be changeable to make sure it's able to do other stuff. So the software needs to do the original functionality. But it must be easy to change if you have requirements that change through your software. So an example of software that's very difficult to change, for example, because it's usually best to give a counterexample, would be if you did a web page and all the text in that web page, you just typed into that web page. So why would that be a really bad-- why would that be hard to maintain? So if I got a web page-- so if I had a web page, and it said log in, and then I put the word username on the web page, and I put the word password on the web page, any thoughts about what I want to do to maintain that or change it or whatever? What if I wanted to change the language of that? What if I had 5,000 web pages all written in English with the English embedded in all the web pages? That's going to be a horrible nightmare. It's going to be a real mess. The reason why it's a mess is that you do not want people who are experts in changing language to start messing around with your software, because the text is inside the software. What you do is you have a separate file with all the language strings defined. You load those directly from that, and then they're allowed to translate the file. So it's just a comma separate variable as it says text, comma, log in, and then you say that equals log in. And then they're allowed to change that. They save that as a German one, and they change them all to German or French or whatever. Or use a machine to do some of it, and then you get it tested and whatever. So it must be easy to change it to evolving needs. It must work with all data. It must be totally dependable. It must be efficient. OK, it mustn't be too slow, because if it's too slow and it's working in an environment where performance is critical, then that's going to cause you a lot of problems, particularly as the system scales up, you've got more users. And then it must be easy to use. Also associated with software and production of software are a number of ethical issues. So again, we're going to introduce that a little bit. So one of the ethical issues is the software and the software engineer has to act in a responsible way. So if the software itself, for example, does things like releases data that goes against the Data Protection Act, then your software itself has been written in an unethical way, because it's not been written in consideration of the ethics. So that ethical behavior is-- there is a number of ethical guidelines that have been listed out by the British Computer Society. So we're going to look at those in a little bit of detail in this module. So here are some example issues. So generally, if you're working on a project, you have to respect the confidentiality of the person who employed you on that project. So you mustn't give stuff away, even without you signing a NDA. Generally, most companies do ask you to sign some sort of NDA, but that's beside the point. You shouldn't be giving any information anyway. You shouldn't say that you're better at doing stuff than you're not, or you have expertise in a field that you're not. That's unethical, because you're miss-selling yourself. OK, that's a lie, isn't it? When you have software, very often software involves other software that has a certain amount of intellectual property. For example, there is a compression algorithm called GIF, G-I-F. That had a patent associated with it. And everybody who used GIF in their commercial software had to pay GIF, had to pay whoever-- I don't know, whoever owned GIF-- for the rights to use it. So you have to be careful when you're putting that into somebody's software that that is acknowledged, and you actually comply with any local laws of producing any patent. You also shouldn't be misusing computers for software. So an example of ethics and software engineering are things like self-driving cars. And we can see a problem when that goes wrong, because that's the result. That's software failing. You can see it is stark. 17 people have been killed in relationship to that fault, whether it was the software or not, but they were associated with the autopilot function. So a number of crashes, some of them involving fatalities. So the failure of software. So when you think of that, whose responsibility is it for those crashes? So if it fails, who's responsible? Are you responsible of the driver of the car? Is the person who wrote the code responsible? Is Elon Musk responsible? That was a Tesla car. So that was a very sophisticated car. It gets very difficult. And one of the interesting things about this ethically is that even if self-driving cars are safer than cars driven by human beings, it may be difficult to have self-driving cars if they fail sometime, because you don't know who's responsible for that failure. And until that can be worked out, that ethical framework, you've got a difficulty in implementing that whole thing. And that's a whole problem with AI and intelligence associated with software and what responsibilities you're allowed to give it. So we've had a quick introduction to the topic and what it's about and what the products are. And I've had a discussion about the ethics of software. We're going to be looking at-- next lecture, we're going to be looking at a software process. So hopefully, we'll all manage to get settled down a bit quicker in the next lecture.