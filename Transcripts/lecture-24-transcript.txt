[SIDE CONVERSATION] There's the attendance code, and we'll start in about a minute or so. [SIDE CONVERSATION] OK, so I'll put the attendance code back on at the end of the lecture. But happy Monday, everyone. Welcome back to software engineering. Today, we're going to continue talking about testing, specifically today more about software testing. So last lecture was more about interface testing, where we actually look at the code by dry reading it and making sure that it's all up to-- that we're following the naming convention for variable names and making sure that the code is actually suitable just by reading it as opposed to running the software and producing tests. So yeah, today, software testing. So we discussed briefly in the last lecture defect testing. This is just testing that you do to see if there are any system defects present in your system. So we're going to talk about the idea of this later on. So the objectives of this lecture is to understand testing techniques so we can discover faults in our program, introduce guidelines for interface testing-- oh, too short back. Specific approaches to object-oriented testing and these objectives are out of date. So topics covered in this lecture are defect testing, integration testing, object-oriented testing, and testing workbenches. So with the testing process, there are two types of testing. There's component testing, where we actually test individual components of our program. So you might have a whole program. One component of that is the login component that handles username and password and ensuring that users can log in. So if you were to do component testing, you would specifically just focus on different components of your program. So you would just focus on that login. So you would test that. The user can do their username and password and ensure that component is working. That is the job of the component developer, usually. So whoever wrote the login system would ensure that the login system worked before they gave it to the rest of the team so that it can integrate it with the whole system. Then we have integration testing, which is the whole testing of the whole program. So you're testing groups of components to create a system, like the whole system, or perhaps a subsystem of your program. That login system might be made of multiple components. And if you tested those multiple components, you could test the whole login system. Or it might just be the whole program as well. And that's done usually by an independent testing team whose job it is to test multiple components that make up subsystems or perhaps the whole system itself. These tests are based on the system specification. So all your components should reflect what has been asked by somebody who's requesting you to implement their software. So therefore, your whole system should reflect those specifications that have been requested of you. So you would do component testing first, which is done by a software developer. Once you've done the component testing, then you would start to do integration testing and making sure all those components work together to make your whole system. So back onto defect testing. The goal is to just discover defects in the program. And you always want your defect tests to make sure that they actually find defects. Because your defect tests will show the presence of defects, but they won't show the presence of-- but they can't show the absence. So no matter how much you test, there might be a chance that there will still be a defect within your system. So it can show the presence, but not the absence. So you need to discover those defects. And until you discover those defects, you don't know that they're there. So you need to discover those defects. You don't know that they're there. So the only way, really, is to discover if there is a defect in your system is to do exhaustive testing, which is just test every single possible thing that you can input into your program, every possible thing. And that is just unreasonable. It's just unreasonable and impossible, because there isn't infinite values in the computer, but it's still quite a lot. There's so many different combinations of inputs that you could give, which would just be impossible to test. So your test is the priority of tests. Another test and priority is that your test should exercise the system's capabilities rather than just its components. It's more important to test old capabilities than new capabilities. The reason for that is if you put in a new capability, you might break old capabilities. So it's always better that when you add something new, you need to check that everything still works. And then testing typical situations is more important than boundary value cases, because more often they'll not unless the user is-- nicer way of saying stupid. But it is more important to test the typical values, because that's more or less what you're going to receive most of the time. Now, you will receive boundary case values, and it is important to test for them. But the important thing is that the typical situations that you're dealing with, the typical inputs that you'll receive from the user, it's important that you test for those rather than the boundary case values. But it is still important that you test the boundary case values. So we have test data and test cases. So test data being inputs that you have devised to make sure that you can test your program. So you list the test data that you'll use. And then your test cases are your inputs to the test system. And-- oh, sorry, the inputs to test the system and the expected outputs that you'll receive. So if you were doing a test for a login, you would-- well, as it says on the next page, actually. This would be your test data, really, your input data. So I'm going to use the username test1 and the password pass1. And then the whole thing is a test case. So you have your input data, the expected output, the action you're going to perform. You're just going to click Login. And then this would be the actual output here. The login was OK. And it's a success. So this is a test plan template. So you just need the name of the test case. So we just want to-- we'll just call this one Login OK Pass. We expect it to pass. And happy days it did. Then we try a pass being password. Then we have Login Bad Pass. So in this case, the input data, we've still got test1, but the password is pass2. And then we expect to fail to login, which happens. So this test was a success. But this last one here, Login No Pass, was a no password. We don't have a password. We click Login. We want it to fail the login. But in this case, the actual output was we were able to login, which means this test failed. So that's your test plan template. And those test plans would look like this. You have the name of your test case, the description of it, the input data, so what data you're going to give into this test, your expected output, which the actual output needs to match for your tests to be a success. Otherwise, your test failed. So this is the defect testing process, where you design your test cases. And you prepare the test data. And you run the program with that test data. And then you compare your results to test cases. So after you design the test cases, you create them. You then prepare the test data. And you get the test data. And then it just feeds all into this one. So at the end, you come out with the test report so that you can show your whole team, oh, when testing this, this and this and this was successful. There's a problem with the login system. So you have to fix that. And that's the defect testing process. So to quickly recap on defect testing, you want to set up the test cases so that you will try and find as many defects as possible. Because the more defects you find, that means the fewer that will actually be hiding and away in your software. So we have this new notion of black box testing. So this is the approach to testing where you treat the whole thing as a black box. So you don't know what's going on inside. And the whole idea is that you'll use black box testing to just test the whole system specification. So this would probably be more integration testing. The nice thing about black box testing is that you can begin your test plan earlier on in the development process or the software process. The reason is if you're testing against the system specification, you know exactly how the program should work. Therefore, you would create your test plan very early on. And then, yeah, it's just a little diagram for it. So this input causes anomalous behavior. It just goes into the system. And this output shows the presence of defects. So this whole system, we just treat as-- you don't know what's going on inside. You're treating it as a black box. You only use it to make sure that the system specification is there. So it's different to white box testing, which we'll see later on. But white, just as a quick teaser, white box testing is where you know the components of your program and you use your components of the program to create tests. Whereas this one is just purely testing the whole system specification to make sure that it meets the user's needs. So there's this new notion of equivalence partitioning. So this line here, input data and output results often fall into different classes. So more clear on the next slide. But say for an email, you need to have the at sign to say what domain you're part of. Now, that input data could be placed within-- if you created input data, you could create classes of input data, not to be confused with class models, treat them as actual-- just like classes of input data. Input data that would pass and input data that would fail. So if you're doing it with an email, you could have input data that would pass would be emails that contain at signs. And then input data that would fail, you would have input data that would have no at signs. And you would expect the input data that would pass the ones with the at sign, you would expect all of those to pass. And you would expect the other one to fail. So those are how the members of those classes would be related, whether they had the at sign or whether they didn't. So what you do is that those-- what you would do is you would create batches of test data with at signs and those without at signs. And then you would distribute them out into a little bit into different tests. So you could use any of the emails with at signs in the tests that require it. And you would say, OK, we'll use this data because it should pass. And then on the other side, you would say we've used this data because we'd expect it to fail. So you divide them into classes where they would behave in an equivalent way, no matter what the test data says, apart from it would have an at sign or it wouldn't have an at sign in the case of emails. So you should take the test cases from each of those partitions, we call it. So you would have-- so ignore this middle one here. But say these three are invalid inputs. And these ones are valid inputs. You would take a number of those test cases from the invalid inputs and the valid inputs. You'd put them through the system. And then you'd either get invalid outputs or valid outputs that you're expecting, basically. So you generate test cases that you would expect to pass or you'd expect to fail. And then you would divide them into two different data sets or class sets or whatever you want to call it so that you would have test cases over here that you would expect to pass, test cases over here that you'd expect to fail. And then you would pick a number of them from each group. Then you'd put it through your system to check whether they would pass or not. So you can test with different data. So yeah, you put them into what we call equivalent sets. So if the program accepts a five-digit integer between 10,000 and 99,999, your equivalent partitions would be anything less than 10,000, between 10,000 and 99,999, and anything greater than 10,000. Yes, it should be correct. Or rather, 99,999. That's a good point. Thank you. So yeah, anything less than 10,000, anything between 10,000 and 99,999, and anything greater than 99,999. So you would choose the test cases at the boundary of these sets. So 0, 0, 0, 0, 0, 0, 0, 5-digit number, all zeros. That's fine. That's boundary data. You would choose 0, 9, 9, 9, 9, 9, which you would expect to fail because it's less than 10,000. Then you could pick 10,000, which you would expect to pass. You could pick 99,999, which you would expect to pass. And then you can pick 10,001, which I think should say 100,001, which you would expect to fail. But if it was 10,001, you expected to pass. Now, because these are on the boundary, these are more likely to display erroneous behavior within your system. That is because when you're doing your if statements, you will have less than a number or less than or equal to a number or greater than or greater than or equal to. And that's where erroneous behavior usually develops in software is when your if statements are checking for something equal to as well, and whether it should be less than or equal to or just less than. So that's why you want to check these boundary data, because your if statements are usually where your program begins to show erroneous behavior. So to picture that with what we had on the last screen, with this screen, we have these three equivalent partitions. So we have less than 10,000. So you can try 9,999. You have 10,000, which you'd expect to work, 50,000, which you'd expect to work, 99,999, which you'd expect to work, and then again 100,000, which you would expect to fail, because you would want it in between here. And that's the same for this one here as well. So three, don't want to work. Four and 10, anything between there you'd want to work. And then 11, you wouldn't want to work. So we have this search. So to continue about equivalence partitioning, we have this search routine specification. So it is just a-- this is its signature here. So it's a procedure called search. It accepts a key or an element that you're looking for and the element array as well. And then there's this-- oh, OK, yeah, we take this-- I don't know why it says in. It should be out. So found should be a Boolean, and L should be the element index of where it was found. So found is whether we found it or not, and L is the actual index of where we found it. So it has this precondition that the array has at least one element. So for that to be true, we need t first and t last. So this is how you would define the preconditions for this search to actually even work in the first place. So this is the precondition that has one element, and t last must be greater than or equal to t first. The postcondition for finding it is the element is found and is referenced by L. So we need to have found it. And so found needs to be true. And t and tL must be equal to the key that we passed. Or the element-- the other postcondition for a success is that the element is not found. And I exist, and also not that I exist. t first is greater than or equal to i, and t last is-- sorry-- is greater than and equal to i as well. So we don't want these two values being the opposite side. And also that ti equals the key. So these would be our input partitions for this search routine. So we'd want inputs which conform to the preconditions. What were the preconditions? Anything where t first is greater than or equal to-- sorry, t first is less than or equal to t last. We'd want to test that a precondition does not hold. So you would want an array that has no elements. So t first would be greater than t last. An element where the key element is a member in the array. So you'd want to make sure that that conform-- so you'd want a precondition-- oh, no, sorry. You'd want a test where the key element is a member of the array. So this one here, you'd want this one. You'd want to make sure that this postcondition is met. And you'd also want an input where the key element is not a member of the array. So you'd want this one here. So those would be your input partitions to make sure that you're testing everything about this function. To make sure that the precondition is met and either of the two postconditions are met. And that your program doesn't-- to make sure that if the precondition isn't met, then we don't check the postcondition. That it wouldn't begin looking for the postcondition if the precondition wasn't met. [SIDE CONVERSATION] [SIDE CONVERSATION] OK, so this had me confused for a second. So if we were doing this with sequences and we were testing software, if we were checking through some sequences, we'd want to test software. We'd want to write tests and input partitions where the sequence only has one value. We'd want to use sequences of different sizes and different tests and derive tests so that the first middle-less elements are accessed. So we'd want to check through all of the-- we want to derive a test so that we can check the boundary cases and also anything in between. And we'd also want the tests as sequences of zero length. So this comes into the search. This is still talking about the search. Yeah, sorry. So that confused me for a second. So this is still talking about the search. So this is how we're going to test it. So test, if it only has a single value, we want to test sequences of different sizes. So we might want a sequence of one. And then we want to test sequence of three to make sure that it isn't just one value of the sequence that doesn't only have one value where search works. We want to test so that TL is either at the first position, the middle position, or the last position. So we want to test that it can be found in any location in the array. And then we want to test at zero length as well. So for the search routine, these would be your input partitions. So you'd expect-- so you'd have these two input-- well, these are the input partitions. And you'd want one of your input partitions to test that there is a single value in the array and that the key element is in the sequence. So the element that you're looking for is in the sequence. Then you would also need to test that there is a single value in the array. And then that isn't in the sequence. You'd have an array with more than one value. And that would be the first. And you'd want the element to be in the first position. More than one value, you'd want to test that it was in the last element in the sequence. More than one value to check that it was in the middle element in the sequence. And then more than one value that it isn't in the sequence at all. And then this is how you would satisfy these. So you have your single value. It's just 17. And you're checking that the key 17 is in there. And then this would be your output, whether it's true. This is the output here, that it was true. We did find 17 in the sequence. And it was at position 1. Again, here you're using the same input sequence, which is just 17. Your key is 0. And then it doesn't find that element. So it's false. And the question mark meaning, well, we didn't find it. So there is no position in the key. Then we have this other one. We got this other test sequence now. This other-- yeah, another test sequence. We're looking for 17. This meets this one here, where it's more than one value. And it's the first element in the sequence, which it is. 17 is here. And we'd expect it to say true. And that it was in position 1. This input sequence here, where you're testing for the last element in the sequence, and he's looking for 45. You say true. It was in position 7. Now we're looking for the middle element in the sequence. And we say 23. And it says true. It was at position 4. And then the final one, more than one value, and looking for an element that isn't there. And we say false. It's not in any position. So that would be how you would define your input partitions, is you would identify the preconditions for it to work, and also your post conditions for whether it should or shouldn't work. Then you write out your testing guidelines. So you'd want it to conform to the preconditions. You'd want an input where the precondition doesn't hold, the input condition where the key element is a member of the array and where it isn't a member of the array. Then you use this to create some more in-depth input partitions, where you can say the array must have a single value. And it must be in the sequence. And we must also test that the array is at least a single value. And it's not in the sequence. Another one they should probably test for here is that the array doesn't have a single element to make sure that that works as well, that it wouldn't even begin searching for it. So that was input partitions. Does anybody have any questions on that quickly before I move on? I know it was very repetitive. Cool. So structural testing and also called white box testing. Like I said earlier, it's where you know what's inside the program. You know what components there are. And you use those components to derive your test cases. And then your objective with white box testing is to use all the program statements that exist in the program. So every single-- so your if statements, you'd want to make sure that all your if statements can pass or fail based on what you give them. So your component code derives the test data. And then you test the component code. And then you keep on doing this loop. And then you get these test outputs as well. So we have this binary search here. That's written in Java. So the equivalent partitions for this would be pretty much the same as the other ones. So we want to meet the preconditions. Mainly that our element array is actually at least one value. That would be the precondition. And that your key element in the array, then the key element not in the array. And you'd want to check that your preconditions are unsatisfied and that the key element is in the array and the key element not in the array. That would be other preconditions. I can't think of one. But yeah. You want the input array to have a single value. The input array to have an even number of values. And the input array to have a number of values. And then you would pick test data on those boundaries. So you'd want the elements to be less than the middle so that there is actually a midpoint. And then you'd want the elements to be greater than the middle as well. So yeah. So you would need to find those equipment's test boundaries and then separate your test data so that it meets all these partitions. So that it counts for all the partitions. And then your test cases for binary search would be like this. So your input array 17, you have found true at one. And then just like we did before, where you'd want it at the first position, the middle position, and at the end position. And you'd want to test with more than one element in your input array. So now we have this idea of path testing. So you'd want to make sure that each path in your program is executed once. And these paths branched off when you have if statements. Because you'll have-- there's one path of code where if this if statement is true, you would go down this route. And if it was false, you would go down the other route. And the starting point for this path testing is you just draw a graph of basically all the if statements in your program and then branch off based on the program decisions that it makes. So yeah, your nodes represent the decisions. And then the paths show the program flow. And also for loops as well would be considered a decision in your program. So yeah, program flow graphs, they would describe your control flow of your program with nodes branching off one another. So nodes that would branch off at two places being if statements. You can either go down this route or this route. And then for loops and any loop condition being just looped back to itself. And then you can use this as a basis for cyclomatic complexity. So this is the number of edges. Take the number of nodes plus two. What is cyclomatic complexity? It's the number of tests that you need to test to make sure that all your control statements have been accounted for. So how many tests, how many different tests do I need to do of all my control statements do I need to do? So that's what cyclomatic complexity will tell you. So it equals, always equals in your program. If you count all the if statements and for loops, it's the number of conditions plus one. And that will tell you how many tests you actually need to do to make sure that you test every single flow path in your program. Now all the paths are executed, but all the combinations of paths are not executed. And that is purely probably just to avoid complexity, because there could be. But maybe you had 1,000 if statements. Your program just consisted of very sequential code and 1,000 if statements. You would have to do 1,000 plus one different tests to make sure that you go down every single path. But if you were to test every single possible combination, I don't know the maths, but it would be a very big number of tests you would have to do. So that's what cyclomatic complexity tells you. OK, so the key points of this lecture are you test parts of a system which are commonly executed. Equivalence partitions are a set of test cases where you expect the program to behave in an equivalent way. So if one thing is part of one equivalent set, you would expect every single test case within that equivalent set to produce the same answer. Black box testing is based on the system specification. So when you're doing black box testing, you should pretend you don't know what's going on in your program. And you should just test it to make sure it meets all the requirements. And structural testing, otherwise known as white box testing, you identify the test cases that can make-- you test all the test cases where it will branch down each decision that your program makes. So you want to test every single path in your program just by checking all the if conditions. If there are any questions, I'll be able to ask them at the end. Probably that one. Thank you very much. And I will see you all very soon.