[SIDE CONVERSATION] Everyone hear me? I can hear myself. Cool. OK, so hello again, everyone. You weren't here yesterday. I'm Henry. So today, we're going to just look at an introduction to UML, otherwise known as Unified Modeling Language. Yeah. We can see how by using UML to help us communicate our designs of a system, we can reduce any ambiguities and, again, communicate our design for a system quite well. So this is just an introductory lecture. So we're going to look again at use case diagrams and how they're useful at understanding what our users need. Looking at class diagrams and understanding how we can split our design into different objects that all have different roles within the system. Sequence diagrams to see how-- to have a dynamic view of how our system should work in what order. And then just very briefly on state diagrams to show how the state of a class or your system can change. So the problem in any task that you're trying to implement is always understanding how you can design that task you're trying to implement. That's always the hardest part. But assuming you do that well, then the implementation should be easy. So as long as you design something well, you should then be able to implement it. The problem is trying to design around the requirements that a company or person or any entity has given you to. So designing, how can you implement that problem? And how can I design that problem so I can easily implement it? So because I just seem to be given the case study lectures, we're going to have a look at another small one, but not as in depth as the one we were doing yesterday. So we've been contacted to develop a computer system for a university medical clinic. And they need these three types of services, staff management, booking appointments, and keeping records also. So you or we have been asked to build an interactive system that can do all of this online because everyone's online these days. 10 years ago, we couldn't wait for that. So we've been given a problem. And now we need to clarify those requirements. So different users have different priorities. So as it's said here, we have an interactive system that can do all of these things-- staff management, booking appointments, and keeping records. All of the people in charge of those aspects will all have different requirements and priorities. When it comes to who are the users, a lot of the time, you will find that they don't really know what they want. They don't have a clear idea or easily express for use. They have an idea of what they want, but because they don't know anything about software engineering, they can't express how they want their system to work. So you've been given a description by someone who doesn't really know what they're talking about. Well, they might have some idea of what they're talking about. They know their business. You know yours. But it's hard to imagine most sometimes what they actually want when you're given their description of what they want. So that's the challenge in taking what they want and then converting that into a design so that you can then implement a nice system for them. So we'll have different things included within the requirements. We need requirements for doctors, patients, admin staff, appointments, and also treatments. So ignore that. So back onto use case models. For it to be a good system, quite simply, all it needs to do is be able to do everything that the user needs to do. So they've given you an idea. All you need to do to make it good, of good quality, is simply just make sure all the users can do what they need to do. So this takes us into a user-oriented approach. So if you can accommodate the needs of every user and make sure they can do everything they need to do by focusing on what they need rather than-- no, wait a minute. Then, yeah, you need to have a user-oriented approach. And then you will end up with a good system, good high quality system. So therefore, how do you know what the users want with a given system? You need to identify the users and all the tasks that they perform. And then you can see how the tasks that they need to perform will more or less come into the use case model. And you also need to know the priorities of the users. So what tasks are most important? If you can do the most important ones first, then you can plan the development better, more on that later. But you need to identify the most important tasks and then assign them to the most important users. And then you need to identify the users and the tasks that they can perform. So it all comes down to making sure that you can identify those key things. So the unified modeling language, or UML, uses technical terms as actors and use cases for users and tasks. So an actor is a user of a subsystem in a particular role. An actor can also be an external system. So in this case, an actor within the specification that the university medical clinic has given us, a receptionist would be an actor. So that would be the person who interacts with on the front lines dealing with the patients and booking appointments, canceling appointments, making sure that the patient is connected to the actual clinic. Then the use case would be the actual task of the receptionist. So the receptionist books appointment, then it's fairly clear we might have a use case called book appointment. They might also do other things. So this leads us onto this use case diagram for the clinic. So it's not just the receptionist that is an actor. There is also a doctor, a patient, and a pharmacist. Schedule appointment is also here instead of book appointment. But it's there. So yeah, you can see every single actor has its own responsibilities. You guys know because you've been doing a use case diagram and assignment for like a month now. But that's more or less what a use case diagram is expected to look like. You've got the actors on the outside who are external to the system. You have your system box here that says everything in here is part of the clinic system. And then you have all the use cases that occur inside that actually happen within the system. But the actors are the people or things that interact with-- that are outside the system but interact with the system. And this thing here with the doctor inheriting receptionist would probably-- what does mean that the doctor can do everything that receptionist does as well. But the receptionist can't view notes, add notes, or issue a prescription. But the doctor can do the viewpoint and schedule appointment and cancel appointment as well. And then the patient over here can just repeat prescriptions, which issue prescription and request repeat prescription aren't connected because they don't need to be. They're just two different things that both the doctor can do and a patient can do. Those two things don't need to be linked. So have a think about that for your assignment as well. Because I've seen some complicated use case diagrams. To reduce risk of completely creating a really, really complex idea from the start, sometimes it's better to just do things in steps and design the system in steps. This means that you can identify the most important things first, so the most basic and essential functionality. So that's what your first iteration would include. So you would identify the most important things that need to be done. Have them work in their own way. When you come around to the later iterations, you can start adding extra stuff to that, but making sure that those basic functionalities are still contained with their own-- in their own, let's say, space so that you don't accidentally make something too complex. Main point of use cases is to make sure that there is clear rules and divided lines between two different things that actors can do. So it's important that the doctor issue prescriptions and that a receptionist does not. Just by seeing a use case diagram, you can see clearly the responsibilities that each actor has, which ones should they perform and which ones should they not accidentally perform. This one is important as well. Don't try and create new requirements outside of the scope that you have been given. Users-- or some people can be-- it can be difficult for them to communicate what ideas they want, but you shouldn't go inventing new things. Because it can be easy to think about-- oh, OK, well, they want this. Maybe it would be useful for them to do that as well. So yeah, for example, it might be good to inform the doctor that a drug is out of stock or something like that, which would be useful. We can all agree. But it might not be what was requested, and therefore you added extra stuff when it wasn't needed and the doctor didn't actually want it because now it's too complicated. And if you keep on doing that, you're getting an overload of information. So always keep it to what was requested when they gave you some form of requirements. So in that case then, when we have this new first iteration, we can just see the key things. We've ignored the doctor and the pharmacist. And instead now, we just have the receptionist can view and schedule and cancel appointments. And the patient can just rebook an appointment and request repeat prescription. So yeah, just what I've said there. Let's suppose I have to discuss some priorities. We decide the first iteration system should provide just these key things. Then once you've designed those things and made sure that that is what you want, then you can start adding, OK, what else have they given us that's important that we can use to deliver on what they've requested. So the advantages of use cases, the first one, it's easier to identify the amount of time it might take to implement all the required features of the system. So you can clearly see. Right, OK, so try and think of an example. This one. Try and think of an example of this one. OK, I can't think of an example given with what's been given here. But what it does allow you to do, like it says there, is you can look at, OK, so it might take-- well, the first thing we're going to have to do is, we're going to have to allow a receptionist to schedule an appointment for a patient. So that's the first thing we're going to need to do. We're going to have to build a database and build up the code so that that can happen. And then once you've done that, you can say, OK, so that will require building the framework. That'll take a lot of time. But when it comes to canceling the appointment, you've already got the framework there. All you need to do is remove it. So as you can identify which use cases are more important to implement first, then you can go, OK, well, that one won't take as much time. So let's just focus on-- then we can start planning around how long it'll take for the other ones. Like this one as well, you can identify which requirements are important. So by providing, like I just said, if you provided, like, OK, so we've built the framework for the appointments because we can now schedule them. This means it was easy to then add in functionality to cancel them. You can show the potential values. You start to do the most important things first. If you've got the most important things implemented first, you can then kind of convince your bosses or whoever it is that, OK, look, we've already got this thing established. Please don't cancel our project. And then your boss will go, oh, actually, you've done an all right job. So we'll keep the project. By identifying use cases, you might be able to identify, OK, that's a risky one. That one will be challenging. If we can tackle that one first, then adding the future ones-- oh, yes, if we can tackle that one first and implement it, build up, like I said, the framework before, always comes back to that one, then you have more flexibility later on to just do other things. So don't leave the most difficult one to the last minute. Always try and get the most difficult one out of the way first so that later on, all you need to do is start making it look pretty. And then that comes into terms of resources as well, like money, time, and design choices. And then finally, when it actually comes around to testing your system, you can easily use the use cases to make sure that your program or your software that you have implemented can easily just tick off. Can the user do that that we identified in the use case too? So it's good for validation checks. So moving on to classes rather than use cases now. You talk about key domain abstraction. So I just said that. In the standard jargon of analysis, we talk about key domain abstraction. So what can you abstract from the key domain? So how can I abstract all these classes? So that they are not-- we can remove information that just isn't necessary. We can do that like I talked about in the last lecture. Now, identification technique. So just going through a big document that's been given to you. So take a coherent, concise statement of the requirement of the system. Underline its noun and noun phrases. So identify the words and phrases that denote things. And then this will give you a list of candidate classes, not all the classes. So once you have your list of candidate classes, you can then begin discarding. You can then begin discarding. So like clinic, it's outside the scope of our system. Urgent appointment, redundant, because it will just be covered by the appointment anyway. Stuff like time, don't need it. Free slot, too vague. And system, because it talks about the whole of the requirements description, not a part of the domain. So then after doing all of that, that would leave us with just these six classes here, which is doctor, nurse, receptionist, patient, appointment, and prescription. So that's what you would do. The other one is you might need to infer classes like we did in the last lecture. So there might be some stuff there which isn't present, but we would need in order to make the system work. And the other way around, like all these ones here, we don't actually need those ones, because they don't help. They wouldn't help if we turned them into classes. So after getting your list of classes, you need to identify and name the important, the important ones, the important real world relations or associations between them. So not only do you clarify the understanding of the name, but you can also then begin-- if you clarify, OK, this is how these ones interact, these are the relationships between all these other ones, you can then start understanding. Easy. You can begin to understand your own system easier. And also, you can then sanity check the coupling to make sure that you're modularizing your code well and also that you've got a low coupling. You want to reduce as many interactions as possible. So this is an example of the relations for the clinic system that we've been given, that we've identified. So like before, we only have doctor, prescription, receptionist, patient, nurse, and appointment. And then we have here multiplicities. So like I said last time, an appointment has one patient, but a patient can have many appointments. The doctor cares for many patients, but a patient usually only has one doctor. Doctor can give out many prescriptions, but a prescription only has one doctor. So that's what that is. And then you can also see here that a doctor cares for a patient, a nurse treats a patient, the patient attends appointments, a receptionist books, cancels, rebooks, appointments. But you can see here that by reducing the interactions between different classes, in this case, that the receptionist is not directly linked to the patient, but only linked to the patient through an appointment. So this is how you try and reduce the coupling by identifying, okay, what relations are important for this system to work, and how can I reduce the complexity of the probe, of my implementation. So it's good, but we can improve it. So we notice after creating that, that a doctor shares all the same associations that a nurse does. That agrees with our kind of intuition. Like the doctor will have many patients, but a patient will only have one doctor, and it's the same for a nurse. Usually, well, in reality, you'll have different nurses, but you might have many, a nurse might have many patients, but a patient only has one nurse. So that makes sense with our intuition, but also if we add that into our class diagram, then that'll clarify our understanding of the situation. So we can see that not only does it make sense to us, but also it would help in the design if we decided to include these two together. So therefore, what we can do is we can have doctor and nurse inherit another class called healthcare staff, but also a receptionist who is also a staff member. So we can then add these additional classes in to help with our inheritance. So a person is at the very top. A staff member inherits a person. A receptionist is a member of staff. Healthcare staff inherits staff, and then doctor and nurse both inherit healthcare staff. Same thing as before, like designing an iteration, so you get the key things first. Then what you can do is just build on from that first thing that you had. So if you added this health class model with the healthcare staff and staff, by including those important key people first, then you can see this is exactly the same. These six classes here are exactly the same, but now you've just added extra things on and that's made it easier for the design. So a patient is also a person, and they interact with the nurse who treats the patient just like before, and a doctor cares for a patient. Patient attends, cancels, or rebooks an appointment, and same with the receptionist, but this way. And then a doctor is also part of an appointment and then prescription. It's just lonely over here connected to the prescription like that. So the class diagram gives a static view of the whole system. You know, we just put it there and we can see, okay, this is how they should interact, but you know nothing about the dynamic system, how everything would like interact with each other. So in UML, you use interaction diagrams to show how messages pass between each individual one. So an example of this would be a sequence diagram. So you consider, so just now consider what happens in the appointment booking scenario. So the receptionist must check that the person is a valid patient. Then the doctor object must be checked to see if there are any available appointments for that doctor. And then if there are any suitable slots available, so a new appointment should be created and assigned to a doctor. So it's just three simple things. Just is this person real? Is the doctor available? Okay, let's give the patient, let's put the patient in with the doctor for that time. So you can show this, these three things. I say three things, quite more complicated there, but... But yeah, so sorry. So you can see the receptionist creates a patient. Now it doesn't create the actual patient in the real world, but in regard to our system, then yes, they do create it. They have to add it to the system. So they create the patient. Is it a valid patient returning this? If it is actually a valid patient. So the receptionist creates it, just creates it. That's it. Is it valid? And then yeah, we come back. Next thing that has to be done is the receptionist checks if the doctor is available with the date and time. So we're careful. So this is the constructor. With the two lessons I would create, and then, you know, what parameter you're passing in. Then we check with the date and time whether the doctor is available. If the doctor is available, then we say, oh, the doctor checks with any existing appointments, whether that date or time passed matches. Did it match? We don't know. And then if it does match, then the doctor will say, OK, yeah, I am available or I'm not available. So assuming the doctor is then available, then the receptionist then creates a new appointment. And then once the new appointment is created, it gets sent back. The receptionist then sets the appointment for the doctor, which then you always need this line coming back saying that, OK, we've created it. This is where the actual function is happening. So this long bar here. So it sets the appointment at the start. Well, everything is done here. And then it returns back to the receptionist. And then the receptionist needs to do that with the patient now so that both the doctor and the patient are aware of the appointment. So the receptionist sets the appointment with the patient. Again, the information is the function for setting the appointment is taking place here. And then it's returned. And then that's just a simple how does sequence diagram work. So we shall see more on sequence diagrams later. But it's important right now as we introduce it that you know that's how they work. They record which actors and classes are involved in an interaction. And it's worth saying as well that in that case, the interaction was very simple, but nothing occurred in parallel. But when you get really complex sequence diagrams, you can see different actors communicating with each other, passing messages all at the same time in parallel. And it gets quite complex quite quickly. Finally, state diagrams. So everything every object has a state, which is just all the data it currently encapsulates. So is I have an appointment now one or is I have an appointment now zero, like the variable is still there, but the state changes based on whether they actually do have an appointment or not. So in this next example, it could be the case that the doctor is fully booked. So running methods inside can change the attributes and all the data that class encapsulates. So by booking appointments for by receptionist book an appointment for the doctor, it can actually, it changes the state of whether what appointments does the doctor have, what state is the doctor in right now. And this can be modeled by a state diagram. So assuming the doctor is available, they can book an appointment assuming that that appointment was not the appointment, just not the last appointment that the doctor was booked. So it would book the appointment and then it would come back to available. So yeah, it would come back to available and then assuming that the, oh, I see, not the previous appointment, like is this the last appointment that I can do. So if we book the appointment and it isn't the final appointment that the doctor can do in a day, then he's still available. And he can do this all the time until he's, until it's not the final appointment of his day. Then if it is his final appointment here, then we end up in fully booked. So the doctor is then stuck in that state fully booked until he cancels the appointment. So just seeing how a doctor or any class can have different states, which are, these are the states here, whether he's available or fully booked and how functions can actually change the state of any class or doctor, in this case, doctor. So we'll consider state diagrams later in more detail. It was a rather quick lecture, but we've seen an introduction to the unified modeling language. And we've talked about use case diagrams, class diagrams, sequence diagrams, and state diagrams. Any questions or people just want to come up and ask me after I don't mind, whichever you do. Thank you very much. And I'll see you on those then.