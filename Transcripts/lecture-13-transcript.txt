[SIDE CONVERSATION] Hi, good afternoon. Good afternoon. Today's session, we're moving from our requirements analysis, working out how we model what the system does, to our design approach, which is working out what software is needed to fulfill those requirements. So when you've got a long requirements document, let's say 500 pages long, you have to know from that, you have to work out how you're going to implement that in some form of code. And you're not just going to leap into the coding, because it's actually a bit more complex than that. Because it's typically done by a team of developers. It's not typically done on your own. So the experience you have here, I mean, you do your group software projects, you work in small teams. Those teams can be very large. So the general thing about the software design is looking for a solution. And that solution will be different, depending on the programming language, the environment. That solution may be slightly different. But it has to satisfy the software requirements, but also has to satisfy some other requirements, which we will talk about within these following lectures. So here, in a nutshell, is what I term the design problem. I've got a long requirements specification. It's highly complex. It says the software needs to do this, that, and the other. You're not sure, by reading that specification, what classes you might need, what database tables you might need. You need to identify all the data. You need to structure it. There may be relationships in the data. All that has to yet be determined. That will not be in this document. This document, there's something which will lead to that. But that's not going to be written down. The other thing to note is that if you're working with a team of developers, you can't just get the first 20 pages of the spec and give them to the first developer, and the next 20 pages of the spec and give them to the next developer. Because the pages of the spec do not correlate one to one with software components. It's not how it's broken up. The spec is broken up as use cases, typically. And one use case is not one software component. In fact, one software component could support all the use cases because it was very low level. And then another software, one use case, might require a number of software components, maybe like web pages, et cetera, so different pieces. So we take the requirements and we break them up into components. Now those components may be classes if I'm doing the OO design. They may be HTML pages, maybe web pages, maybe CSS, maybe some XML work. Could be all sorts of different bits that need to be developed before we can finish our project. Once we've done this, we can then start allocating these classes to our team. We're going to allocate them in an appropriate manner so that the most important stuff gets coded first. And we would want to make sure that if there's any dependencies, i.e. if lots of this code depends on class eight, then you develop class eight early on. So you put that first. So all those decisions can now be made because I can see not what needs to be done in terms of what the project needs to behave like, but what things need to go in to make it actually happen. So the software is highly complex. The whole system is very complex. And it's produced by a number of people. But the software itself needs to be easy to understand. If it's not easy to understand, it's going to be difficult to test. It's going to be difficult to develop. So a class doesn't want to be too long because it becomes incoherent. And a method doesn't want to be too long because it's hard to understand. It should never typically go over one page of your editor. It should break it up if it's much bigger than that. The code itself also has to be flexible. You have to be able to change it to do new things. If you don't design the code carefully, you will not end up with code that is flexible. You'll end up with code that is very difficult to modify for new projects. Portable and reusable. Reusability is very associated with OO inheritance. So if you don't use OO inheritance very effectively, you may end up with code that's hard to reuse in a new project. So when you do about inheritance, inheritance is a good thing used in the right way. So we're going to go from a complex set of requirements to simple software modules. And we're going to do some degree of abstraction. Abstraction means we're going to model what is the real world in software somehow or other. So we've got a case study on that for you. In practice, in the real world, design is very often mixed up a bit with the implementation. So there'll be some design work done. And then when the coding goes into place, the person doing the coding goes, it'll be a good idea to have this because it'll be making it more flexible. They'll be doing that as they go along. But you then really should go back and update the design documents. But that's a very typical flow. Then you do a bit more design work. And then you do some more implementation. And as you implement, you're adding more design in. A lot of software is designed while coding. That happens. And often, the design document doesn't reflect the final product. This is reality. It's not always the ideal circumstance because then you don't have well-documented code. But it does happen. So that's the point. In terms of breaking this problem up, the first stage of the design is to understand the problem. So if we're working with our health care system, what does the health care system have to do? We're going to work out which bits of the code we're going to implement in our system. We're going to draw a boundary diagram to work out which things are outside our system and which things are inside. In practice, we will try and put stuff outside the boundary if we can. So if we don't have to develop code, we won't develop it. It's not always necessary to do that. We can use a service that's already out there. That's very often the case. You'll find there's loads of people providing online web services that you can integrate with. And then you don't have to start developing them yourself. So it's possible to have a system that has a very large amount of functionality that your system itself does not have a huge amount of software in it because it uses lots of other systems. Then you look at a few different solutions. We're going to use a technique. We're going to show you a technique called the noun identification technique to identify some of this stuff. And then we're going to describe our solution. Now, the big things we're going to look at for describing our solution are class diagrams and interaction diagrams. Class diagrams will show the structure of our data and our code in terms of its architecture, but in a static view, i.e. nothing's happening. Just shows you the relationships. The interaction diagram is going to show you a dynamic view of the code. What happens if somebody logs in? What happens if somebody does a use case? But they will be done graphically. So coursework 2 will be part of that, will be to do some of this graphical and descriptive notations in UML. And we're going to keep that going, breaking the system up into smaller and smaller parts until the thing we're describing is relatively easy for somebody to code up. So that little piece they can do by looking at the description, looking at the specification for the code. In general, the design is modeled as what's called a directive graph. You've already seen the directive graph. All it means is the lines have arrows on them saying which direction they go. So we're going to look at that. And there's a number of overlapping stages. As I said, you'll often do a bit of the design of one component, and then a bit of the coding up, and then a bit of the design of another component, and then the coding up. If we're going to break this up in a series of steps, we can see that we start off with our requirements specification. This is what we got from the last step. Then we're going to break our system up into our architectural components. Those are the main building blocks of our system. And for each of those, I'm going to write a little specification. Typically, that specification for a lot of these systems would be developed in XML. It would show you what incoming parameters are going in, what you'd expect the output to come back like, and what were the range of values you'd expect. So these parts, all these parts are to do the whole of the architecture of the system. Then we've got the component design, data structure design, and the algorithm design. The component design, and the data structure design, and the algorithm design in OO are all covered by one process, and we call that OO design, object-oriented design. So that will be the focus. So you see these last three parts, that is OO design. The first three parts is called the system architecture, and that's independent of what programming language you are using. We don't need to think of it. So because we're using Java, these three parts will be wrapped up together. Remember in Java, your code is designed as data wrapped up with the same functional code together, isn't it, as one process. So that's why these steps are done together as part of OO, because it's integrated. So notice this one, this subsystems, identify the subsystems, specify them, and describe them. They're the three components for doing the architecture of the system. And then these, that's the internal operation of the software itself. So the first three, you're probably doing a day. Take you one day. The rest of it might take you two weeks, three weeks. Might take a lot longer, because remember, in the rest of it, you're doing all the inside of each of these subsystems. So you'd have a subsystem for doing card payments. There might be lots of different classes inside there. So they would be more complex to do the second process. In OO, this second step is called OO design. So we're going to just do that as OO design. We're not going to show you how to do-- we're not going to focus on them separately. We're just going to jump straight into OO design for that. It's important when you have a computer system that it's not one great big lump of code. They're composed of separate modules. And the reason it's done as modules is that it's generally seen as a lot cheaper to make more systems after you've done your initial development. It's a lot easier to do reuse and stuff like that. And it tends to make the software of better quality. So when we do the system design, we need to know what those modules are and what they should do. So they'll all have a name. They'll have a description. And then, if they're a class, they'll have a set of public methods. And each of those public methods has to do something for you to provide some functionality. And as they're classes, they'll also store data. And then you'll have interactions between the classes, the relationships between them. A very long time ago, before you spent a lot of time on OO, modular programming was just breaking stuff into subroutines. That works OK, but it relies on the fact that the modules work independently of one another, have some coherent task, and are not going to fail regardless of the incoming data. Robust means it's very difficult to break the software. That's all it means. It's difficult to break it. The first step you can do in terms of breaking code up is use something called procedural abstraction. That means breaking up a complex process into other subprocesses. A few lectures back, I did that drinks machine. Remember, we looked at the drinks machine as a whole, interacting with its environment. And then we looked at inside that. We said each one, well, that's made up of different parts. And then we looked inside each of those. That's what this is, procedural abstraction. It's looking at a complex function and breaking it up into separate smaller parts. So you might have separate functions like display a menu or get a user option. Everything where you can break something up into smaller and smaller parts, that is procedural abstraction. Another approach to programming is to use something called functional programming. Functional programming has some interesting properties in that a method or a piece of code in functional programming has something called referential transparency. It means whenever I call a piece of code and it returns some data back to me, if I put the same number in, I always get the same number out. That's like a mathematical function. If I put 3 into squared, I get 9. And every time I put 3 into squared, I always get 9, don't I? I'm never going to get any different. If I put 9 into square root, I'm going to get 3 or minus 3 because you get two values. If I think of a method in Java, I can call a method in Java with the same data, but get different values back because it might rely on some other internal state. So the good thing about programming using functional programming is once you've tested it once with one set of data, you know it's always going to work. So it's a really good way of operating. So it's very good for compilers because things like compilers, you put in the same statement into a compiler, you'd expect it to process it into the same code, wouldn't you? You wouldn't expect it to take some code and try and translate it and produce a different value sometimes. Anything where there's a consistent task, what would else be good? A compression algorithm. That would be good done by functional programming. An encryption algorithm. Anything where there's regular transformation of data, that works well. So these are interesting languages. A bit fringe languages at the moment, but I used to do a job in about 1992, and we used to use Lisp. We used to use Lisp for that. And Lisp is a lovely language, but it's quite low level. But it has this clever-- it's got this quite cool functional aspect to it. It's no good for distributed systems and any system that has internal state. So a normal web server or a normal e-commerce application has internal state. When I go and update my order, the system knows about the previous things I put in the shopping cart. That is the internal state of the system. OODesign, which is the main focus of the design in this subject, views the whole thing as a series of what are called objects. And an object has various properties. So in this, the state, each object has some data in it. So if you see the word where it says state, that just means the data that it holds within it. And the objects send messages to each other. And when they send a message to another object, that object can also update its internal state. And they all sort of zip around sending each other messages. It has been found that object-oriented development and design provides a lot better reuse and stability of code than previous methods. That's why we use it. It wasn't just invented as something cool. It was found that it actually was very effective. It also allows you to model the outside world as it is inside the computer, which means your program is closer to the real world than other types of programs. They look a bit like the real world. There's a number of criteria which help you to work out whether you've got a good design technique, a modular design technique. And these are decomposability, composability, understandability, continuity, and protection. So decomposability means you can get a complex problem and break it into smaller problems. I know I was good at that because we can have a class that's associated with all our different data. So if we've got a medical system, we'd have a class mayor representing a nurse, and a class representing a doctor, and a class representing a patient, and we'd have a class representing. And now you can see we're already breaking stuff up into parts, aren't we? Breaking stuff up into pieces. So that works well. So you're going to break the problem up into subproblems. And you can just-- anything where you can break a complex problem into a number of smaller subproblems, that's doable if the approach you've got allows that to happen. So here I can imagine my main system. And then these are my subsystems. So this is on the right-hand side. That could be my payment system. Here could be my order processing system. Here could be my marketing system. And then some of these in the order processing system, the order's about to be dispatched. It makes a request to the payment system to put a charge on the card. And then presumably, if that's OK, it says it starts the process of dispatching the goods. If it fails, it sends a message back to the customer saying, please change your card number. We could not make it-- you know, we had a problem doing it. You can imagine how that's done. But that is all done in discrete systems. So in top-down design, we start working at the uppermost components and break it up level by level. In general, a large system is not completely top-down. So if I go back to here, usually you at least do this break up into subsystem, subsystem, subsystem. But some of these things may already exist. So let's say you see these ones that are cross-hatched here. If they already exist, you might have to integrate them with the software that you're devising. So you might have to do some bottom-up development in design. So you can think of, for example, designing a word processor and think of what subsystems you need for your word processor. So you might want to have a file I/O for loading the file from the disk and saving it. Printing to handle rendering the thing as pixels on a printer, because you'd have to send out a pattern that the printer understood. A GUI to have the drop-down menus and the bit that controls the editing, the text processor, which would take the key presses. And then it would do things like formatting it, right justified, left justified. Word processors are horrendously complex pieces of software. There's so much in them, it just goes on and on and on. So they are very complex. And there's a lot of design that has to go into making a good word processor. You can then decompose them further. So file I/O can be loading and saving documents. And then when you're talking about loading documents, you might have drivers for loading a PDF document, or loading a Word document, or loading a Latex document. Each of those would require different parsing of the document. So you'd want to have a series of parsers that you develop. So you can imagine defining those. So your design is saying, oh, we need a parser, and we need one of these, and we need one of these, and we need one of these, working out those different pieces. The next one is composability. That means that you end up with a series of modules, which then then be added together to make new systems. OO is very good for this, because OO has this idea of a module that has a public interface and an internal private functionality that's hidden from you. So in OO, the interface to the classes is somewhat simplified. You don't have to see all the detail. And it's also associated with this issue of reusability. When we look at OO later on in more detail, it's also composability is strongly associated with inheritance. If you don't do inheritance, you don't get good composability. So sometimes there is a little bit of a trade-off. So if you break up your system from just purely top-down design, all you're doing is developing modules which fulfill your requirements rather than modules that hopefully can be reused in another project. But we'll look at that again later on. So there's a group called the Numerical Algorithm Group. And they do algorithms that do solve problems, mathematical problems, but in a numerical way. So one example of it is if you want to do integration, but you don't want to solve the integration, you just feed the integration formula in, and it numerically integrates. But they'll also do things like a Fourier transform. The Fourier transform gets a signal, and it tells you how many high notes are, how many low notes are. You've seen that on a graphic equalizer, where you've got the music, and you see the bits that are high-pitched and the bits that are low-pitched, and it bounces around. You'll have seen how it does that. That can be done using a Fourier transform, which come from this group. Now, the NAG group libraries, you can join them together. So you can use NAG group commands and use a pipe to put the output of one into the input of another one. The next one is modular understandability. This means you're using a technique or you're producing code or a design or whatever that is easier for people to understand. In fact, in the old days, some of the old programming languages only allowed you to use one letter for each variable. That meant you allowed 26 variables. You could have upper case and lower case ones. It's even more confusing, so you now have 52 variables. It's absolutely horrendous. If I have a variable called a, I have no idea what it means. It doesn't mean anything. So what you should do in this case is make sure that the variable itself says what it is. And hopefully, if it stores a numerical value, gives its unit. So if it's mass, it really should say mass in kilo. And the advantage of that is now you don't have to comment it because it says what it does. So the whole idea is you develop a structural use of coding and/or design that's called self-commenting. If it's self-commenting, it means I can read the code, and it tells me what it's doing before I've even read the comments. If I have to read the comments to understand the code, it's not great code. It should be so clear just by looking at the code. That's really good code. Sometimes, it's doing something like an encryption algorithm. You need to reference the encryption algorithm. But in some cases, it should be clear enough. You can never think of if you had 1,000 lines of code with no procedures, that's really horrible. Or using a go-to statement, again, that's really horrible. I wouldn't expect to see any of you doing anything like that. I'm sure you're far too good students. I don't think that's going to happen. The other thing to note about components, the software components, and relating to understandability are some of these factors. So can a component be understood in its own right? Have you got meaningful names? I mentioned that in the previous slide. Have you got some documentation? If you use a complex algorithm, are you using it in such a way that you've documented how the algorithm works? And if you have to change the code to do something different, have you put a to-do comment on the top of the module? So if you say, to change the number of files that we can have simultaneously open, change this variable. Put it up at the top. Next one is called module continuity. It's a little bit more subtle. It says that if a small change in the requirements leads to a lot of change or a large number of modules change, you have failed module continuity. Module continuity should say, if I do a slight change in the requirements, I only need a slight change in the code. And there are some. So for example, don't put any literals in your code. Don't put the word yes and no. If you're going to display them on the screen, they shouldn't be appearing in your code. Because then somebody, to change the language to French, they want to go oui or non, and they want to do in German, they want to go ya or nine, they want to change their language, they would have to go in and type and change your code. That's really bad. That's really poor. That's a showing of poor module continuity. For example, if I said the whole of the user interface has to change from English to Spanish tomorrow, how much code would have to change? If it's only one file, I've done the module continuity right. If it's 25 files, it's poor. So you can do it. You can put all your strings in one file and then send it to English to Spanish translator. You can run it through Google Translate, but I know that's not great. You probably want to use an expert if you have any sense of quality or whatever. Send it to somebody who knows what they're doing. They translate it. You upload it. Bingo. Everything works. So it's very important. This module continuity is one that doesn't seem that clear now, but when you do it in practice, makes a lot of difference. So don't use static arrays, stuff like that. But it will come with other examples. Module protection. This means that if there's what's called an abnormal condition, something goes wrong, it doesn't go very far through the architecture. It means that a module, if you give it bad data, it doesn't accept that data. It throws an exception, spits it out, gives you an error, forces stuff out. So you see, remember you've got all those setters and getters in Java. You've got set this set name or whatever. You can put setters and getters in Java that set the data inside a Java object. Those should always have validation on them. If it's set postcode and I can put any old string in as a postcode, that's no good. It should throw out everything apart from a good postcode. So validating input at source improves module protection. It improves security, stops people hacking your system because they can't put in any old rubbish data. Yeah, so use of int types. This is not so relevant for you as Java programmers. If you do C and C++ programmers, in some versions of C, the int is 16 bits long. Some versions of C, the int is 32 bits long. That means I send 16 bits down the wire. My other C code at the other end, that's the same code that's meant to read this block of data, tries to read 32 bits, and it reads one int, and it reads the next int that I send directly after it. Everything goes haywire. So it's very important that you be aware of that when you're sending data. So one example of failure of modular robustness was the Ariane 5 space launcher. So that costs 370 million. I'm sure it's a lot more money in these days. I mean, that was a long time ago. Well, not a long time ago for me, a long time ago for you. And there are other ones, the therac radiation. These systems did not cope in circumstances where they get data that they didn't expect. And that's really poor. That's really poor, out of range. So for the Ariane 5 one, it was a numerical conversion exception, numerical overflow. The number was too big. It was too big. And it just caused the thing to crash out horribly. Horrific, really. So in general, it's a good idea to use components. But you must be taking care. So the Ariane 5 used Ariane 4 launcher code inside it. Nowadays, people are a lot more circumspect about how they handle that sort of thing. All systems have data. And sometimes that data needs to be stored somewhere so that when you switch the system off and then switch it back on again, you get the data back. You know what I mean, saving your work on the disk. That's all we're talking about here. It does have a name that you will see in computer science. And it's called persistence. So that's the technical term for it. So if you say, I'm persisting this object, it means I'm taking the object. I'm saving it to a disk or something like that. But also, there are problems associated with sending data over networks, things like that, or associated with the same kind of problems. So for persistence, there is this thing called the repository model. So one possibility is to have a repository model. And the word you would be familiar with in terms of what is a repository model is a database. So a repository model is a central database. It doesn't have to be a MySQL type. It can be a NoSQL type database. It can store the data in native form or in JSON. It can be a document style database. It can be all sorts of styles of databases. But it is a central repository store for all of the system or all of the subsystem. The other possibility is that each separate subsystem has its own little database, and then data is passed between them. That's often used in large scale things like embedded systems. So if you think of something like a factory, there will be the robot arm that sits on the factory production line, welding a car or whatever. That will have plans and stuff downloaded to it. So the plans will be downloaded into its local database. And then it will operate all day, whatever, whatever, whatever, fairly autonomously. Why is that good? Because it means if the payroll computer breaks down, it still carries on making new cars. It doesn't care. It's still working away. There's obviously an override button in case it goes mad and tries to kill some of the car workers, like a Terminator thing. They have those red buttons on the wall where you can press them, but apart from that, it's fairly autonomous. It's allowed to carry on doing its job doing its job doing. But it has to have a local database, and that local database tells it where to weld because obviously different models of car have different weld spots wherever it's going to go, whatever. So very often used in embedded systems. So the advantage of the repository model, and the reason why it's used in the vast majority of normal information systems-- let's get this straight-- is that it's very efficient. OK, you don't need to send much of the data over the network because if I want to send data to another module, I just save it in the table for that module, and I load it up from the table for that module. It does have one very serious danger, and it's something called stamp coupling. But we'll come to that later when we do coupling. And they don't need to think about data that's used by other systems. So if I save some data in the database, another module can load it up, use it. And then because you've got all your data in one place, you can back it up, keep it secure in one place, have access control in one place, and you can even have it double-backed up over two sites with your database split, one in Manchester, one in Edinburgh, one in Liverpool. You can imagine you'd have them spread about. So that even if you get a flood or a fire, you can always get access to it. Prostetry models are excellent for that because you can do all this because you're putting all your data in one place. OK, so the disadvantage-- and it's really not for most of us, and it doesn't make any difference-- but they have to agree on how they store the data. And if you've got a large amount of data, you might have to translate it to other systems. These aren't really very big problems. If you have some systems have different requirements for security, obviously for security, you could just enforce the most important policy. So you could just enforce that across the database. And then you might have to-- for example, if you're putting your repository and spreading it about, that might be difficult because it might need a lot of network bandwidth. So to wrap up today, we've looked at these things-- decomposability, composability, understandability, continuity, module protection-- describe what they are. And we looked at the repository models. So we're going to carry on in the next lecture with more discussion on design. and