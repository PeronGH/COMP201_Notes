[SIDE CONVERSATIONS] Good morning, everyone. Happy Monday. Time tables isn't working right now, so I can't get the attendance code. So I guess everybody is marked as here today. So yeah, back to class diagrams and talking more about the associations that classes can have between each other. So we discussed this idea of association is if some object-- so if class A knows something about class B or vice versa, they are associated. But that's kind of very high level, and we can specify more about these associations in class models. And so today, we're going to be talking about these different kind of associations, starting with aggregation and composition. So aggregation and composition, like the rest of things today, are kinds of associations. They are a way of describing if some class is part of another class. Now, composition is always an aggregation, but an aggregation isn't always a composition. I think that's an easy way of thinking about it. So yeah, they're a way of saying how are they associated. So this one here with the diamond that is not filled, that describes aggregation. Quite simply, it is a way of saying that something is part of something. So a module is part of the honors course. So you might have one too many honors courses. So you might have G40A, G40E, that one doesn't exist anymore. But you've got different types of honors courses. And an honors course will always have at least six modules up until something else unspecified, probably not a million. So a module is part of an honors course. So you can have, like I said, as many honors courses as you want. There's at least one. And then each honors course must have six modules. But this is by saying that a module is part of an honors course. In the honors course class, there will be an attribute which says modules. It might be a list or something. So it is a conceptual notation, just like a lot of things when doing the design. It's all conceptual. We haven't actually done the implementation yet. So seeing aggregation in a class model should help you understand the relationship between-- OK, so that class is part of another class. But that is quite informal. It doesn't give you any formal information other than module is part of honors course. Composition is a special kind of aggregation. And it says that in a composition relation, it strongly owns the part, which means if class B is part of class A, if I were to delete class A, then it would also delete class B as well. So class B can't exist if class A doesn't exist. So it's like an arm to a body. I guess you could say my body strongly owns my arm. So there would be a composition relation between my arm and my body. So yeah, a part cannot be part of one, cannot be part of more than one whole body composition. So an example of this is you have a noughts and crosses board, one or tic-tac-toe. There's one board, and it has nine squares. Always has nine squares. That's tic-tac-toe. And a square is strongly owned by the board. It is-- sorry. A square is strongly owned by the board. So if I delete the board, then the square disappears as well. All the squares disappear. And that is just denoted by another diamond. But this time, the diamond is filled in. So the difference is that if I delete an honors course, the module can still exist outside of it. But in composition, if I delete this board here, then the square has to be deleted as well, because you wouldn't just have a square on its own. So that's the difference between aggregation and composition. So considering the following scenarios-- no, sorry, consider the following scenarios, would the relationship between an employee and a team be composition or aggregation? Does the team need to exist for an employee to exist? Can anyone tell me if that first one would be aggregation or composition? Aggregation. Aggregation, exactly. The relationship between a wheel and a car? Composition. Between an account and a customer? Composition. I suppose so, yeah. I thought I read that as accountant. But yeah, yeah, you can't have-- the account can't exist without a customer. Yeah, yeah, yeah. Brilliant. So we've seen how we can describe with associations how something can be a part of something. Now we're going to go back to roles, which we briefly talked about last time. So you can read an association name in both directions. So you can have is taking or is taken by. It's kind of loose how you do it. But as long as you make it, it should be implicit how you would read it. So I'll explain it later. It's more readable sometimes to just have two separate ones. So two separate names for the roles that the objects play in the association. So I don't know. Yeah, so over here you have-- this is director of studies. And then this is a director. So you can see clearly that the student is directed by the director of studies over here and the other way around. And so you can just have-- like it says on the next slide, it's not clear, though, who's taking what, even though you can-- just by knowing how a student and a module operate, you know which way that one's probably going. So a student is taking a module. So because of the multiplicity for each object of class student, there are six objects of class modules. So yeah, a student always has six modules. And in return, the module can have one to as many students as there are. So now we can introduce naviga-- I hate this one-- navigability. Yeah, all right. And you can put the arrow to describe how the messages are being sent between the two classes. So the module knows about the student, but not the other way around. Now, the student does know about the module. But I think what this is talking about is in here, you would have all the grades, all the assignments that are released and unreleased. So based on that alone, the student doesn't know everything about the module. But the module should know everything about the student. Even though it says student is taking the module, it still goes this way. So you can make it clear in your class models which way the messages should be flowing, which way-- what-- yeah, which way the messages are being sent. So yeah, that's navigability. Then we have qualified associations. I'm zooming through this slide. Occasionally, it is helpful to give finer detail. Very occasionally, no. You won't see this all the time. So a square, as we said earlier, is relative to the board it's on. So there's always nine squares to one board. But they're identified relative to the row and the column. And there's three of each. There's three rows, three columns, three times three is nine. So what you can do instead is you can say, OK, so the board has one, two, three rows, one, two, three columns. And now this square is connected to it just as a one, one to each row and column. As opposed to earlier, it being nine squares and one board. So by doing this, you can make it clear, OK, what role-- yes, but what is the square actually being attributed to in that other class, so in the board? So we could just have nine squares. But this makes it clear that squares are actually a row, one row and one column each. So yeah. And then you can extend that further. And you can combine the composition onto it. So you have exactly what we had before. There's one square to each row and column. But now it's strongly earned. Again, we've got that composition. So if I was to delete the board, the square would disappear as well. So now we move on to derived associations. Excuse me. Basically, yeah, imagine that a student takes a module and a lecturer teaches a module. So do you need to always have to record that a lecturer teaches students? Is it already implied by how you've drawn your class diagram? So we can use the concept of derived associations to make things more obvious. So we can emphasize to the design how they are related, even though they're not actually related in the class diagram. When you implement the main association, so assume that a lecturer isn't taught-- I can't put my hand over it. Imagine teacher student isn't there at the moment, and only student and module are associated, and lecturer and module are associated. The idea that a lecturer teaches students is implied, but it isn't important for our system. The lecturer interacts with the module. The student interacts with the module. But then the student and the lecturer don't interact, not in real life. But in this class model, it should be assumed that the lecturer teaches the module and the student takes the module. And therefore, this derived association that the lecturer teaches the student exists automatically. As long as the main association is there, we can derive this. And we can derive it by using a slash in front of the name. So this teacher student here, with the slash in front, the lecturer and the student in the system aren't directly linked, aren't directly associated. But it's implied that they do. We derive that information. So the black triangle indicates which direction of the association the name describes as well. So that's how that operates. Does that make sense to everyone? Cool. So a constraint, it must be satisfied for there to be a correct implementation of a design. So we can put constraints on our class models. Formal constraints are written in OCL, the Object Constraint Language. And that is intended to be formal so that every single constraint we write is clear and unambiguous. And that is easy to use as well. So everybody can just say, this is how it should work. I've written it. I don't have to consider much more than that. So imagine a copy of just a copy of either a book or a journal. So of either one of those, yeah. And it's either a book or a journal, as I just said. If we have two associations, like a copy book and a copy journal, this will not rule out in the system, in the design of being a copy of both a book and a journal. So I'll just describe this. So there is a copy. And it can be a copy of a book and a copy of a journal. Now, that can exist both at the same time. But as we know, that isn't possible. So it could be a copy of both at the same time. So yeah, we want to add a constraint to our association to make sure that that isn't the case. And for this, we decide to use XOR constraints, so exclusive or, which I'm sure many of you have come across during your studies in computer science. But as just a little recap, it's A, XOR, B. So they can't be the same. It can't be neither. It has to be either A or B. And if you ever see-- never do logic, that's how it's written. So just by adding this dash line, you say exclusive or XOR. And that basically means that the book can't be a copy of neither-- sorry, the copy can't be a copy of neither a book or a journal. It has to be a copy of at least-- of either a book or a journal, if that makes sense. So it can't be neither. It can't be both. But it has to be one or the other. So it has to be a book or a journal. Does anyone not get what I'm saying? Thank you. I assume you speak for everyone. Makes it easier. [LAUGHTER] So now, associations won't always just be, like, existing in your code in the middle-- well, let me rephrase that. Associations aren't just a conceptual thing all the time. Sometimes when we write programs, we want the associations to store attributes and operations as well. So consider the situation where a student class is associated with a module class. Where should the grade for that module be stored? Should it be stored in the student class or the module class? It should-- I mean, the grade really belongs to the association of these two classes. So the idea of an association class is that it is both an association and it is a class at the same time. So it's a class down here. But we have this dash line. And then we say, is taking as the class. And then the mark is there as well. Now, you can avoid that if you think that's best for your design. Or you can go with this if you think it's best for your design. The way you'd avoid it is you'd just create a new class, which is just called mark. And then the student has six marks in total. The module has as many marks, quite a lot, because it's got as many students. So that's how you would avoid the association classes. You'd just create a new class itself. So you could just have it like that. Or you could actually make a class mark. And then, as you can see, the associations are exactly the same. There's six modules. So there's six marks. There's as many students as there are students. So you just map it like this. So you go on to as many as there are six. And then you just say, OK, student has six marks. And the module has as many marks as there are students. So now we're on to interfaces, which specifies operations of some model element visibly outside of the class. So all the elements of an interface and a class diagram are public. It's an interface that needs to be able to be interacted with by anything so that you can access anything within that class to interact with everything else, just like the user interface. This is a very poor drawing that I found online just to describe what this was actually saying. So all the elements of such an interface are public. The notation is to use a rectangle just like a class. But you add this interface string here. So this persistent object is very abstract, what it is. But you can see it's just exactly like the shipment up here. And it has an interface. And then it can do all your finding, save and delete. And I assume that's to the shipment, although I don't think it's a generalization. So the idea of an interface is the same as the idea of an abstract class, where you have defined the operations, but you haven't stated how they work yet. So therefore, it can't be instantiated. A class where no method has an implementation is essentially an interface that we saw on the previous slide. So how you define, find, save, delete, and retrieve is undefined at the moment. So the key points of this lecture have been aggregation and composition, where you can say where aggregation is-- you're saying something is a part of something else. But composition is saying it is strongly owned by the other things. So if you delete-- if class A is composed of class B and class C, if you delete class A, then class B and class C disappear, where that isn't always the case with aggregation. Navigability-- smashed it that time. So what direction are the messages being sent? How is the information flowing through your classes? Associations-- so we talk more on roles, association classes, everything like that. Constraints, where we discuss the exclusive or constraint and how you can write constraints between two associations and make it clear if something could be something or something else. Yeah? Is there a specific reason that we're avoiding the association class? Avoiding the association class-- see, that is a good question. I suppose this is just how you do avoid it. I'm not too sure. I can ask-- you don't need to avoid it. You can just create is taken. [INAUDIBLE] Yeah. So if you want to do an association class, you just do this. I'm trying to think for a reason really quick. But I suppose-- [INAUDIBLE] I don't think so. I don't think so. I suppose it always just comes down to your implementation. Is it feasible? I think this mark would be easier to implement. It would be better rather than association class. Because this at least tells you how the information flows. This one does as well. But suppose you would have to create-- I mean, in either case, you could put mark in student, install that, and then you would have to store it in module as well. This one, you don't have to store it in either. So I think you would need to in here specify the student on the module as well. But this one can just be stored in-- would have to be stored in either really. I think, yeah. And then I briefly talked about interfaces as well. Any more questions? OK, so next. Lecture, we'll be looking at interaction diagrams and specifically sequence diagrams. Thank you very much.