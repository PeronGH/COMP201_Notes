[SIDE CONVERSATIONS] Right. There's the attendance code. Just a quick reminder, tutorials start this week. OK, if you can't make it to your scheduled tutorial, just turn up for another one. But only do it if you have a clash or something. Don't-- please don't just wander off and just go to a tutorial because you prefer that tutorial. Otherwise, we'll end up like they'll all be over the place. We'll have overfilled tutorial rooms. People who are allocated to that tutorial won't be able to get a seat, will they? OK, so that's today's code. We're going to be talking about software requirements. The next session, we're going to be going through coursework and some things to do with coursework 1.1, the next two sessions. And then you can start to-- well, you can start as soon as you like, having a look for coursework 1.1. That's what I'd like you to start doing now, really. Let's get going with it. OK. So software requirements, going to be looking today at a difference between user and system requirements. We'll look at the difference between functional and non-functional requirements. That is part of coursework 1.1 functional. So you should pay attention there, because obviously, getting that correct. But you'll score better if you actually manage to identify the difference between them. And we're going to look at a couple of different techniques for describing these requirements. So we're going to be describing a couple of things. What we expect the service, the computer system to do, what we want the customer requires of the system, but also the constraints. So an example of a constraint is the system has to run in Google Chrome. It's a web-based application, and it must support Google Chrome. It must support Safari. It must support Firefox. And then you'd have all the different versions that it adds to support. You wouldn't support all versions of Google Chrome. You'd have a cut-off point. OK, and why do you do that? Because obviously, it limits costs. If you said, we're going to support any version of any browser anywhere, that could be very expensive. You could have developers messing around, trying to fix stupid bugs, make compatibility. It gets a bit stupid. OK, constraints could be the amount of memory. OK, what hardware you've got. OK, if you're doing an embedded system, lots of constraints. So a lot of that goes into the requirements. OK, customer doesn't really care about that. But you do as a developer. It's really important. OK, and that's all going to go into this requirements document. And that's going to be generated. And getting the requirements right, it's a critical phase. Bad requirements, poor requirements, weak requirements. There'll be a lot of stuff. It won't work. So when I said before, it had to work on versions of Google Chrome. Let's say you forgot to put testing for Safari web browser. There'll be loads of people who are running Apple Macs who go, this system doesn't run on my system, or it won't run on my iPhone, because you didn't test it on mobile Safari. Yeah, it's not going to be good, is it? So we need the requirements for a number of reasons. We need that the software solves the problem. And part of that doing the requirements process is to understand that problem. So evidently, you can say, I need a new computer system for my medical clinic. But until I know exactly what that means in practice, has it got to like-- does it have to store x-rays or blood test results? What's it got to do? So you need to know why the problem needs to be solved. So imagine you have a clinic, and they say, well, we've got a lot of problem with people missing their appointments, and they never tell us about it. So you could have your computer system could come in, and it could send them a quick WhatsApp message two days before their appointment. Because they've said, I prefer I don't use old text messages. I use WhatsApp all the time, and that's all I use. And they take that on their preferences. You could only do that if you integrated WhatsApp with your computer system, couldn't you? So you'd have to integrate it. So you could actually reduce the number of loss. Determining who should be involved, who we're going to talk to. We're going to talk to doctors. Maybe a lot of people, you'd say, well, maybe we should talk to patients, because they might use the computer system. And talk to nurses, receptionists, the medical system. If you don't get the requirements right, it means the project might not be successful, and it might mean that the project overruns a lot of time. So if I don't say which is the correct version of the browser, and then suddenly I have to do a lot of work updating the software for Safari or Chrome later on, that's going to add time onto the project. The requirements, it depends on the perspective of the person reading the requirements. It can just be a broad description of what the requirements have to do. So for example, the requirement could say, it has to control safely and facilitate in the landing of an Airbus 777. Not an Airbus, Boeing 777. OK, you could put that. It'd be rather broad. OK, wouldn't tell you how it does it. Then it could have the mathematical functions. How that would be done in practice would be a very technical, detailed document. So from the very high level view to the very in-depth technical. So there are two possibilities in terms of the requirements, in terms of commercial reasons. OK, so you could have the requirements that would be saying that you're willing to do something for a certain amount of money, like a bid for a contract. In that context, you want the requirements to have possible options and open-ended to a certain extent. Or it could be a basis for a contract. And in that case, you would want to be very precise on what you're saying you're willing to do for that amount of money. Because if you're not that precise, then people will say, well, we said, you said in this document, you said you could do this, this, and this. And you say, well, we didn't really mean that. So we're going to have to charge you a lot more money. And they'll say, well, you've already written it into a contract. And we've got you there. OK, so it's very important that you get this. That precision will have a commercial impact on activities you are willing to do in the real world. In general, requirements go through iteration. Remember, we talked about evolutionary development. And you do it once, then you do it again, and you do it again. Any process you do goes through iteration. So you're doing group software projects. I would expect if you had-- when you submit your requirements, I would expect you'd probably be on at least version 10 before you handed them in. That would be minimal. You'd have gone-- the first one would have just been-- you'd keep doing-- you keep going, oh, every time you just change a few sentences, it can be another version. It doesn't have to be a big iteration. So here are some examples of iterations. So each line is a different iteration. So the first one is, the system will support a wide range of the most commonly used graphic file formats. The problem with that is it's not saying what file formats. OK, so one person thinks one is the most commonly used. Another person says the other is the most commonly used. What is it? Don't put that. What you should say is you should list them out. So it says pnj, jpg, tiff, and get. So we just put-- maybe they're not your preferred list. That doesn't matter. Change the list. OK? Or say refer to list in appendix. Next one, it says the system support these following file formats to a maximum resolution. Why do you want to do that? Because you want to test the system with given environment. So you want to say, how long is it going to take for us to process 1,000 by 1,024 pixels? Imagine you're doing an AI system that has to identify what breed of cat it is. So somebody-- what you've got is you've got-- you're a veterinary surgeon. And what you do is you say, send us a picture of your cat. And then we know what type of cat it is. And then we can give you some recommendations on there. You feed it or something. But you want your system to identify that. Now, if you said that that could be any resolution, it might be very, very slow to process the image or it might have a problem with that. Then you'd have the next one. The system may support the following file formats, blah, blah, blah, 1,000 by 1,024 pixels, maximum file size of 20 megabytes, with these promising and extended, easily using plugins. You'll notice it moves from what you'd think was like a general user requirement to a system requirement to almost a software requirement. So notice, we're talking here about software, like plugins. And here, we're not even mentioning software or anything technical at all. So that's the difference between what you call a general user requirement and a system requirement. Has a degree of precision in it. You know what you're talking about. So the user requirements, they're the statements in natural language. It can have a diagram of the system. And that's generally written for the customer. So a customer, if you had a veterinary surgeon, they probably don't know what PNG or JPEG is. It probably doesn't matter to them. It's of no interest to them. They want it to provide a service. The system requirement, that will be a contractual level requirement, because it will have that degree of precision that you can say, has it been done correctly or not? So it's very important at this point, you can say tick, yes, we definitely did do that. Tick, we definitely did do that. The user requirements doesn't have that precision. The software specification, now we've got the written to a level that would be suitable for the developer. That's why, if you look at the last previous list, go back this slide, you'll notice the last one mentions that being easily extendable using plugins and maximum file size, these are things that a software developer would probably maybe want to know. It's a good thing for them to know that. So when they do the development, they don't leave it out. As far as technical concern, here, this third one is probably close to more like a system requirement. And the first one is more like a user requirement. So every time you do the requirements, you're moving from the user through the system requirements to the software spec. So it's sort of that way you're iterating to get enough detail. So here's just some more examples. So user requirement, the user needs to be able to spell check a document. OK, fair enough. The next one, the system requirement says, the system needs to be able to spell check a document, do autocorrect facilities, and there will be-- they're spelled incorrectly, if you have the notice. So that's bad. Quality assurance, there you go. There will be support for the following languages, English, French, and German. And it says then, we'll have a support for other languages. So it's very important that you can think of making the thing future expandable, so you can pop in other languages. And how you define those other languages, that it isn't defined within there. It just says that's what it has to do as a system. Next one is a software specification. And it's defining within the software specification the interface to a method, some way of doing this. So it comes in with-- it's going to have a method called check, spell check. It's going to come back with a type called check result. Don't know what's in that. It's obviously defined in some other part of the software spec. It goes in with a word and a dictionary. So the concept of a dictionary is that it stores a load of validly spelled words with their definitions next to them. And then you can-- and it says something about the data. It says words defined in Unicode format and string. Well, that's useful if it's Unicode, because it supports a wide range of natural languages, including Chinese and Japanese and Vietnamese. Lots of different languages are supported. It's not just talking about Roman letters, are we, the Roman alphabet. And then it says the structure of the dictionary has to be defined within this part of the document. The check results defined in another part of the document, et cetera, et cetera, et cetera. It even puts a hint. So it says, ideally, use hashing tables to approve code efficiency. So it's giving you some heads up about how it's going to do it. There are distinction between what we call the functional and the non-functional requirements. Funnily enough, you need all the non-functional requirements to work correctly, often, for the functional requirements to be useful. So the functional requirements just say what the system does. The last example where I gave you the spell check, that's a functional requirement, because I want the system to spell check my document. Providing a login facility, so I can log in and protect the system from people who shouldn't be accessing the data on the system is a functional requirement. Anything that provides a service to the user is a functional requirement. A non-functional requirement are constraints. So a non-functional requirement could be, when I log in, it responds to me in less than a second. So something like a timing constraint would be a functional requirement. Constraints on the development. I could say that all the code must be developed in C# using Microsoft Visual Studio. I could say that's a constraint. I could say all has to be done in Eclipse in Java. It doesn't make any difference to the user how I develop it, but it might be important non-functional requirement because I want it to be then supported by my team. So let's say I was getting another team outside the company to develop it. I would then want it in-house, and I want my team to be able to support that code. Maybe they're all C# experts. Maybe that's a good idea to do it in a certain language. So this is defined on the system as a whole, and often they're what are called emergent properties. But they're also what are called domain requirements. So domain requirements, these come from the area you're working in. So for example, a domain requirement of any computer system that works within the UK is that it has to be compliant with UK Data Protection, the UK Extended Data Protection Act. That's a domain requirement. You can't have it-- it's affected by that. If it was an accounting system, something that would relate to rules of accounting, yeah? Let's have a look at some functional requirements. So all the users access the system using a user ID and a password. So notice, I've got enough detail in there to know that me as a user could simply test that. I need to put a user ID. Or the system should support the following formats-- PDF. Or every order should be allocated a unique order ID. Or the system should have a mechanism. So you can see how these relate to users of the system directly. They're what they're going to get. Sometimes requirements are not very precise. And the problem with that is that if you make the requirements and precise, when the developer's the developer, developer A will develop system one. Maybe that's Alice. And then developer B, Bob, will develop a different type of system. So that's quite possible. So ambiguous requirements are not highly desirable. We want them as precise as possible. So let's think of recovering a password. Well, we might think, well, I thought we'd have the password. Maybe I have to tell it my secret. So you know that thing where it says, what is your secret? And you say, where were you born? What is your mother's maiden name or something like that? You know they have those little secrets. What's your pet's name or stuff like that? That could be a way. Or the developer might thought, well, that's a bit complicated. I'll just send them an email link. There's positives and negatives. The problem with the email link is you-- well, what's the problem with the email link? Why isn't that a good-- why isn't that a brilliant way of doing it? Well, you need their email. Oops. Not everybody wants to give their email. Why do I have to give my email to use the system? It's horrible. People don't like throwing their email everywhere because they'll end up with loads of spam, don't they? It's not a nice thing. So there's a sense of-- to do the second one, there's a sense of implicit trust in the type of system you're developing. So the second one would be suitable for a medical system where you're probably quite willing to give your email to something like a clinic because a clinic's not likely to spam you with loads of stuff. But the second one would not be so good for something that's just like a-- like just some rubbish website that you just use every now and then. And you've got to have a password for it. But you don't want to give your email away. So the context of development will affect which one you choose for the type of requirement. So we need two things here in terms of delivering our requirements. Our requirements have to be complete. Everything has to be in there. And they should all be also consistent. That means that one requirement doesn't disagree with another requirement. And in practice, that can become somewhat difficult depending on the length of the requirement. So the longer the requirements are, the more complex the document is. The degree of inconsistency creeps in sometimes. So the non-functional requirements, these define system properties such as things like how reliable is the system, how quickly it responds, and any storage requirements. So we might say that I need the system to work-- because I'm developing a system for a DVD player, and the code has to fit into a 20 megabyte ROM chip, which is going to be an EPROM. It's going to be programmed. I have to get the code into that site. It mustn't be bigger than that, including any micro operating system and any tables and any other form of data. And there might be RAM constraints. So there may be those sort of constraints. And often, these are what are called emergent properties. Emergent property is a property that you only know when you've completely developed the system. You won't know it as you go along. You won't know it until you've finished the database and the remote access, how long the login is going to take until I've got the database set up on the server. There may be process requirements. So as I said before, what programming language are we going to develop in? Are we going to use OO development? Are we going to use particular case tools? Are we going to use Eclipse? There are non-function requirements which can be highly critical. So for example, if you have a key length for encrypting secure email and use a short key length, well, it's a rubbish security system. And that could be a critical error because people could then read all your email. And that could be very expensive commercially. And it could make your product useless. The non-function requirements can be broken up into a number of areas. So the first of that is to do with the product itself. So that's what I talked about before when we said how quickly it responds, how reliable it is, how secure it is. Those are typically determined, if you comply with those, by testing the system. So to work out if those are in, you've got to get the system running. And then you do some tests. Things like the security, working out how long the encryption length is, you'd probably have to look at the code itself. There are organizational requirements. So that is the bit, for example, like getting a particular programming language or implementing the code using a particular team or having some backup process. And then there are what are called external requirements. The external requirements are also, funnily enough, related to the domain requirements. So some of the domain requirements you could think of as external requirements are essentially non-functional requirements. So in terms of our classification for this module, we're going to broadly talk about functional and non-functional requirements. The domain requirements will come under these external requirements, typically. So we're not going to be thinking of three different types. We're going to just think two. So one of them would be confirmed to FIPS. FIPS is the United States. It's called Federal Information Processing Standard. And they have standards on how you must encrypt information, how you must store it securely, what information you're allowed to release. So FIPS is a little bit like the Data Protection Act here, but it's an American one. So they have these all over the place. Obviously, the EU has a number of standards as well. So some of them are similarly compliant. So let's have a look at some examples. Product requirement. All encryption should use the Advanced Encryption Standard. That also, funnily enough, could be one that was externally determined as well. Organization. You must conform to the process and deliverals defined in a coding documentation standard. I'll send you our coding standard for the university. Do that. I can show you that today. External requirement. The system shall not disclose any personal information about persons, apart from their name and reference number, to the operators of the system. That would be typically a requirement that would be within compliance of the Data Protection Act. The Data Protection Act says that you should not release any information to any users of the system, that it's none of their business to know. So typically, they're very wary about systems. You know, like when you ring up and you want some service and you're on like a-- you're calling a data-- you're calling like a call center. Those call center people, sometimes, some of them may have access to your address. Hopefully, a lot of them don't, because obviously, your address is quite sensitive information. If somebody finds out your address, they can dox you. They can put your address online. And that can cause terrible problems for people, having their address online. It's not something you want released. It's really important. And then performance requirements, how fast it goes. So it says, respond to a request less than 0.01 second and 0.01 seconds during normal time. It hasn't defined peak time in normal time. Maybe they should be defined. Looks a bit vague, doesn't it? Non-functional requirements can be a bit difficult to state. So we're going to determine a better version of the non-functional requirement, which is called a verifiable non-functional requirement. A verifiable non-functional requirement is one that can be objectively tested. So unless it can be objectively tested, it's not very useful. So the goal is what you want it to do. But the non-functional requirement is exactly how you want it to do it. So the goal is the intention. So the intention of saying, I want the system to respond in less than a certain amount of time, is the system's easy to use. Because it's not got long delays. So here's an example of a goal. The system should be easy to use by experienced controllers and should be organized in a way such that user errors are minimized. So notice with the goal, it's not objectively testable. I don't know what is meant by easy. Easy is a soft word. Easy for some people is not easy for others. And minimized, one error a day, one error a week, one error an hour. What do we say? What's minimized? It's like as best as we can expect. What does that mean? But we can take the goal and we can try and make it more precise. So it says, experienced programmers shall be able to use all the system functions after a total of two hours training. After this training, the average number of errors made by experienced users shall be not exceed two per day. Now this is testable. We can set an experiment up. We can put some people doing it. So we've got some precision here. It doesn't say what experienced means. Maybe it should say people with two months experience. Experienced, again, is a little bit soft. This could be improved a bit. So you can take it. You could tweak it. You could each time look at it and go, yeah, it's a bit soft, that. You're not going to sharpen it up a bit. So when you're doing the objectively testable thing, you need some measures. So for example, I could say that the speed of the system could be done as process transactions. The second, if I was doing a game, how do you measure the speed of a game? Have a measure, don't they? It's called FPS they have at the top left sometimes of a game. Frames per second. It's how many times they can refresh the page. And obviously, it's computationally within a game, with a modern game, very expensive to do all that computation. And getting the FPS rate up is quite difficult. So you could say FPS rate minimum of 25 on this hardware, on this platform. Needs context. Can't just say for any platform. You've got to put the context on. Ease of use, training time. Reliability, meantime between failure. Robustness, time to restart after a failure. Robustness usually means it means the system's failed, but it hasn't lost my data and it comes back nice and easy. So it means that it's sort of tough even when things go wrong. Reliability means they don't go wrong. So they're slightly different. They sound similar, but they're slightly different. Portability, how easy is it to get this code and build that into a new system? So I've developed my code for-- let's say I've been developing my code for Xbox, and I need to put my code onto PlayStation. How much of the code is portable between the two? It's possible for there to be conflicts between non-functional requirements. So the first requirement is the username and password mechanism should be easy to use. And the second requirement is all passwords must be hard to guess. And ideally, I have upper lowercase letters and special symbols to ensure high security. Evidently, the simpler you can make a password, the easier it is to type it in because you don't have to worry, remember. What's the problem with making passwords? Why does making passwords very complex? Some systems do this. When you go new password, you're not allowed to type in your new password. What the system has is a little client locally, and it generates a new password, and you're forced to use that password. What's the problem with that? I mean, it generates very hard passwords that you could never get in a million years. But what's the problem with that? What happens if passwords are really hard to remember? What do people do? They write them down. And in fact, they write them down, and they sometimes stick them on a little Post-it note on their thing. And then somebody comes into their office, and it's somebody's birthday. And they go, oh, I'm going to do a picture of them with their cake. And then obviously, the little Post-it notes in the background, and they shove it on Facebook. And before you know it, somebody's into your system, because they wrote the thing down, because you made a password that was so hard to crack that everybody wrote it down. And now your system's totally open. So these things are counterintuitive. So you need to make things that work in a realistic environment. It's really important. So what's the most critical requirement? Well, how do you solve this problem? Maybe you solve this problem by using biometrics. Maybe you think, I better use fingerprints as well or something, or two-factor authentication. You don't just rely on passwords. You've got to think about these problems before you try and solve them. Here's an example of domain requirements. So there is something called the Health and Social Care Act 2012 and NHS Act 2006. And this is a compliancy act for any computer system that you want to implement within the NHS. Being compliant with all this is quite hard work. That's why you can sell these systems for a lot of money if they're totally compliant. So people within the health care system using data for secondary purposes must only use the data, does not identify individual patients unless they have consent of patients themselves. What that means is if you have a load of information about people and their high blood pressure and what diseases they got, and you want to use that for research, you have to get rid of the people's names from the data so that you can't cross-reference and match it. The data must be anonymized before it's moved on. It's really important and compliant. Unless you have consent, and obviously for most circumstances, you wouldn't be able to-- it wouldn't be realistic to get consent. If you're doing a set of domain requirements, the problem is the requirements are now expressed in the language of the application domain. The previous example wasn't too bad, but there are ones which are a lot more complex. So the programmer is not necessarily going to be an engineer or an expert in health law or data or whatever, but they have to implement the problem. They have to actually do it in practice. So if you think of the previous slide, the programmer might not understand the law associated with data processing, and they might not understand about how you anonymize data, the correct ways to do it. The other problem with-- there's an implicit in things in these requirements. So the domain specialist assumes that things are going to be done correctly, but it's not written into the document. So there may be a lot of requirements that are implicit, but they're not being written down. And that's a problem because they won't get tested. If they're not in the document, they're not going to get tested. Then they may not be complied with. The user requirements-- so now we're on to functional requirements and non-functional requirements. So they have to be understood by the system user. So they're high-level requirements. So the user requirements must use natural language. So it must be non-technical language. But the problem with the user requirements and the problem with the natural language is it's somewhat imprecise. So we'll look at improving the precision of that. There tends to be things wrapped up so the functional and the non-functional requirements can be mixed up. When we do the next lecture and you start coursework 1.1, we'll see how we pull these apart. And then there's a certain degree of the requirements being amalgamated. That means all pushed together. And that's difficult when you're debugging and testing because, remember, the requirements we're going to use for testing our code. It's a good idea to have a standard format to use for your requirements. And use a language which is consistent. So there is something called RFCs. RFCs are Request for Comment document. They're a way of the internet defines its standards in these things called Request for Comments. It's a type of thing. And within Request for Comments documents, the word "shall" has a particular meaning. Notice I've bolded it. So "shall" is used for what's called a mandatory requirement. If you don't comply with a "shall" requirement, then you haven't complied with the standard. "Should" is something that you don't need, but is a nice idea, would be a good idea. So most implementations would have the "should"s in. The other one is "may." Now, it's important to have a "may" because it says what you can do. Anything beyond the "shall," "should," or "may," if you include another feature, you're not compliant. You've gone too far. So you need the "may" to define stuff that you're allowed to do as options, but anything else you're not allowed to do. Don't jump beyond that. So not only is the requirements document, in this case, saying what you should do and what you shall do, but it's also telling you what you should not do. Because anything beyond you may do this, you can't do it. You can't add it in. You can't just start adding in your own features to the language. So if you take something like HTTP, which is the protocol that's used to transfer web pages over the internet, you can't just add your own commands to that because it won't work. You've jumped out of the standard. Other servers complying with HTTP will go, "What? What are you sending me? I don't know what you're sending. I don't know these messages." So it's really important. In general, the document itself should ideally be self-contained. So anything that helps to explain the document should be in the document. And try and avoid too much jargon. Try to not make it jargon. So we just had a quick-- the most important take home for this lecture is this difference between user requirements and system requirements. And functional and non-functional. And then this verifiable function. Because they're in Core cert 1.1. So that will help you to understand, hopefully, when in Core cert 1.1 you've completed it, you'll understand this lecture. So remember, the functional is what the system does. The non-functional is how it does it or how you develop the system. And then the user requirements, this high level view rather than the system requirements. [BLANK_AUDIO]