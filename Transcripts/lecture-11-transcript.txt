[SIDE CONVERSATIONS] OK, good afternoon. [SIDE CONVERSATIONS] So in the last session, we were introducing a number of modeling techniques. We looked at Moore machines. We looked at Mealy machines. We looked at the equivalence between Mealy and Moore machines. We had a look at some entity relationships. And it introduced to you the idea of a PetriNet developed by and proposed by the German computer scientist Karl-Adam Petri. Today, we're going to be spending a bit more time looking at PetriNets. And we will continue this in the next lecture. So today's session, we're going to look at modeling based on PetriNets. So first things first, just let's have a quick review of some of the general principles of PetriNets that we introduced in the last lecture. So Karl-Adam Petri invented PetriNets a while ago, did his thesis on PetriNets in 1962. And there's been a lot of research. And generally, if you've got a model that has already been understood well through research, you can then do analysis on it. So you can put a proposed model for a PetriNet. And then you can look at the reachability. What sort of states is it capable of getting into? And that's useful because then you can ask the question, what sort of states is the computer system itself capable of getting into? So the whole idea here is we're modeling the requirements in a simplified and abstracted form and then using that to ask how we want the computer system to behave. And then we can look at our model. And we can ask questions about it and see if those questions are valid or not. So if it was for a safe system, we'd want to know, is it safe? You know, if it's a safety-critical system. So until roundabout-- so for about 20 years, it was mainly of theoretical application. But since then, a lot of work has been added in. So since roundabout the 1980s, because they added a bit more onto PetriNets to make them more powerful, they're now useful for modeling real systems. So high-level PetriNets are what we looked at last time, where we have the places, and we have the transitions, and the arcs, and the tokens, and firing, et cetera. But we add some extra things to help us make these more useful when modeling a real system. So now the places and the transitions, instead of just being theoretical things, we can apply a bit of meaning to them so they're useful. So we add in color, which allows you to put in attributes. So now instead of just a token being a token, now the token can represent something in the real world. We can add in timing on the PetriNet to allow us to ask questions about how long something may take, given a different circumstance. And because we want to develop complex PetriNets, we add in this idea of hierarchy, where we can put one PetriNet inside another PetriNet. So we're going to look at some of these in today's session. So why are we doing all this? Well, because we're talking about requirements. Remember, we've got the first block of this subject is largely about requirements. When we wrap up requirements in a week or so, you'll be moving on to system design. But for requirements, we want the requirements to be unambiguous as possible. We want them to be clear. We don't want one programmer to get the idea of how they're going to develop them and come up with a different idea than if another programmer got them. So it's really important. So the PetriNets are useful for that, because they're a formal description of the behavior of the system. It's formalized. Formalized is the word. They're also useful for distributed systems, because in PetriNets, remember, there's different things that can happen. Different transitions can fire. So like in a distributed systems, where I have multiple processes that can be going on approximately at the same time, within a PetriNet, I can have multiple actions that can happen next. And they're also useful for modeling anything where you're sharing resources. So remember, in computer systems, you can have multiple processes, multiple blocks of memory. Those multiple processes can access the different blocks of memory. Even when you just have any computer system, it has variables, it has memory, it has stuff that data that gets stored. And that gets shared between different threads, executing executable threads. So when you work with a concurrent system, you want to be able to deal with that resource sharing. The other thing to note is because the PetriNet allows multiple things to happen next, you don't know which one's going to happen, but any one of them can happen. And we don't know which one's going to happen. They're good for modeling non-deterministic systems. And many concurrent systems, we don't know what's going to happen next. They're, in that sense, non-deterministic. It's not just going through a standard process. It depends on what external events hit our system. So for our fire alarm, we don't know if any one-timer smoke detector is going to go off, do we, or a heat sensor or anything like that, or there's going to be an emergency. It has to be able to deal with any of those sort of chance events. And that's what PetriNets are good for. They're good for modeling those things that cause those characteristics. So reviewing what we started to look at the last time, remember the PetriNet has a whole load of places. So each of the places is represented by a circle. The places are connected to transitions, and the transitions can fire if they are enabled. So here, transition one is enabled because it has a token on all the places that connect into transition one. If it fires, this token's consumed, and tokens are then generated on the outputs. Notice, tokens do not move from the inputs to the outputs. They are consumed on the inputs and generated on the outputs. That means tokens can come from nowhere, and they can disappear to nowhere. They can actually disappear out of the PetriNet. So the connections also between the PetriNets are directed. So notice the use of this arrow here. It's very important that you follow the arrows on the diagram to understand what's happening. So that direction is relevant as well. So we've got P1 connects into T1, and then T1 goes out to P2. So that means every time this fires, tokens are generated here in P2 and here in P3. The tokens themselves are dynamic objects in the sense-- not in the sense that they move, but in the sense they can be consumed and then regenerated on the graph. So in a general sense, this network is a graph, isn't it? It's a directed graph. In terms of notation, it is also equivalent to put a solid bar for the transition like this. So either of these could be used-- for example, if I showed either of those in the examination, this or the previous slide, you should be able to understand. Very often, you'll find this is used for the exam because it's easy then to mark the transitions T1 and T2. You can just put it inside the box. But that's equivalent to the previous graph. And it just makes it a little bit easier. So notice this T2 can sit inside the box if you do it this way. The patrinet itself has a state. And that state is described by what's called a tuple, a number of items of numbers inside brackets, which describe the distribution of the tokens across the network. So the only thing that affects it is this distribution of tokens. So in theory, if you could put enough tokens in there, in theory, you can have a lot of different states of a given patrinet. And in fact, some patrinets have an infinite number of states. And some don't, depending on their initial configuration. And then they can fire. And then evidently, the tokens disappear. And then they're regenerated. And that creates patrinets with different distributions of tokens. So whenever you look at the way it's done, it's done as a tuple here. So notice we've got 1, 2, 1, 1. And then after firing, the numbers will change. The transitions themselves can have more than one input and output. So here we have a transition which has an input from P1, an input from P2, an output to P4, and an input and an output to P3. Notice in this case, if the transition fires, the number of tokens-- bless you-- the number of tokens within P3 will stay the same. Because one would be generated and one would be consumed. So P3 has an input and an output. So if this fires, there'd be one generated here, two consumed here, one consumed here, and then regenerated again. So it wouldn't be the same token in theory. It wouldn't be the same token in practice, never mind. So the transitions, those are the things that do. They're the active components. And the transition is enabled. If every input place contains tokens. And it's a bit deeper than that because it depends on the weighting on the input. But if we look at this, we can see transition one, in this case on the left hand side here, transition one, is not enabled because it doesn't have any tokens in here where I've got the mouse. This one with T2, we'll notice that it has both these, have inputs, therefore it is enabled. If it's enabled, it may fire, but it doesn't have to fire. We just don't know. It could last there 100 years, 1,000 years. It could fire in the next nanosecond, the next millisecond. So it's this idea that it's capable of firing. A little bit like you've got your precondition on your use cases. Remember that precondition? If it's true, it can carry on. So for Petrinet, the precondition for firing is that there must be enough tokens on the inputs. And that is different depending on the weight of these. So notice that's just one and one. But if this had a weight on here of two, it would need more tokens within here to fire. So by default, any enabled condition may fire. And firing consumes the tokens from the input and generates tokens on the output. The other thing to note, and this is very, very critical when you're looking at the nets, is that the firing is totally atomic. So if I have 20 transitions across a network all enabled, the next firing of any one of those will pick one of those out of that list. So only one of them can fire. Then the network goes through its change of state. And then on the next time tick, another one of them can fire. And that one could fire again in theory if it's still enabled. It's very important that the firing is atomic. Because if the firing wasn't atomic, if two could fire at the same time, you could have weird things happen like the number of tokens consumed would be more than the number of tokens that were there. So it would cause logical problems with the network itself. That's because firing consumes tokens. So we have this idea that it's atomic. Obviously, in real computer systems, if you have multiple processors, in theory, two events can happen exactly at the same time. But in practice, because they're all contending for resource, and if they're both wired to the same bus, they sometimes have to wait a little bit of time before the other one's finished accessing it. So you get that in hardware. There's something called direct memory access chip. That's typically wired to one end of the computer's bus. And then the CPU is connected to the other. And they both have to share the memory. So when one is accessing the memory, the other has to back off, et cetera, et cetera. And you get this typically in computer systems where each event can happen as if it's happening at the same time. But there's always a slight difference in timing. So here's an example of a PetriNet. And this PetriNet is going through a series of firings. So it's similar to the one we've bought. So here we've got three on this input here, one on this output place there, and one in this one. It fires. One gets consumed here. One gets generated here. One gets both consumed and generated here. So notice that stays as 111. This reduces to 3210. And that goes from 1 to 2 to 3 to 4. So notice the other events. It's sort of going in a circle. It's going in a clockwise circle. And then at the end here, notice at the end, the transition is not enabled because the input only has no tokens on it. And this state where no transitions are enabled in the whole of the network is called deadlock. So deadlock is where the thing can't go through any more transitions. And often the problem with deadlock is it defines a state where the system can't progress. So deadlock could be seen as a problem in some systems because no other events can happen. And if these events are useful for the working of our computer system, we could see deadlock as a problematic state. So the other thing to note about this is you can also see that reachability of this network. The reachability of this is just described by this 1, 2, 3, 4 states because those are the only possible states this initial network can get into because once it's finished, bang, you're done, aren't you? You can't get any more. A transition without any input-- so look at T1 here-- is by default enabled all the time. So if I look at this transition here, and then after a certain amount of time, because this is automatically enabled, it will fire, generate a token in P1. Then after a certain amount of time, hopefully, it will fire, it can produce output in P1 again. And it will transition, can fire again now from this state here and produce another output on P1. A transition without any input is a little bit like a clock coming on the edge of a circuit. So if you've done a little bit about computer hardware, you'll notice you have the CPU. Then you have an input clock, which tells it every time, it's got to do some type of internal operation. It just gives it a little waggle. And the speed of that clock, obviously, determines how fast the CPU can operate because every time it does that, the CPU does some kind of internal or external operation. But note with a petri net, because we don't know when it's going to fire yet, it's not quite like a clock because it's not on a regular basis. So we know that it can happen. You can when we look at putting timings on petri nets. And if we could put a timing constraint on this T1, then we really would have a clock. So when we look at the extension with time, then we can have a whole net with a T1 on the edge of it and use that to clock the whole net so it changes its internal state. OK. A transition-- so that's the transition without any input. Without any input, the transition without any output just consumes tokens for as long as it is enabled. So notice in this case, T1 is enabled because there are three tokens here. So in this case, T1 is consuming the tokens. So it fires. Here, the number of tokens is 2. It fires the number of tokens is 1. It fires the number of tokens is 0. The thing to note about this is that the last one I called it a clock or a source. This you could call it a sink. It's something that's a consumer, isn't it? Just sink. That's a good word for it. And there are things that consume resources or whatever. Let's have a look at the situation which shows you proper non-determinism in Petrinax. Here we've got two tokens here-- oh, sorry, one token, not two transitions. Two transitions, T1 and T2. And it's been fed by one token from this place. Notice that is a situation which you could say is conflicted. Because either T1 will fire or T2 will fire. If T1 fires, T2 is disabled. If T2 fires, T1 is disabled. They're fighting against each other for the resource of this token. You're starting to see that these little tokens can be seen as resources, resources needing to allow something to proceed. OK. So if this was two-- let's say this was two people working on a production line making something, and they were processing it. And they had a table in front of them with some stuff that they had to do. Either one of them could take the item and process it, or the other one could. And evidently, if you have multiple tokens in here, one could fire, and then the other could pick a token. Notice, even if there is two tokens on the left-hand side, they still cannot fire at the same time. That's not allowed. Still has to be atomic. All it means is that they could fire, and the difference between their firing times could be infinitesibly small. It could be one picosecond, one nanosecond, the smallest amount of time you can imagine. But they will still be discrete events. But because that time is so small, it can almost be seen as simultaneous. If you can have an amount of time that can be as small as you like, that's fairly instantaneous as far as we humans are concerned, isn't it? So if you think about it in that respect. So the firing is arbitrary and non-deterministic. The other thing to notice, the firing's not fair. If I have 10 tokens in there, T1 could fire 10 times randomly, and T2 could not fire at all. That's possible. Because it's just random. There's no rules about it. So don't get the idea that because this one's been firing, this one should fire or whatever. There's no rule about that. There's no fairness in this. It's just done randomly. Because we've spent all this time working on the petri nets, we've got to ask ourselves, what are they useful for? What are we actually modeling? Remember, modeling is taking something from the real world and then working out, doing a way of looking at it, but in a formalized fashion. In general, for the modeling, there is an analogy between things in the real world and the tokens, places, and transitions. Tokens typically represent resources. And we'll look at some examples of that within the lecture. So anything where there's goods or machines, things that you might need. If you're doing a production line where you were making a product and you were making this keyboard and you needed all the different parts of the keyboard, including all the keys and the bits behind, each of those could be a token. It could be the bits that you would need. The places are things where stuff is stored. It's typically where resources are stored. So they represent buffers, channels, geographical locations. If I was making the keyboard, the places would represent a warehouse where I was storing all the stuff. So these are useful, storing all the materials. These are useful for modeling things like supply chains, supply chain management. And then transitions are events, things that happen. So if I was doing manufacturing, a transition could be manufacturing a car. And the tokens could be the components for the car, including the engine, the four wheels. I'd need four wheels, wouldn't I? I'd need the roof. I'd need all the bits, all the electronics. Every one of those could be represented by a separate token. And there is some more examples of modeling within the Petronet tutorial. So there's a tutorial that goes with this, a tutorial sheet giving you some detailed modeling questions. But today's session, we're going to be modeling a traffic light. So the traffic light, a classic traffic light, goes from red to red amber to green to amber. So we're going to simplify this a bit just to make sure that our Petronet doesn't get too-- it's so that it's not too messy to go on the slide. But essentially, we need to make sure that the traffic light is capable of controlling the traffic both safely and fairly. So we'll discuss what we mean by that as we go through today's session. But it has to go through these sequences. And notice when it gets to the end of here, when it gets to the end of that sequence, it comes back again to red. And it just goes through this sequence all day and all night. But a traffic light is obviously a safety-critical system. If a traffic light goes wrong, people can be killed. There can be accidents, be very dangerous things. So this is really important to get this correct, isn't it? However formalized we're going to make it. So here's the description of the traffic light. Notice this is in English. But we don't want it in English because English is a little bit ambiguous. We want it in Petronet form. So we're going to start off with the description in English. So we're designing a traffic light system for a crossroad. So there's a road going this way. And there's a road going this way. And evidently, when the traffic's going this way, this traffic's got to stop. And when it's going this way, this traffic's got to stop. And you've got to stop this traffic before you start that traffic. You have to get the order of events right. And then you've got to stop both of them and let this one go, et cetera, et cetera. So the single traffic light goes from red to green to amber, then back to red. So we're not bothering with red and amber. We're simplifying some of the flow. That's fine. Because the most important thing is the red and the green, isn't it, because they're the safety things. The amber helps. Makes it easier for the drivers to control the driving. But in theory, you could just have a red-green traffic light. I mean, you could make it safe as long as it didn't move too quickly, yeah? So there's two sets of lights. There's one for one of the roads and one for the other road, and evidently, when one's on green, the other must be on red. And when one's on red, the other must be on green. There are other states which are fine, like both being on red. But what we must not have is both sets on green. Because obviously, both sets on green is going to end up with a crash. So we're going to decide to model this system as a petrinet. And it's useful because it means that it's formally defined and reduces the ambiguities later. So obviously, this example will be quite quick and easy to learn, will seem somewhat trivial. But you can imagine for a lot more complex system, where I have a whole number of lights, I can expand and expand and expand it to make it safe for quite complex lighting systems. We can also prove properties about the model because we formalized it. So just in this description, it's hard to make any formal description. But when we do the traffic light in the petrinet, it'll be more formal. So here's our petrinet for our traffic light. Notice the position of the token defines the state of the light. OK, so when the token's up here, it means the light is on red. If the token was sat down here, it would mean the light was on green. And if the token was in the middle one, it would mean that it was on amber. Amber's just another word for yellow, really. So if you're not familiar with it, but just amber just means yellow. So it's just that stuff that comes out of trees that they're having Jurassic Park. It's a lot of complicated stuff, anyway. So the traffic light now can go through a number of states depending on where the token is. So it starts off in the top. Notice there is only one transition that is enabled. That's this RG one. And after a certain amount of time, this can fire. And it can go down here. And the light can go from red to green. So the light, once it's in red, can't get to amber. It can only next state it can go to green. This token will be consumed. A token will come down here. Then after a certain amount of time, since this one is enabled, the light can go from green to amber. Since this one is enabled, tokens consumed. Token will appear there. And then when this one fires, the token will be consumed from there. And it will be generated on there. And there will be a token up here again. So notice, in essence, that controls one traffic light. Fine. OK? This works in terms of making sure it goes through the correct sequence. And evidently, we can just double up on this. We can just have two traffic lights going through this. And evidently, we do have some controls. So it starts off with both on red. But we've got a problem here, haven't we? What's our big problem in what we've got in this example? As it stands, what's the danger? What could happen with it? Notice, these are two independent Petri nets. They both-- [INAUDIBLE] They can both go green at the same time. There's no constraint on that. And if you have 10 of them for 10 roads, they could all go green at the same time. OK? Or they could both all just sit at red at the same time, and just no traffic would flow. So there's no sense of synchronization. Good. OK. So we have a problem here, that these aren't safe. There's no way of controlling. So what we need to do is we need to control. We need a relationship between this Petri net and this Petri net. We need to join them up so that, as you say, there's some synchronization. So we put in an extra little place. This place is called safe. And this place determines whether it is safe or not. And whether it is safe for either of the lights to go from this red green-- so notice this safe one has an input into RG1 and RG2. OK? Now, both RG1 and RG2 are enabled. OK, so in theory, they could fire. But notice they're both sharing a token out of this safe. OK? That means we're back in that state I showed you before, where you had two transitions with just one place and one token. One can go, or the other can go. And now you can see why it's important that you have atomic firing. It's very important that these cannot fire simultaneously. Because if they could fire simultaneously, we wouldn't be able to predict this was safe. Because one must fire before the other, only one can fire. OK, so if RG1 fires, this token disappears here. RG2 is disabled. If RG2 fires, RG1 is disabled because the token disappears. Notice also that the safe token, after this fires, there will be a token put here, and there will be only one token on the whole of the net. Yeah, this token will disappear from safe. Then at some time later, there will be a firing, and the token will appear here. And then at some time later, this light will fire. This transition will fire. This light will go back to red, and the token will be generated back in. So it's important to see that the token's consumed at one point, and then that we know that we're safe, because only with the other ones switched off. And then as it comes back to go to red, we know that we're allowed to go again. So every time it goes to red, the token reappears. Every time one of the lights goes to green, the token disappears. So the token corresponds to-- that's why it's got the word safe in there. Because if there's a token in there, the thing's safe to go. Obviously, if you put two tokens in there, it wouldn't work, because both of them could go to green again. So you've got to get the right number of tokens. It's really important. But we'll look at ones where we resource and have more than one token in a sec. OK. So before we go on to the next slide, the only problem here is-- the only problem with this is, if you look at the left-hand side, it could go to green and then go back up to the top, and then go to green and then go back up to the top. In theory, it could just keep letting one lot of traffic go all the time. OK, that's not so good. To get around that problem, you introduce safe one and safe two, which control the transitions for each one in turn. So notice, instead of having one safety place for one of the lights, I have two safety places. This one's controlling the light one, and this one is controlling light two. And now the difference here is quite remarkable. It means that after this, at first, this light is enabled. It fires. This token is consumed. And notice that only one of the lights is-- this red light is disabled to keep it safe. Then when this one fires back to red again, when this happens, it enables the other light. So the enabling with this moves from left to right to right to left, allowing the thing to be fair. There's still one problem with this, and we're going to deal with that in the next lecture. Obviously, because we don't know when this is going to happen, even though it's safe and fair, they could sit there still for 25 minutes, waiting for them to randomly fire. So there's some implication here that the thing has to have some timing constraints on it. It's not quite complete, but it's safe, and it's fair. And you can make lots of predictions about it. And if it's safe and fair and make lots of predictions about it, we can just change the timing how we like, can't we? We can say, oh, well, suddenly we realize that lane one is very, very busy. Let's keep clocking that. Let's leave that one on for longer, this one on for shorter. We can make loads of decisions about how we do the timing. That's not going to affect our safety. What we've done is we've decoupled the timing problem from the safety problem and the fairness problem, which is nice. Decoupling, pulling them apart logically is a good idea. So can you prove that the petrinet from the previous slide will never allow two red lights to be shown simultaneously? How would you do that simply? What would you do to prove that two lights couldn't go green at the same time? What would be the easiest thing to do with this petrinet? [SIDE CONVERSATION] I mean, for example, if I asked you-- I mean, without even totting up-- is this a finite state petrinet or an infinite state? Can we go-- how many sort of states are there? Is there 100 different possible states? It's not so many, is it? Yeah, we can go through them. It's not going to take long. I mean, even if you like to think, oh, I missed out one when counting, but it's not going to take you long to go through those states. And evidently, I could-- if I had a petrinet simulator, I could get it to go through all the states and then log them and see which were good and bad. So there are petrinet simulators. You can get them, and you can put the thing in, and you can say, that's my petrinet. I'd like you to run it to completion. And if your petrinet simulator determined-- it could determine whether it was bound-- what this is called, rather than finite or infinite state, is whether it's bounded or not. It's within a region. In general, for a petrinet, you can either define it as a network of possible states or a tree of possible states. Sometimes they come in a tree. If that tree goes on forever, it's unbounded. If the tree is finite in scope, it's bounded. And you can then make conclusions about whether it's safe or not, which is cool, which is nice. So the answer is, yes, you can prove it, because it's bounded, because there's only so many states you can get through. OK, some more basics about this. So what you can do is put multiple arcs between nets like this. And multiple arcs imply that you need multiple tokens to enable a state. So look at RR down here. RR is only enabled if there's two tokens on here. Whereas this one, this black one, is enabled if there's-- sorry, not that one. That's not the one. This one, BR, is enabled if there's only one token on its input there. So the use of that in terms of modeling, it's useful for modeling what are called disassembly assembly processes. So I could have three things coming in, and one thing coming out would imply I was taking three of the bits on the tokens, joining them together to make something else, like in a production line, like making a car. So you could have four wheels, yeah, would go in one car, wouldn't they? You can imagine that. The current state is commonly called the current marking. And there is something called the reachable state, which is a state that can be got from the current state after a number of firings. So when I was asking the question about the traffic light, I was really asking, what are the reachable states, and are they all safe? The last one is what's called the deadlock state. That's where no transitions are enabled. And evidently, if I had a deadlock state for my traffic light, that would be a problem, because my traffic light couldn't move. So I'd be in trouble, because none of the traffic would come to a halt. So whether you want to have or you need a deadlock state or what the reachable states are, these are important questions about any given network. So in general, you want to write the current state by a tuple with the numbers in it representing the tokens on the number of places. So in this one, notice it starts off with 3, 2. I've got 3 here and 2 there. And after this, rr fires, because 2 will be consumed here, so I'll be left with 1 in this red state. And 1 will be generated here, so that will go from 2 to 3. It will move from 3, 2 to 1, 3. When you're actually determining the reachability of a petri net, you want to do this, but for all the possible combinations of firings. So here, notice I've got 3 transitions, so I've got 3 possible firings. If I was going to analyze that as to find the reachability of the petri net, you can start to see why I talk about a tree, because if I start off with 3 of them enabled, I go down 3 branches of the tree, I get those states. Then, depending on the number of states that are enabled in those, I can go down another branches of the tree. So if you describe the reachability of a petri net as a tree, the branches of the tree represent which transitions are firing, and the nodes, the leaves of the tree, the nodes of the tree, represent an actual state. It represents a tuple. So if I look at this one, I can break that down into a number of-- I can go through the number of possible ways this can fire, and I can simulate this in a petri net simulator. Starting off with state 3-2, if RR fires, I go to 1-3. But when RR fires, I'm in 1-3. Notice RR is not enabled, but BB and BR are enabled, so I can go from that to 1-2. And then if I go down this branch, where I go BB or BR firing, so that's BR or BB firing, I go to 3-1. And then fire again here on BR, I go to 3-0. So notice in this, when I draw this tree, here are the states, there's the nodes, and here are the different transitions on firing. Notice some of these go to the same state. So BB and BR take me from 3-2 to 3-1. OK, they're similar in terms of what they do to the number of states. That's because, notice, BR firing doesn't affect the number in red, because it's got one in and one out. OK, so that's why that stays as 3 going through the BR firing. And then BB or BR, well, BB also doesn't affect red, because it's not connected to red, is it? That's why you've got this assistance. You go through all these, and then you end up falling out the bottom here, and you end up locked in the deadlock state. So to do this as a programming problem, it would be a tree. So you go through the petri net, you look for the live nodes, for those live nodes, you take them as branches off the next one of the tree. For each of those you try, you could do it using recursion, something like that, where you just called yourself again for every one of these nodes, and then you'd call the function again. This is ideally-- trees work very well with recursive programming. So we're going to have a look today at the-- this is the last example I've got for today. And this is an exercise in reading and writing email. Notice here, I've got something. This is individuals who are resting for a bit, and then they type an email. And then when they finish typing the email, they go to this process where they click and they send it again. So notice the token is describing the state they're in. They're either resting or they're typing the email. So they're resting for a bit, not bothered what they're doing. Then they start the process, they start typing it. They click Send. This means clicking Send. Every time they click Send, a token gets fired into here. This can't receive an email till there's a token in here, and it keeps going up. And then this person's resting. They decide they've got an email, so they click. They start reading it. When they finish reading it, they go back to here, and then they wait until the next email comes in. So you can ask yourself for this. How many states are reachable? Are there any deadlock states? How would you model a situation with two writers and two readers? And how to model a bounded mailbox? So that is an exercise for you to think about before the next class. So that's it for today. And I'll go through the solution in the next class. So it's for you to have a think there, just a little think about how you'd do that. OK, so there's the attendance code. I'll just put that back up. And I'll just-- [SIDE CONVERSATIONS]