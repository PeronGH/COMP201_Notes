Okay, good morning. Today's session we're going to be starting the process of looking at OO design. So OO design is actually split into two bits. It's split into something called OO analysis and OO design. OO analysis is usually working out the names and the relationships of classes. OO design is working out the attributes, methods and responsibilities of classes. But in a general sense we're going to put this together under one umbrella term called OO design. And we're going to, as part of this process, we're going to be structuring our code into what I call the collection of objects. So the objects have two very important things about them. They define the data of your code and they also define its behavior. How you do your OO design, whether you're focused is more on the data or more on the behavior, breaks it into two approaches. So the first one is called a data-driven design, where you're focusing more on the data. And the other one where you look at more like behavior is called responsibility-driven design. So you take a given class and you ask what its responsibilities are. So when you think of something like your alarm, your fire alarm system, you have things like the cards and the cards, you know, they store data about people including their pin numbers and things like that. If you were focusing on that, that would be the data-driven thing. If you're looking at something that would be the fire detector, that would be a responsibility-driven thing because it would be having the job of detecting fires. Okay, so how you do it, but by using this approach, it allows you to design from both angles. So we're going to be keeping on these questions about what a good system is like and we're going to hopefully work out that the OO paradigm gives us good loose coupling and good coherence. So we're going to answer questions about what we mean by an object, how the objects talk to each other, the interface of the objects, and we're going to briefly look at objects and components. We're also going to look at these terms, inheritance, polymorphism, and dynamic binding. We also cover these again in software engineering too, but in more depth, in particular dynamic binding, static binding, various other aspects of including the solid approach to OO design. In general, you don't think of, it's important to think of an object not for what the data is inside it, but what services it provides for you. So the data inside is not going to be exposed publicly to you. You're going to have to get access to that via the public interface, which is defined by its public methods. In general, the public interface does not want to be too big, because if it's too big, the object itself, the object class itself, loses coherence. Hopefully, when you've got a set of objects that are very well written, they can be reused in other projects. So the idea of good OO design is to have very high levels of code reuse. If after you've done your OO design and you've developed your project, you look at your OO code base and it's not highly reusable, then there's something gone wrong with your OO design. The object very often represents something in the real world, but for a lot of configurations, it doesn't have to. So it often doesn't and it often does. An example of where it represents something in the real world is typically with information systems. So if I do an information systems for a hospital, there'll always be an object representing a patient, an object representing a treatment, an object representing a doctor. But there may be other objects which don't represent things. So it's useful because now the software design more closely resembles the things in the real world that it's meant to be controlling. So it's easier to understand from a domain point of view. An object is anything in the computer system that you can interact with. So in general, you can send it various messages and it will react in some way or other. It will respond. The behavior of how it reacts depends on its internal state. So part of the, so for example, part of the object's reaction for receiving a message will be dependent on its internal data. So think of something like a getter on an object, a getter on an object class, when I call it, the return value depends on the attribute it's getting. Every object on the system has an identity that distinguishes it from every other object in the system. If you're working in Java, that object's identity is its reference. Okay, so I put name of a variable, a type of variable, name of a variable, and then I go equals new object. A copy of the object's identity is copied into the variable and that's called a reference. And that tells you not only where the object is in memory, but it gives you information about the type of the object, the class of it. So a clear definition of what an object is developed by Grady and Bush is that it has three important things. It has its behavior, okay, which will be defined if you write an object class by all its methods and its internal code. It has internal state, which is the value of its variables or attributes, etc. And it has identity, which object you're actually referring to in memory. So it's possible to have two separate objects which have exactly the same behavior, which currently have the same state, but they're two different objects in memory, so they have different identity because you're pointing to different blocks of actual data and memory. So the state can be identical, even if the identity isn't. The good thing about structuring your code using objects is now we don't share data. The object stores the data securely and encapsulates it, stops other people writing to that object. So the objects are independent of other objects. They wrap up and encapsulate the state in a private manner. And it means that they're easier to look after. It means that other people can't change the data inside the object without the object being involved in that process. So the state of the object is all the data which it currently encapsulates. So that means all the values of the named attributes or instance variables each have a value. Some of those attributes can be references to other objects. So one object's internal state can be other objects. There's no reason why that can't be the case. Some of the attributes can be mutable, so somebody's address could change. But other attributes can, in a logical sense, in a domain sense, be immutable. So somebody's date of birth or identifying number would not be something that would change. It would be fixed. You can make an attribute mutable or immutable in the sense of Java by including or excluding a public setter on that method. So you don't have to put, if you just remove the public setters, now you've got an attribute that is immutable because it cannot be changed by a standard setter. So an example of a object which has immutable state in Java is the objects of type string. They're all immutable. You can't change what's inside a string. You can inspect it, you can make other strings from it, but you cannot change its internal state. And it does that for memory efficiency reasons. It's just easier than reallocating all blocks of memory and doing it that way. What it does is it just duplicates more strings. It just finds that easier to handle. The object also has behaviour. So when I send a message to an object, I'm going to get some response from that message. So it can receive a message and act on it. In Java, receiving a message means having a method of the class of that object being called on that object. The messages that the object understands is normally fixed for languages which have a certain degree of what you call fixed interface. So for Java, when you have an object, the object has a class, the class defines some public methods. Those are the only methods that you can call on that object. There are languages such like JavaScript where you can change the methods later on. You can add in and dynamically change the methods. There are some versions of PHP where you can do that. You can dynamically add the methods in there. But that does mean that it's easier to create bugs and errors in the language. So the fact that it's normally fixed is a good thing. It means that it's fixed in terms of once you've coded it, as the thing runs, it doesn't change the behaviour. The object's identity is which object it is in memory. If you think of, you've got the object class which is its type which defines all its methods, all that information about the object structure. But then you've got, when you create new, when you call the new keyword in Java, you make a new person or a new doctor or a new anything, that creates a brand new object in memory. Each time it does that, it creates an object with a unique identity. So every single time you call new, it makes an object with a new identity and that is a distinct object in the computer's heap memory. So we can have an object we call my clock and it understands a various series of messages which relate to something being a clock. So it allows me to report the time which will give me the time, return it back to me, and then reset time which will allow me to change the time. So you can ask how it would implement the functionality, how it does the clock, how it works with the time, whether it works with time zones, but that doesn't matter. You don't need to know that. So any information about implementation with any given object needs to be hidden. It needs to be hidden inside the object. So it probably has an attribute like time, it's probably a 64-bit long int, giving you the number of seconds since the 1st of January 1970, something like UTC time, but you don't need to know that. It's not really important. So it passes the messages to some other object, it deals with something internally, maybe there's some counter, some internal operation, but how it works is not of importance to us. It's important that it works. Each messages the object takes include a selector. In Java, the selector is the name of the method you're calling. The message also can include one or more arguments. Because of overloading in languages like Java, it's possible for the message to be different depending on the arguments sent in, and it's possible for it to call different code. So for a given selector, there is a given set of correct number of arguments, but in Java, obviously it can have reset time too, and I could take in three arguments which might be the seconds, the hours, the day, the month, a multiple of arguments, or it could just be a time in seconds. So remember that this is more complex in things like Java, because it has things like overloading. So we could have an object, a person, it's got an identity with some internal state, has a behaviour, has a method on it. There we've got another example of an object called printer. It can be online or offline, but it has a method called print document that sends a document for printing out. And then we've got a security object called login, which has identity login, and that has internal state of having a username and password. And this has a method called validate, which does all this stuff. It hashes the password, loads the credentials from the database, checks the password, does all the details of that. Notice by wrapping all this detail into an object called security login, it means that I can change the way that the authentication is done, but I wouldn't have to know about the details of that if I just used that object. So it makes it easier for me to reuse this object in other projects. In general, the object itself has a public or private interface. The object's public interface just defines which messages it accepts, and in Java, accepts all the methods that you can call on that object. Typically, the object itself has two interfaces. There's a public interface that anybody can use, and then a larger private interface. In Java, there is a reference called package private, which is when you don't put the word private and you don't put the word public or protected, you just leave the thing with no name. If you have package private, it means that any of the code and any of the classes that sit in the same package as that can access it. So it means that they can have friends, they can talk to this sort of internal interface. You can use that to create that facade structural look type before, where you want to have a number of classes that can talk to each other very intimately, and then have one public class on the outside that provides a public interface to the services. So in Java, there is a public and a private interface, but there's also a package interface and a protected interface. There is another keyword called protected, which means that a subclass can access that interface as well. So it's a bit more complex in Java, it has more complexity than this, but in general the public interface is there with all languages. For each object, the classification of the object depends on how you want to see that. So I've got an example here of a cat, and notice we have the little old lady looking at the cat, she just sees the cat as something that purrs that she feeds it food, and just has an external view. Here's a veterinary surgeon's view of the cat, the vet sees the cat's heart, the lungs, the liver, all the internals. So you as a developer, you're really on this side, you can find out the internal operations of the cat, but if you as a developer want to just use an object that somebody else has developed, you're going to have this view. So your view of each object and class depends on if you're just using that or you're developing that particular object or class. So that depends on your view as a developer at any one point. Objects which share the same data structure and the same operations in Java and other languages, but not JavaScript, mind you, some of the languages don't have this idea of a class, are grouped into a class. So here we've got all giraffes, well they all have a long neck and they're all like that, and they all have all those funny little things on their heads, don't know what they're called, horns or something. So all giraffes are of the same classification giraffe, all lions have the same classification of lion, all snakes have the same classification of snake. But here we've got a confusion here because we've got something with a lion's head, so it's got a classification of this one, a snake's body and a giraffe's, a snake's tail and a giraffe's body. In some languages you can create objects by inheriting from multiple other classes, multiple other classes. You cannot do this in Java, you can only inherit from one. Each class can define as many instances of objects as you like, as you create, so it's as possibly infinite, depends how much memory you have to create. So the object is the instance of a class, so before you even create an object, you have to create the class which defines its type. The object instance knows its class, okay, and it knows it in the sense that it knows it at run time and it knows it even if you cast it to a different type, it's still known, the JVM will know that. Each instance have its own value and for each all of the attributes. Some of them, but you can share a set of attributes between the instances by using the word static. You should only do that unless you very, very, very much need to do it because it's not thread safe, it can create a lot of confusing bugs. So in general you don't want to have the word static unless it's static final, static final is very safe because you can't change the data inside it. But a normal static class variable is to be avoided unless it's absolutely critical. In general, the class itself wraps up, so encapsulates all the data and behavior of the details of the object. The object has an interface which is specified so that lots of components can be defined in parallel. So interface is a slightly different keyword than class in Java. Interface can define all the public methods, all the ways of accessing a class and then you can use that to define the interface to the class. Why is that useful? Because it means that now by defining all your interfaces first, people can start developing against those interfaces and then the details of them can be put in later on. So in general, objects will have multiple interfaces. So you can now put the object, hide the information inside the object and have multiple viewpoints in the way it's called. So you can ask why do we have this thing called classes? Why not just have the objects that have the state and behavior, the identity? Well, one thing that classes do is they make sure that there is type protection. So it makes sure that you don't try and take a piece of string information and copy it into an integer information. Okay, so they're used in the way that types are used in other languages. It's also a good way of designing your code because now you can design your code by a group of classes which share the same properties. So in the OO language like Java, the class type is used as other types are used and it protects you. It does stop you copying the wrong type of data into a different type of data. It makes sure that doesn't happen. Classes are slightly different than types in that a class doesn't just define what data is stored. It also defines strictly what an object understands. Okay, so it's a little bit more complex than that. So they're similar to one another and most of the time you're going to use them in the same way but they're slightly different. The other thing is that some objects and some classes can be used as a reusable component. Okay, so there is a suggestion in the past that you can take a class and automatically use it in another project. It is possible this but only if the object has been very well designed and decoupled from other objects in the design you've got. So if you have nice loose coupling, you can use them in other projects. Otherwise it's more difficult. So an example of something that would be an object that would be very usable as a component would be something like a string class. String class you can use in any project. It doesn't have any limits to what it can do. It's generally flexible. Any one of those utility classes from the JVM like date, etc. If you've designed your code well, you will be able to use your code as components in other projects. The other thing is that if you're trying to use a class structure in another project, there has to be, two things have to be the case. They have to be in a similar or the same programming language. Obviously you could translate from similar programming languages such as Java to C#. You could probably do quite quickly. That wouldn't be too difficult. But also there has to be a compatible architecture. In terms of, for example, if I'm in Java and then I call a class from the class library and then I try and bring that into a C# library, I would have to have a compatible library that was compatible with that Java library. You could put in a layered library in between. You could do a simulation of it. Some of them have similar architecture but it's unlikely they're going to be identical. Inheritance is taking an object and extending that to make a new object class. So it's taking the attributes and operations of a class and then making a new one. Okay, so why is that useful? Because it means that you can reuse the functionality of the class into the subclass and then add in some more things to it. So it means you can take a whole load of classes and by extending them add the functionality without changing the functionality of the base class. That's useful because you've already written the base class. You've tested the base class. The base class works. It's a working piece of code. You don't want to have to change any of it. So inheritance allows you to add to it but without changing. So the subclass is a specialised version of the super class. But you have to be wary about how you do it. So it includes all the attributes and operations of the super class but plus some extra ones. It includes the attributes of the super class even if they're private, even if the subclass can't get access to them. They're still contained within instances of the object. You just have to get access to them by the getters and setters and whatever. So all the code and everything is there even if it's not accessible due to privacy or due to scoping parameters but it is still there. So if we look at objects and inheritance you can think I could start off with a class called person. I could inherit from nurse that would include all the attributes and the things of person. I could inherit from person. I could inherit of a class called doctor, one called surgeon, one called family doctor, etc. like here. In this example I've got vehicle and then I've inherited that. I've got land vehicle, water vehicle but then I've used multiple inheritance to create an amphibious vehicle. Multiple inheritance is available in C++ but is not available in Java. Multiple inheritance is somewhat confusing because if these two have the same attribute that's added and then you refer to it here, you have to distinguish between which one you're inheriting from. It can get really horrible. I'm personally not a big fan of multiple inheritance. I find it somewhat confusing and can be poorly used but it's quite a bad design. So the Java single inheritance model is somewhat more structured. In general it's very important when you do that you don't just use it to access methods of the superclass. So the subclass needs to inherit all the superclass and if you're using inheritance in a way that doesn't seem right it's generally better to use composition. The object class is also coupled to its superclass. That means if you break the code in the superclass you will break, you could well break the code in the subclass. So the two are coupled together. So because of that coupling sometimes people prefer to use composition which has a looser degree of coupling. There is a term called polymorphism which talks about how things can change their shape. Poly means many, morph means shape. In this if you have a type, if you have a subclass, for example if B is a subclass of A then anything that expects a variable of type A will also be able to take anything of type B. The reason being is that B has everything that A has so you can put it anything A. The other way around is not true. If B is a subclass of type A you can't get a variable of type A and just put it where type B is. So that thing where you take a type B, B is a subclass of A and put it into type A is called upcasting and upcasting is automatic, it's an automatic process. Why is it useful? Because it allows you to reduce code duplication. It means that your code can be a lot more sensible and easier to structure. Dynamic binding, this is where it's deciding which method to call depending on how things have been, which is the actual object of the thing at runtime. So if I look at this, C is a subclass of B, so I've got B equals a new C. We're allowed to do this because this is called upcasting. Now the type of temp, the type of this variable is of type B, but the type of this object is of type C. There's a distinction here between the type of the variable, what the variable is in terms of the compiler, the compiler sees the variable of type B, but the object in memory is of type C. So when it goes temp.println, if there's a method called printname which is defined in class C, it will call that method. That means that it's not looking at this type when it calls temp.println, it's not looking at this type B, it's not looking at the type of the variable, it's looking at the type of the variable it's pointing to, the object in memory. That process is called dynamic binding because it only knows which method to call when the code executes. It doesn't know which method it's going to call here until it actually looks at this type of this temp variable here. So this could be passed in, it could come from anywhere, it has to check and look up a dynamic binding table to do that. That's why languages such as Java use an interpreter because it can do this process of dynamic binding. So here we've got an interface called vehicle, it has this method called startEngine. I'm going to have two classes, one called car and one called boat. I go v=newCar and I go v.startEngine, that will call this method here. Then I go v=newBoat and I go v.startEngine, it will call this method here. Notice different code is called on this line than this line even though the line is textually identical. So even though the line is textually identical, the runner of this looks at this type v in memory and sees which type it is. So that's a sort of true example of, so this code would be in here in this thing called top. So it's very important this dynamic binding, some people get a little bit confused about it. If you get confused just come back to this slide, it will make it fairly clear. There is a language which we're going to be going into quite a bit in Coursework 2 which is helping us to do our designing, visualising and do our requirements for our code. So you've already looked at a bit of that when you looked at use case diagrams. So UML is not a single notation, it's a number of different notations that have been brought together under one umbrella which allows you to define these aspects of your design. So it comes from other people's research and work in the past. So for example, Meir defined these pre and post conditions that you've looked at with your use case analysis. Harrell did the state charts which we looked at when we defined our, we did some finite state machines and state chart work. Responsibilities, they're part of working class, message numbering and singleton, all these used in class diagrams. Patterns, patterns we look at in software engineering 2 and more later on and these object life cycles, these are used in the notation for things like interaction diagrams. So it's a whole load of different research work that went together to go into UML. So the object, when we do UML for class diagrams, the object classes are rectangles and names at the top and then the attributes are in the middle and the methods are in the bottom. So it's just 1, 2, 3 blocks and then the relationships with them are lines linking them together. So here's an example of a class called library member which is allowed to borrow and return books. Notice these just have the names of the classes and the relationships. Here we have a member of staff which is a specialised library member and the member of staff are allowed to borrow and return journals but they're also allowed to borrow and return books because member of staff is inherited from library member. Notice copy is a copy of, so this is a copy of a book, so you can have one book which can have multiple copies in the library and then the journal. Notice there are things here to say that one copy of the book is allowed to be borrowed by nought or one library member, that makes sense and one copy of the journal, any copy of the journal can be borrowed by nought or member of staff. One member of staff can borrow zero or many journals. So all this tells you a lot about the relationships, tells you about the business rules of the system you're working on. So if you take the generalisation away, this looks very much like an entity relationship. The other thing you can use to help you do this design work is to use a case tool. So they help you to, they can use you to help you to do the modelling but also some of the complex ones will do things like code generation and analyse your design. So you have things that allow you to design your UML like Argo UML, you have ones that allow you to do analysis like rational rows, ones that allow you to work with query languages, helping you to develop SQL, data dictionaries, things that allow you to do code generation, things like oh, very useful here are things like the visual studio languages, they'll do that and things that allow you to translate from one language to another. So object OODesign is designing a component so they have this internal private state. The objects have a constructor as well as an inspection operation, so something to start it off, things like getters and setters. And they can be implemented in turn or by a group concurrently by using the same interface. You should use, ideally you want to use a programming language to define the object's interface because that way you get a formalised interface to it. To do that you should use the interface keyword in Java. If you're doing OODesign, hopefully you can use those objects on new projects and when the project changes it's going to be easier to change it. We've got this thing called UML which is going to help us do the notation for the different object models. So we're going to look at in the next lecture, it's the design workshop, so it's this hotel requirement. So have a look at that in preparation for next week's lecture. So this is a case study on doing some OODesign. So that's what we'll be doing for the next lecture. [ Background noise ]