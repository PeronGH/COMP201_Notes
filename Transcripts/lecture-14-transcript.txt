So, excuse me. Okay. More about software design. Okay, so today's session, gonna be looking at issues of design. And in fact, in particular, we're gonna be focusing on ideas like coupling and coherence. These are important concepts in software. Good software has loose coupling and strong coherence. We'll look about why they're important. There is a concept in OO development that's called solid. And the S in solid stands for single responsibility, saying that each class is meant to do a particular thing, a singular responsibility. That is very related to what we think of, which we will touch on today, which is that topic called coherence. So coherence and single responsibility are very much the same thing. So what your classes need to do is do something, not lots of different things, but one task very well. So we're gonna be thinking about how we create a software design, a coherence of the software solution, which satisfies these requirements. We're gonna actually think about what that means, not just in terms of that the software does what the requirements document says, but is the software good software in a broader sense, what that means in terms of software that's stable, less likely to give you errors and bugs, easy to modify, easy to reuse in another project, that's very important. So those concepts we're going to be introducing in this lecture and the next lecture as it falls. So a good system has to have the following properties, okay? So the first one says it has to be useful and usable. Yeah, obviously it should be fulfilling the requirements. It should be easy for the user to use. It should be usable in terms of an accessible interface that makes sense. Okay, it needs to be reliable. So it needs to work in different circumstances using different data. It needs to be able to work in environments where things go wrong. So for example, if it's software working on my phone, it shouldn't do anything bad if I lose connection to the network, okay? It shouldn't do anything bad if my battery goes flat. It should come back and there shouldn't be any errors or any problems with that. So it should be able to deal with the environment it's sat in, and that's really important. And if you think of software that's running like web software, it has to run under different browsers. So maybe a mobile browser, different versions of browsers. That can be quite a job to make it interoperable. That would also be a measure of reliability. Next one it has to be is flexible. That means if I need to modify it in six months time to do slightly different things, it shouldn't be really horrible and hard work. In fact, good software has comments in it to tell you how you would modify it to do different things. That's really good practice. So what you can do is you can put the to do comment and say to do this, you need to change this module, etc. That's really nice. So what you're showing is that the software isn't just what it is now, but what it could be. It's really useful. Needs to be affordable. You need to be able to develop it in such a way that it can be developed for a reasonable price. And it needs to be available. It needs to be there. So we're gonna think of how the modular design allows us to meet these goals. And we're gonna look at that in detail when we think of object oriented development, cuz object oriented development focuses on some of these goals which in the past have not really had enough focus. Particularly with things like flexibility and something that's associated with that which is called reusability. Modules or pieces of code or whatever have an interface. And an interface says how you call a piece of code. So the interface tells you what the name of the code is you're calling. It tells you what parameters you need to send it, what the types of those parameters are, and what it's gonna return back to you. And in Java, there is a keyword called interface that you can use just to declare the interfaces of your code. A good way of programming, because you wanna focus on the interface first, the top level first, is to write a set of interfaces. It's a good starting point. From those, you can develop your abstract classes, your classes. Or we start with some interface definitions. So the interface is what's called an abstraction of the module. What that means is it tells you what the module does and how you get access service, but it doesn't tell you how it does it. The interface can be written before the code is written. Okay, so it tells you what the code does. And if there's something that needs to be told, some assumption about the interface, it should be documented in that. So that means if there's something that you need to know about how you're calling this code or what this parameter means, put it on a comment line. And in fact, Java and Eclipse, in fact, Java in general has this rather nice thing where if you put slash star star and press enter in front of loads of different things like method and code, it will automatically format the comment in such a way that you can just fill in the values. And then you can use a tool called Javadoc, which will take all those comments and extract them and turn them into HTML and develop your website automatically. So there's a tool that will do that as long as you put the comments in. So that means that you can produce a whole load of code documentation without having to sit there writing code documentation in Word. You can just use Javadoc comments in your code and they can all be extracted automatically. And it produces this really nice, easy to click and browse documentation for your code automatically. Let's have a look at an example of an interface. This is a class definition written for C++. So this is a class called vector. And vectors, I guess, are sort of high school mathematics. That sort of level. Vectors can have multiple dimensions. They could be 2D or 3D, depending on number of coordinate systems. They can be 4D, 5D. If they get to those higher levels, they're called tensors sometimes, have a different name. But the thing about vectors is they have a public interface. So here I have definition of the constructor for a vector. It comes in, so that's the one thing that initializes it. It comes in with x, y, and z. And then there's the destructor for vector. Doesn't have any particular parameters for the destructor. Doesn't need any. And then it has two methods that do some processing on the vector. One is a dot product. A dot product takes two vectors. It does the scalar size of one times the cosine. I can't remember what it is. It's obviously easy enough to look it up. But the important thing here is that the dot product produces a scalar value. Notice it just returns a number, doesn't it? A dot product of a vector. Okay, so it's the scale of one in the other's direction, isn't it? A dot product. And then you've got a cross product. A cross product produces another vector. And that vector is perpendicular to the plane of the axis of the other two vectors that you cross product. So if the other two vectors are in that angle, the cross product comes out of the page. That's not very important. What's important here is we've got the interface of how to do them. We don't even have to know what they even mean. We can still use the class. So this class is usable, this code is usable, without knowing the mathematics and without knowing the internal operations of the class. We've also got set vector. So the note here about the interface definition is it tells you, it's the abstract view of the code. Tells you how to get the thing to do what you want it to do without having to know how it does it. Then there is a private interface. Notice you wouldn't be normally coding this unless you're actually changing the code inside vector. Okay, and it has a method called normalize. And normalize you can use for doing some of the previous operations or various operations. But that's not available to us, it's part of its private interface. Any class you develop will have both a public and a private interface. So any times you put the word public in front of a method, it suddenly becomes part of the public interface. You can control how people use your class by deciding what you leave on the public interface. So you don't want the public interface to be too long. You want it to be as succinct and simple as possible. You wanna keep the coherence of your class as tight as possible. And anything that is not meant to be part of the public interface should be kept private. So that's the takeaway from this. So do you know how to compute the cross product of two vectors? You don't need to know. That's the point of the abstraction. You don't need to know the maths and you don't need to know the code either or the maths, okay? So it's incidental that you know it. That information hiding is usually a feature of good software. So you've got these things, you use them, you grab it. It's a little black box, you know that it's doing it. So one example of that would be if I had a class for doing a Fourier transform. Fourier transforms are a horrible mess, involve you doing a numerical integration. I'm probably at high speed. That's gonna involve a lot of complex code. But you might know that it's useful for doing a Fourier transform to compress a signal, okay? So you might need to know that. That would be useful. Now we can choose to change the code for computing the cross product, make it faster or more numerically stable. So a cross product involves a vector multiplication. If you know how vector multiplications work, you'll notice they go up. As the vectors get bigger and bigger, they go up as an order of square of the size of the vector. They're gonna quickly get computationally take a lot of power. And evidently, you might want to optimize the code inside. For example, to use multiple CPUs, you might want to do it. So you could do one row in one CPU and another row in another CPU. And you could actually improve the performance of it by using some horrendous threading if you're using really big vectors. And a lot of physics, for example, a lot of physics complex calculations involve very large vectors, that's very common in physics. So you often want to optimize that code. So you might be, if you're asked to be a physics programmer, you're working for a physics company, they're doing a lot of quantum mechanics. You wouldn't have to know the physics, but you might have to know how to multiply two very big vectors. They don't know how it's happening inside, you're improving the code on your own. There are five principles that we want to be able to produce when we're doing our good design. The first of these is called a linguistical module unit. And you are pretty familiar with this if you've done any of your programming in Java and in Python. An example of a linguistic module unit in Java is a method, as is a class because a class, even though it contains multiple methods, is one sort of unit. It has a beginning and end. It's defined, it has constraints, and sits in Java in just one file, doesn't it? So you know where it begins and ends. You wanna have not too many interfaces to a given unit. Your interfaces don't wanna be too large. The size of the interface I'm talking about means the number of methods you call. Okay, so if you've got a class with 100 methods in, it might be a bit of an indicator, it might be a smell that there's a problem with that class. Your interfaces want to be explicit, they wanna be clearly defined what they do. So you shouldn't just have the word public in front of a method to say it's part of the public interface, it should be commented to say what it does. That's really, really critical. And any information stored within the class needs to be hidden properly. Okay, needs to be properly hidden. So, A programming language, any programming language or design language, needs to support this principle of a linguistical module unit. Okay, so you can think of lots of languages. Some languages support them more than others to a massive degree of difference. Okay, so Java has methods and classes. Java has a load of quite sophisticated keywords. It has private, it has protected, it has public. If you leave all of those off, you get package private, which is subtly different. It has keywords such as class and interface. You can make a class package private, and it's only accessible by classes in the same package. So it has a lot of subtle different ways of controlling the access and scope of variables. So Java is quite a powerful language in that sense, as are languages such as C#. C# is a nice language, very powerful. There are languages which are somewhat pretty horrible languages such as BASIC. That was one of the first languages I used, cuz it was just one of the first languages I had access to, it was just there. And that's really horrible. That has line numbers. You can go and jump to any arbitrary line in the code, okay, which is mad. It's absolutely ridiculous, cuz you don't know where you've come from. So when you're in a piece of code, you can hardly tell where you've come from. You know in Java, unless you're at the beginning of a method, you've always come from the line before, okay? So it's easy enough to trace back up. If something goes wrong in Java, cuz it has this nice JVM structure and has an interpreter, if it throws an exception, you can trace back. And you can also trace back who called who, cuz it stores all that information very explicitly. So having a good language and a good environment makes a massive difference to the quality of the design you can render out of it. It's like having a good written language. In English, you've got full stops and apostrophes and grammar. You've got all that thing to help you construct what you have. They're the little tools, aren't they? Okay, assembler, not so good, has basic modular units. C, better, but the scope again there, it doesn't have the same scoping like the private and public. C++, pretty powerful, that has pretty strong scoping things. But not as subtle and nice as Java. C++ has too many things in it that allow it to go very weird and wrong. So in C++, for example, you can overload an operator. So you can make the plus symbol in C++ do different things, which is a bit weird, it makes it confusing. It has multiple inheritance, which can be very confusing. So the next one is fewer interfaces. An interface is a communication channel between one module and another. So when I mean fewer interfaces, I mean each class doesn't have to talk to too many other classes. In theory, if I have n modules, there can be n times n-1 links. So if I have ten classes, in theory, I can have 10-9/2. I can have 45 possible links between those ten classes. In practice, you don't have that many, and in practice, you want as few as possible. So let's have a look at that, how that might look. There, on the left hand side, you can see a reasonable level of calling and call the architecture. Notice, this is class calling this class. This class is called by this class, and this class is called by this class. This class is called by this class. This is sort of a reasonable amount of intermeshing. This, on the right hand side, if everything calls everything else, what's the danger here on the right hand side? What do you think the possibility, what's it gonna do to the software in general? What about a failure in a module here on the right hand side? How far is the impact gonna go? >> Would it cause everything to- >> Causes everything to go. >> Wrong, doesn't it? Cuz everybody who calls it is now unhappy, and that's true the other way around, isn't it, any of the other ones. So, yeah, evidently, if you've got a mesh of 100 classes, and they're all dependent on the other one, then you've got a horribly unstable environment, haven't you? Also, if you modify this, and that requires a modifier to the one code change can go wrong, can't it? So, yeah, try and reduce the amount of coupling. There is one type of coupling which is very heavy in most environments, but that is acceptable. That is coupling with the baseline API. All your modules might use string, yeah? But that's acceptable, cuz string is part of the core API. It's been considered to be tried and tested, and very, very stable code. So evidently, there may be a few modules that you'd hub into, but this mesh is not so acceptable. So it's fine to have one class in the middle and they all use it, but it has to be something that's very tried and tested. So string or something like that's fine. But yes, you're right, it can create great instabilities in the code, and it also makes the code a lot less portable to new environments. It means if I take one of these classes and I wanna use it in another project, I have to take all the other classes with me. That's a pain, that's not so good. There is a structure called the facade structure that tries to reduce the amount of interfaces, but allows a group of classes to work closely between them. So you take a group of classes that are in a package. So let's say you've got this group of classes, and they're considered to be, it's important that they have a very intimate relationship. We've determined that that's the best and most efficient way to code them. But what we don't wanna do is we don't wanna interface to them, to the rest of the code, to have a very large interface. So what I do is I develop another class, which is the public interface, and all the calls go through that class. In Java, you can do this by, if all of these classes don't have the word public in front of them, they just have the word class, okay? And you put them in a package, and then in the same package, you have another class which has the keyword public in front of it. If you structure your code like that, then all the calls from the outside world have to go through this little interface, and you reduce the coupling with the main code. This would be acceptable if you're developing something like a payment library, or a library for handling shapes or something. You have a library for doing a specific thing, and you wanted those classes to work intimately together. Even so, this architecture here, I wouldn't expect that degree of, that's not nice. Anything looks like a mesh. There's something that smells bad about that, it's not good. The interfaces themselves need to use something called loose coupling. So this means how you communicate between two modules, how you send data between two modules, how you call it. So the interface of the module defines the features that you may rely on, and that defines how the rest of the code is permitted to use that interface. So an example where you would get that particularly wrong is if you put your attributes, your instance variables, you made them public. That would be horrible. It means that somebody could change the data inside them without that going through any degree of validation. So for example, if you had a string that was a postcode, you could just put any data in there. It wouldn't have to be a postcode. Whereas what you should do is you should have the string that was a postcode, then you should have a setter, and then in the setter, it checks if the thing is a valid postcode. And if it's not a valid postcode, it throws an exception. Every time you have a setter, you should consider having some degree of validation. It would depend what it is. Some things are easier to validate than others. So for example, a surname is very difficult to validate purely because nearly anything can be a surname now. I haven't seen many surnames with only one letter in, but a lot have only two letters in. And you're never sure, it depends on what country they're from, etc. It's very difficult to know whether it's a valid surname. Coupling is the relationship between two modules or system components. And loose coupling means if I change something in a component, it should not affect other components by too much. Tight coupling is to be avoided at all times if you can do. Okay, so there are some situations where it's hard to avoid because we wanna communicate, usually when I wanna communicate large amounts of data. But I don't wanna communicate, I wanna do it in an efficient manner, such as sending a pointer to a block of memory or something like that. And generally, the loose coupling is by putting the state, by putting the variable in an object and sending all communication via parameters of an argument. So here is a example of tight coupling. Here is some code here, here is some code here, here is some code here, and here is some code here, and here is some memory. Okay, so that memory might be some just public variables. It might be memory on, it might be data stored on a database table, okay? That's a classic example of tight coupling. If I save information into a database table and another piece of code loads that data up from the same table, they're immediately coupled together, and that is considered really tight coupling. That particular coupling, where you save and load from a table or from a file, is called stamp coupling. Stamp coupling is notorious for causing problems in computer systems. So what people will say is, well, our system went wrong, and you said, why did it go wrong? And they say, because your database, your entry on the database table was corrupted, that's a problem with stamp coupling. In fact, what you usually do to get around that is you make sure that each block of code accesses only one table in the database. So for example, if I have a database table called customer, that stores every single customer, I would have an associated classical customer, and that would be the only thing that would be allowed to load and save from customer. That's a very good idea, rather than have customer being updated by different modules, that's really poor. So try and make a one to one relationship, and that weakens that type of stamp coupling. Loose coupling, on the other hand, has separate modules which have their separate data inside. You automatically get a degree of loose coupling with OO. So if this is a instance, that's not just a class, but an instance of a class, and this is an instance of a class, and this is an instance of a class. Each of them can have separate attributes and data, and then they only access their local data. In general, OO systems are loosely coupled, but only if you use the right keywords. So you have to make sure all your attributes are private. So there isn't shared state as long as you make sure that you've made everything private, that's very important. The objects communicate using message passing. But the object is coupled to its super class. So if I go a class and then I do extends in Java and I make another class, now the code in the subclass has access to all the methods in the super class. And every time I make an instance of the subclass, I have access to all the methods in the super class. And if somebody breaks the code in the super class, that can break the code in the subclass. The other thing to note is because of overriding in Java, a subclass can also break a super class. It can change its behavior. There is a keyword which I will encourage you to find out about and use. We do talk about this more in software engineering too. We talk about this more. It's called final, okay? So it's not just keywords like final and not just for constants. You can use it for a method or a class to stop people overriding either the class or the methods within a class. Final is a useful keyword. Do use it as much as you can. It's a little bit like private. It creates safety in your code. So final is a really useful one. So it works well with private. The next thing we want is reusability. So if we wanna make software cheaply, we wanna be able to use modules from a previous project. So in the practice, people said, well, you've written similar software before. We just want something similar. Why do you keep starting from scratch every time and doing the coding differently? So the reason for that has been the way the coding was done, the type of techniques used. So there's been obstacles to that in the past. And the obstacles to that in the past were often economic, that people found it cheaper to write the code first time in such a way that it wasn't necessarily written in the perfect way to reuse in a new project. So if you write it the first time, obviously you have to write it better quality than just writing code that just fulfills the requirements. In general for OO, if you have more inheritance, you get more reusability. So do use inheritance, use inheritance inside. And then there's organization psychological reasons. People just didn't think about reusability cuz it wasn't just bad. It wasn't part of the educational framework of how it was done. So I will focus quite a bit on that. I do in this module plus in Software Engineering 2, we talk quite a bit about reusability. It's a really important concept. In general, the best design methods are often called step-wise refinement. So start off with a simple view of the thing and then add it in. So you start with a high level view of the method, what we're gonna do. And then break it down into a number of smaller problems. One way you can do this, for example, for a like an e-commerce website, is you do a framework of the website. So you rough up some web pages and something like Visual Studio. And then you click your way through and you determine as you're clicking the way through, you say, what will be required at this point when I've clicked this thing, what module's required? So if I'm doing something like create a new order, you think, well I now need order processing. And then you go click to payment, and you think, well, I now need payment processing. And you think of all the modules that you'll require for each of those steps. And then you break that step into sub-steps underneath, thinking of what the underlying thing. So that means start off with a UI view of the project. And then by taking the UI into deeper and deeper levels, you can think of what supports those things. So that means working out from the top to the bottom. If you're working with modules, you want to be able to explicitly see which module is communicating with which module. Now this is difficult. It's difficult for this reason. If I have a class A and it calls a class of class B. So for example, let's have a class and it has a string. It has a string in that, so I'm using string. You know, I'm using some string attributes. I can look in that class A and I can see it uses string. I can't look in string and see it's being used by class A. So it's easy enough to see the classes that are using other classes. You can just read that in the code. But it's not that, it's impossible in a way to see if a class is being used, okay? It has another class as its client, as they say. One way you can deal with this is to develop what's called a traceability matrix. So the traceability matrix says which class is calling what other class. So you have class A, B, C and you say that class A is called by these other classes. Class B is called by these other classes. The problem with the traceability matrix is you have to keep it up to date every time changes the code, somebody has to update this. So really what you want is something which dynamically looks at the code. You could write something which would actually run through the code and see, actually analyze it dynamically. That would be the ideal way of doing it. But it's important because it shows you if a module changes, what other modules will change. What I used to do in the past is if I had a class and I was changing the method in a class to change how it worked, I would change the name of that method to something really stupid. So I take the method name and then I just put some random characters on the end. And I would see where the compilation failed and I would then see all the other classes that were calling it. And I could then know which other ones to test. Okay, so that's one way around it. If you're changing a small piece of code in a big project, one way is to change the name of your methods to something random that you're gonna change back again afterwards. See where all the errors are and then list those classes as candidates for testing. That's one way of doing your traceability matrix, but just manually when you're coding up. The next principle is information hiding. How do we do for time? We're nearly done. Okay, so this says that everything about a module and what it does internally needs to be private to the module unless it's specifically declared. So the module has an interface, an external bit, which shows you how it works. But that is simplified, so it doesn't show you the detail inside of it. Okay, in Java, keep everything private. Even keep your methods private unless they're part of the public interface. Really, really important. Cohesion is how much component is one singular logical entity. In general, in OO, components either represent data or functionality. So a class would be, you'd have a class called person or patient or doctor. They're representing data, aren't they? Or you might have a class that's called printer handler, cuz it's handling the printers. Okay, so then it's doing a thing. So the name of the class is always a noun, but it can be a noun that represents data or a noun that represents some verb, some doing thing. So in general, in terms of cohesion, grouping stuff together, there are different levels of cohesion. So bits of components can randomly just be put together. That's to be avoided at all costs, cuz it's very weak. Components that serve a similar function, okay? So an example of that would be string length, okay? And then array length, okay? That's not good. Just saying because they both do length, you put that code together. That doesn't really make any sense, cuz it's gonna be a very different thing doing it for a string. Things that happen at the same time. Sometimes there's power on self-test when a system loads up. Sometimes they put those modules together. Again, that's a bit weak, because tomorrow you might do one of them at a different time, doesn't make any sense. If they operate on the same input or produce the same output, it's called communication cohesion, not ideal. If you put one input into the input of another one, that's called sequential cohesion, that again is quite weak. Functional cohesion, this means that they all do a singular function. I talked about that before. That was like with the classes where a class represents a person, stores all the data about a person. That's functional cohesion. And then object cohesion, that is the cohesion provided in a class where all the code in that class only talks, operates on the data within that class, means that the two are wrapped together, and that again is very strong. Those last two, functional cohesion and object cohesion, are the preferred cohesions for OO design. So generally, cohesion's not well defined. Usually, you can tell cohesion when it's not there, where something just looks. You can't say this does a particular thing. So if your class isn't a singular, when we look at our case study, the cohesion will be a lot easier. I'll show you how that comes from this noun identification technique. Now, cohesion and encapsulation, not quite the same thing, but they are related. Generally, strong encapsulation supports strong cohesion, but it doesn't have to. If you don't have good encapsulation, it's very hard to have good cohesion. Okay, that's for sure. But you can have good encapsulation, and the code cannot be cohesive. So think of a class that has a 2D point. We've got a little bit of time, it won't be long. So a class that stores a two dimensional point, and we have get and set methods. So Cartesian means x, y, or polar coordinates means that you have a radius and an angle, okay? So there's two ways of doing a 2D point. You can do them in 3D, you can have x, y, z. And then you can have two angles and a radius, whatever. How it stores it inside, we're not bothered. Okay, so the user of the class doesn't need to know how they're stored. One version of the, it could store them both independently. It could convert one to the other. It's up to it, isn't it? And in the Java class, the get and set methods will be public. The data will be private. All the internal conversion operations will be private. If the module has high cohesion, low coupling, and a well-defined interface, hopefully it may be able to be used in another module. But it depends on the context. So when we have the Ariane 5 space launcher, there was a failure of using a module from a previous situation. So you need to work out. So for any design, you have to work out what's the easiest way to have modules which you can move to other projects, reuse them, and then modify them in such a way that there is stability. So we need to have a system that's gonna produce all these things, useful and usable code. Reliable code by having low coupling because, now because the coupling's low when I change the code, hopefully it won't have a big impact on other code. Need to be flexible, so I need to be able to change this code without worrying. High cohesion, cuz I can use it in other projects. And affordable, I need to be reused these modules and available. So have a think about those. That's for you to think about in your own time. So we've looked at those definitions. We've looked about whether they're important. And we've thought about OO. So I'm gonna come to this again. Whenever you're doing your design, doing your code, doing your code work, you are.