[SIDE CONVERSATIONS] OK, quick announcement. Panopto, whatever it's called, is back online. So you should be able to view all the previous media via the link on Canvas. So just click on that. Today's session, we're looking at-- I'm going to cover the essentials of use case analysis. And use case analysis is what is tested in coursework 1.1. So we're going to be going through use case analysis. So remember, coursework 1.1 involves you to do some use case work. It also involves you to produce some verifiable non-functional requirements. And we covered that in the last lecture. The next lecture will be on-- is a case study. So there is a case study on Canvas. You just check before the next lecture. And you can see the case study material there. Have a quick look at that before the next lecture. So do a bit of preparing for that, because I'll be going through the answers in that context. But you may have some different answers. So you go and have a look at it first. Don't just arrive without looking at it, because it's useful to have done some work yourself. OK, so that's today's attendance code. And let's get on. OK, so the focus of today's lecture is on use case analysis. OK, so remember, we've considered that requirements can be functional, what the system should do, something like provide a login facility, provide for your security system to protect against fire, to provide a fire alarm service, to provide a configuration, a fire configuration menu. That would be a functional requirement. And then there are the non-functional requirements, how the functions are provided. So I've got an example here. The username must be longer than six characters. The software must be written in Java. If you're thinking of your security system, you could-- a non-functional requirement, for example, would be when the smoke detector detected smoke, there would be a minimum of two seconds before the fire alarm was triggered. OK, some timing characteristics, something like that. That would be an example of a non-functional requirement. The functional requirement would be every time it detected smoke, then the fire alarm would be triggered. So one is what actually happens, the other is a constraint. Use cases show you how the system is used from the perspective of the edge of the system on the outside. So when you break the word use case up, it consists of two parts, use, how you use the system, you as a user, or we may find that a use case relates to a non-human interactor of the system. But then the word case means an example, one particular use. So if I have a cash machine, one case of using a cash machine would be to withdraw some money. A different case will be to check my balance. Each of them are just separate cases. The thing to note about use cases, they are external to the system itself. They're not showing you what's happening. So you can't say there's a use case of loading a record off a database. That's not a use case because the user doesn't do that. The user interacts on the outside of the system. It also, the use cases, shows the system relative to all the different users of the system. So when we think of different users of the system, in use case analysis, we're going to call those actors. An actor is somebody who interacts with the system. In that respect, since we have given actors and their different examples, it's called a scenario-based technique because I have the scenario where I'm withdrawing cash. I have the scenario if I'm withdrawing cash and I use a stolen card, what does the machine do differently then? OK, so it identifies those interactions. When you've got a full system, you can add in a set of use cases. When you've got a full set of use cases, they should describe all the possible interactions with the system. So when you've finished your use case analysis for the security system, that should cover all the different possible interactions with the security system. Once we've done the use case, we can take a look at the sequence diagram, and that shows the internal operations of the system. So when I press a button, which class gets loaded up and then how that sends a message to another class and another class and another class. So the sequence diagram, the use case is showing what the system does. The sequence diagram is how it's doing it. That's an internal operation. So this top one, the use case is requirements. The use case diagram is software design. They're very different in that respect. The use case diagram itself shows entities called actors. And an actor is a user of the system. But the thing to know about actors is they can be human, but also they can be non-human. So if I have a system that is an e-commerce website, and I want to make a payment, and that payment is PayPal, my website server has to go and contact a PayPal server. I don't have the PayPal technology in my system. That's an external system. That PayPal service would be an actor of the system because you interact with it. So they don't always have to be human. They can be human or non-human. The example of a non-human actor for the security system would be a smoke detector because it has to interact with the system. You have to connect it to it. The use case itself is a task which the actor needs to perform with the help of the system. So each use case has to do something useful. So even though the useful and use case, they sound similar, they mean something a little bit different. Useful in terms of it's providing a benefit to the users of that system somehow or other. So those actors are anything the system can interact with. So here's a few examples just to get you going. So it can be human. You can have a customer. It's a fairly straightforward one. You could have a player of a game. You could have a driver of a car. If you had the software for a Tesla car, then the driver would be an actor, wouldn't they? And that's fairly-- an engineer who's fixing the car would be an actor because the engineer would use the software to determine what's wrong with the car. And they would log into the software and find out what's going on. In terms of non-human actors, a smoke detector or a sensor, a payment service, a geolocation service, a robotic arm, an email server, that could be an actor. That'd be a good actor, wouldn't it? A database would not be an actor because a database usually would be within the system walls itself. So you can tell what's an actor or what's not an actor by considering is it inside or outside the system. If it's inside the system, it's not an actor. If it's outside communicating with the system, that is an actor. The use cases are supported by something called a use case description, which tells you what the use case actually does. So here's an example of a use case. It says print receipt. A customer has paid for an item via a valid payment method. The tool should print a receipt indicating the current date and time, the price, the payment type, the member of staff who dealt with the sale. And then it's got an alternate case. So you have to not only put in the use case what happens when the use case is successful. You have to consider what happens if it's not successful, if there's some degree of failure. So if it's a login, what happens when you use the wrong user name or password? What happens if you use it wrong three times? Does it lock the system out? All that flow should be inside the details of the use case, some understanding of that. So here's some ways the things are represented. All the actors are represented by these funny little stick figures. So it's just how it is. That's what they look like. So even though that looks like a person, even if that's PayPal, it's still a little stick figure. That's just how you draw it. The use case itself is just described by an ellipse like this. And you can put a reference to the use case in there. So you could put UC1 to say it's use case one, UC2 to say it's use case two, et cetera. Then there's an arrow that joins the two to say this actor is a user, is a utilizer of this use case, interacts with that use case. And it's perfectly possible for a use case to have multiple actors. Because if I'm buying a book from an e-commerce website and I choose PayPal, then I would be an actor as a customer. And for the same use case, that also would involve a connection to PayPal as well. So a use case can have multiple actors acting within it. So to help you understand this, I've got a very, very brief case study of how you do an ATM machine. So I've put up some actors here. Notice in this example, I haven't got any non-human actors. All the actors are human for this example. So I've got a customer, bank staff, or an engineer who services the ATM. And then I've got some use cases. Withdraw cash, check balance, add cash to machine, check security video recording. Notice each one of those provides some useful function. One that would not be a suitable use case would be read the keypad. It doesn't mean anything. Because all of these different ones might read the keypad. Each of them might display something on the display. The use case has to do something useful. Has to have value. Has to have value. That's the good word, isn't it? So that's how you could draw those use cases on a use case diagram. So notice the actors sit outside the system. They're to the left. That's because they're not inside the system. This big rectangle, that is the system itself. And then within the rectangle are the services the system provides. So that's as good as it got. And here, the customer is able to view balance, withdraw cash, print statement. The bank staff can check the level of the cash stock. And they can download the video recording. They usually have video recorders in these to check for crimes near ATM machines. Because believe it or not, where people are taking cash out is a very easy place for theft and robbery to happen. So evidently, having a little camcorder there, that can gather evidence, it's really useful. And then the service engineer-- so the bank staff can download the video recording. And the service engineer is required to top up the cash. This is just a first cut. Obviously, there will be many, many, many-- in a real ATM machine, there will be many, many, many use cases, one after the other. So there may be over 100, 150. We don't know, because we've not done the analysis properly yet. But we'll see. We'll see. We'll see. We'll see. We'll see. We'll see. We'll see.