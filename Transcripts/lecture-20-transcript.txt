[BLANK_AUDIO] . >> Good morning, good morning everyone. I'll give you another minute to just wipe down the attendance card into your phone and then we'll begin. [BLANK_AUDIO] [SOUND] [BLANK_AUDIO] Okay, so today, that's 20, we're doing the essentials of class models. And so just the bare bones really. So again, like the last lecture especially, won't be that long, which is in the morning. So I suppose that's a benefit. So just to quickly start off this lecture, we've been talking a lot about known analysis. And you can see when you're looking at a statement that's been given to you by a company. You sometimes have to infer classes from what the actual noun in the statement said. So if the statement that you were given said, persons must be able to do this. You wouldn't call it persons, you would, one rule, no plurals. So just always make sure that, never use any plurals, never use any verbs. So if you saw this system must be able to encrypt something, don't use the verb as a class name. Don't use encryption either because it describes the process. So you're best off calling it, it's noun version encryptor or encryption helper. And just like you'd call it printer, not printing, or you wouldn't call a class print or prints either. So there are just a couple of things on naming classes. So no plurals, no verbs, no general process descriptors. Just use actual nouns for the thing that does the thing. Okay, so we will be studying class models today. We've had a little look at them over the past two lectures and maybe seen them a couple more beforehand. But class models are a part of UML and they are static models here. So they describe the elements of the system and their relationships between them. That's all they do. They describe just how the system should look and the responsibilities of each one. But they don't do what dynamic models do, which is describing the behavior of the system over time. So that was like that sequence diagram we looked at last time where they pass messages in between and you can see how everything should handle these messages as time goes on. And it's not the same as a use case model either because a use case model should just describe it from the user's point of view. The static model actually describes the system and their relationships as a whole for your point of view, the person who's going to be implementing this. So yeah, that's a little look into class models. So a very simple class model is, you can just have doctor up there. A class is shown in a class diagram as a rectangle given its name. So doctor up there is extremely simple. I don't even know if your program would be able to do anything, but see if you can. So two things that make a good class model is you want to achieve two things. The first one is just build it as quickly and cheaply as you can. And as you choose which objects and classes you want in your program, they should be able to execute every single requirement that you've been asked to implement. So, but bearing in mind you're trying to do it as quickly and as cheaply as possible. The next thing is you're trying to build it quickly and cheaply as possible, whilst also making sure that it's easier to implement in the future to make changes. And that's just ensuring that you can evolve your system. So you need to build it. You need to make, so yeah, the way you do that is you build a system with encapsulated modules with low coupling and high cohesion. So you need to be able to, need to make sure that every piece of behavior required of the system is within, can be executed by all the objects and classes you decide to use. And also make sure that all those classes and objects are encapsulated, that they are low coupled and have high cohesion. When you do that, you've got a cheap system which can be developed further with ease. So, yeah, a good class model consists of classes which represent things that will always be there in your domain. Things that aren't temporary, like you wouldn't call class Henry Forbes, cuz I might, I won't be in the system forever. As morbid as that sounds. But you would have a class person and you would instantiate a new person and you would call that person Henry Forbes. And that you should always, and that comes into the next thing if somebody else from somewhere else looks up and goes, what's this class? Henry Forbes? Why you, you'd be like, well, it's not very, that's not named very well. It would be better to just call that person. So you need to make sure that your classes represent things that will stay and always stay within your domain and also make sure that they're named well. And where possible, use a data dictionary to avoid any conflicts. So, just like we talked in the past two lectures and briefly at the start of the lecture, we use noun identification techniques to find potential classes given a problem. There are two ways to approach that noun, that noun identification technique. The first one is data driven design, where you identify all the classes based on what they need to know. And then you assign those responsibilities to those classes to ensure that the functionality is all there within your system. [BLANK_AUDIO] The next one is responsibility driven design, where instead of looking for all the data that is, instead of trying to create the classes just based on what data they need. Instead, you create the classes based on what they need to do. And then after that, assign attributes to the correct classes. So you have a choice of doing the data first and then adding what can this do. Or you can say, okay, what can this do? And then add the data that was required for those methods after. So there's two extreme techniques for doing that. The one with the hotel use case, the hotel case study that we did two lectures ago, that was data driven design. We haven't really done responsibility driven design. [BLANK_AUDIO] So we're coming in to the first relation that we're going to talk about in class models, which is associations. So, whereas the actual class object and its attributes and everything come from nouns. The relationship between two classes is derived from verbs. [BLANK_AUDIO] And this, yeah, so they express the relationship between two classes. [BLANK_AUDIO] So instances, yeah, so that's the important distinction. So there are instances of associations just as there are instances of classes. So an instance of a class is called an object. So I suppose I'm an object of class person. And instances of associations are called links in UML. So, four very complicated bullet points here. So for class A and B to be associated, an object of class A sends a message to an object of class B. So class A has some attributes and some objects within it that need to send a message to an object of class B. Or an object of class A creates an object of class B. An object of class A has an attribute whose values are objects of class B or collections of objects of class B. Or an object of class A receives a message with an object of class B, as an argument. So the easiest, you can combine all these into just saying, if some object of class A has to know about some object of class B. So if an instance of class A needs to know of an instance of class B, then they are associated. So for example, a doctor has a patient allocated to them. And then because that doctor needs to know about patients, so an instance of the doctor needs to know about an instance of a patient. Therefore, they will then be allocated. Another annotation which is used, and we've seen a lot, and I mentioned it last lecture, is multiplicity. And multiplicity is very fundamental when describing how the relations between your classes and your class models. Lost one, the same. But the reason they're important is because it allows you to know, okay, how many, in this case, how many patients does a doctor need allocated? And you can do that really easily just by saying, okay, so the patient always has one doctor, and the doctor has between one or infinite patients. As many patients as, I suppose, the doctor can allocate it. So doctor is associated by has allocated with just one or more than one patient. So you see, yeah, like I said, the one at the doctor end of the association. Alternatively, if you want to just make it more explicit, you can do one dot dot one, but yeah, just use one. And then on the other hand, yeah, on the other side, the multiplicity of the patient is one dot dot star because it means that the doctor can have one or as many patients, infinite patients. Who's a good doctor? So continuing an exact number, so just like doctor here one, you can just put an exact number. So if you have like human has two arms, you just say two. Arrange of numbers, so one dot dot, so they can have between one or ten in this case, or an unspecified number using star. So loosely you can think of that star again as an infinity sign. So that's multiplicity at the end of the day. It just specifies how many associations or how many links or how many instances of a class should a class, an instance of another class be able to handle. Sorry, so the attributes for class describe the data contained and yeah, you just see these are the attributes name and date of birth, both attributes, that's information that the class always stores. And then most important are the operations. So what the actual class should be able to do. So how will the objects of that class be able to interact with each other? So the patient can add an appointment, it can get its date of birth, or it can add a prescription. A signature of an operation is just the name of the function, its parameters it has within it that it needs to be able to execute that function. And the return type as well. So that's just known as signature. So all three of these here are signatures. So this is called the selector, the argument type, the argument name, and the return type. So the method called depends on where it appears in the hierarchy. So there was this notion that's taught about called dynamic binding. So the idea of dynamic binding is that the function that is executed when inheriting this is determined at runtime. So the vehicle is null and then you say v equals a new car. So this v.starengine could use the vehicle star engine, but instead it has this star engine down here. And so that is determined at runtime. And the same with v equals new boat. It will then use the star engine that is used from the boat class. So even though it was declared as a vehicle, because you're changing, because you've got other star engines in the subclasses, therefore it's dynamically bound these functions here. So it's determined at runtime rather than determined at compile time. What function are you going to use? So that's the difference between them. Generalization is a very important relationship, yeah. That means if class A is a generalization of class B, class B must conform to the interface of class A. So that means that every single attribute and operation of class A is then supported by class B. It looks a lot like inheritance, but there is a difference between the two, although very, very minor. So this means that cat and dog are generalizations of class Animal. So they have access to Animal's attribute and its method. So it has age and getAge. So an object of a specialized class can be substituted for an object of a more generalized class. So Animal being the generalized class, and then this being the more specialized class. So it can be substituted for an object of a more general class, which expects a member of the more general class, but not the other way around. So what we mean by this is you can declare Animal as a new Animal, and you give it its age, say, right, it's 12 years old. You can do the Animal.getAge, and that returns 12. That's how old it is. But this Animal can't do Meow, and it can't do Bark. So these two can't be done because the Animal does not contain those methods. However, you declare a new cat. Now, what can happen is you can do Animal.getAge, still fine because the cat has access to that age and the getAge operation, and the Cat can Meow as well, because the Cat has access to that Meow function. But it doesn't have access to that Bark function that is within the Dog. So it looks a lot like inheritance, which brings me onto this slide, inheritance versus generalization. Generalization is just the conceptual relationship, whereas inheritance is the implementation. So they're just two different words, basically, for the same thing. That's how I would view it. So it increases coupling of a system, and if you decide to change a subclass, that means you would have to recompile a subclass as well. Oh, is that... Oh, okay, yeah. Another way to check for good design, instead of any... as an alternative to a little sidetrack, you can use CRC cards, which is classes, responsibilities, and collaborations. It's not part of UML, but they do, they can add useful insights into how everything is connected. So you'll see all this in a sec, so I'll come back to this slide. But the responsibilities of this class describe at a high level. So you discuss what the responsibilities of a certain class are at that really high level. Difference to a class model is, when a class model you describe, it's you actually name the attributes, you give the signatures for functions, you know, the methods, you actually describe what they should be called, even though that can change, but this one is more, like I said, high level. So as you can see, you've got the class name here, so this is a library member. This is the library member's responsibilities. All it needs to do is maintain data about copies, and meet requests to borrow and return copies, and then it collaborates with copy. Copy maintains data about a particular book, and inform corresponding book when borrowed and returned, that collaborates with book, and then book maintains data about one book, and knows whether there are any borrowable copies. So the name of class is at the top, responsibilities on the left-hand side, and the collaborators on the right-hand side. So if you want good CRC cards to try and maintain, like, local coupling, you should have about one or two responsibilities, but never more than four, just to try and keep it as low as possible. Remember, this is high level, so we're not talking about one or two functions. We're talking about one or two responsibilities. You can have many functions that take care of those responsibilities. Too many collaborators can signify high coupling, so the first one, sorry, was low cohesion, so, you know, you're not abstracting your system enough, and then too many collaborators signify high coupling. So you want to avoid, like, the opposite, and that's why you should have few collaborators as possible, and then one or two responsibilities, but generally no more than four. So these classes do conform to our notion of good design. They're cohesion. They have high cohesion because they have few responsibilities, and they have low coupling because they don't interact with too many different collaborators. Library member can only collaborate with copy, and copy can only collaborate with book. This is probably a bad object class for a CRC, the reason being it has way too many responsibilities and even has responsibilities that could be the responsibilities of the collaborators. So spell check the document. That could be the dictionary. Print the document. That would be in the printer, maybe also the file I/O. Open a new document. Save the document. They're definitely the file I/O, and then email document could go in the networking API. So, yeah, that's how they could have been improved. You could move the responsibilities over to the collaborators, and then you can also try and make sure that you could maybe split the collaborators if you wanted, like, some file management class. You could put maybe printer, file I/O, maybe networking API in there if you wanted that part to deal with all the files, and then you could just have your word processor object interact with the dictionary, and its main responsibilities would be handle typing of the document and provide formatting options. So more about associations is that UML's strength is being expressive, being expressive just about how -- being expressive, yeah, like, trying to think, like, declarative in how we describe the language between classes, objects, relations, all these things we've been talking about. So, you know, you could -- it allows you to be a bit lower. That's it, yeah. It allows you to talk about your design at a lower level but also have it be quite expressive, even though you're describing and designing your solution on a lower level. So we're going to, over the next few lectures, look at all these other things, aggregation and composition, roles, navigatability, qualified association, derived association constraints, association classes, and then more about classes. I think there's a couple more lectures on class models. So these lectures' key points are class diagrams and static models as opposed to dynamic, how classes and their associations can be found, and multiplicity as well. Class attributes and operations, we talked about signatures, we did a little recap on dynamic binding, and that, you know, you just override -- you can override, like with the star engine, and you can override the subclasses methods for executing that function. And then we had a quick look at CRC cards as well. This is a quick one. Again, thank you very much, and I'll see you next week or tomorrow if you're in the labs.