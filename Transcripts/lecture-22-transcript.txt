[SIDE CONVERSATION] Good afternoon, everyone. I'll just give you like 30 seconds just to work in the attendance code, which is just there. [SIDE CONVERSATION] OK, so what's the last-- you do that. Today, we're going to start talking about interaction diagrams. So we've seen this class models, class diagrams, and use case diagrams, which give like a static view of what the system should do and what it should look like. But now we're going to actually look at interaction. So how does the system change over time? How should it act in like given time? So this is the outline for the lecture. So we're just going to do a quick recap of use cases for the assignment. And also, they'll recap on class diagrams. And then we're going to look at collaborations and interaction and collaboration diagrams. Sequence diagrams. And then finally, some say activity diagrams. So we've seen use case diagrams a lot. I think this was put in to remind some people about the assignment. So they show the interactions of users and the system with the functionality of the system. So a use case is a functional component. So what should a specific task do? And an actor is somebody or something with a role within that system. So an actor must do a specific task. And that's how use case diagrams work. And they're, like it says here, used very early in the development and the design, the whole development process, rather, to kind of map out the functionality of your program. So one thing that you should remember about use case diagrams is that they show the functionality of the system, but not the sequence of events. So the events that take place inside the system, they should more or less go inside the event flow. So the sequence of events or alternate courses of action should just go in the event flow. The use case, a use case diagram just shows how the functionality works. So a seller can place an order, can validate a customer, and it can track an order. Now, to place an order, the seller probably has to validate the customer. But there isn't a line between these two that says, place order, include, validate customer. There isn't a need for that. Because the use case description for the place order will describe or should describe in the event flow that the customer has already been validated. They're two separate things that can happen within the system, but they're not linked. So it should just show the functionality of the system, as opposed to the sequence of events in a system. The sequence of events, the sequence of events that you're going to see in the system, the sequence of events in a system, the sequence of events can go inside the use case. And that's how a use case, that's how you can make sure that your use case diagrams aren't too complex. When we're describing use cases, we need to use natural language. We can also use structured language, but nothing too specific. So you can use some very basic pseudocode, if you want, in your use case descriptions. I would try and avoid using state diagrams. And most importantly, above all, try and include just natural language in your use case description. If you use an extend relation, you should also describe which of the use cases will be chosen. So you have that extensions inside each use case description. You need to say what use case you are extended. So what use case does the original use case extend? You should describe that. Now, the include and extend, I wouldn't say an advanced feature. I would say that they're not always necessary. They can really-- if you use them too often, you're going to add a lot of complexity to your use case diagrams. So try and avoid them where you can. And instead, if one of your use cases does include another use case, just try and see if you can just put it in the original use cases event flow. So the recap of the use cases being it should describe the functionality of the program, but not the sequence of events of the program. The sequence of events can go inside the event flow. It is really high level, and it doesn't need to be-- use case diagram doesn't have to be overly complex. It just needs to show the basic actions, or the necessary actions that each actor can perform. Now, recap of class diagrams. They show the static structure of the system. Now, this includes, as it says there, classes, interfaces, and any data types that you define. We show how each class has a relationship or an association between each other, and that we denote that with multiplicity. So we can show if it's one to one relation, one to many relation, or zero to many relation. So there's an example. We've seen it all the time. And then we also talked about inheritance or generalization. Aggregation, so if something is part of something but can exist outside of that something, so the class uses another class, and that other class is part of this class, this other class can exist on its own. And then composition, where the class strongly owns another class, and without the original class, this class over here would not exist. Attributes, we include in class diagrams as well as their methods and their return types. Visibility, when we talk about this, whether it's public, protected, or private, so plus for public, hash for protected, and minus for private. And class diagrams do provide a vital role in going from your design to your implementation. There is enough detail there, if you do everything correctly, to know what data types you need, what methods they all need to perform. And then realistically, it shouldn't be too difficult to move to implement something that you've designed with a class model, because a class model should have that high level but formal language there that helps describe how everything should work when you're programming. So like everything we just talked about, the student and professor, they both extend this person class. So they both inherit this person class. So a student is a person, a professor is a person. The student takes a course or a course offering. And a professor teaches the course, and the course is taught by a professor. So there's one professor, but the professor might not take a course, but he can teach up to as many courses as they want. And the student, the course doesn't need a student, apparently. I think it should. And a student might not take any courses, but can take as many as they want, which again, I think they should take at least. So over the last couple lectures, we've seen really the two most important UML models, which are use case and class models, and use case diagrams and class diagrams. Diagrams of models means the same in this case, not all the time. And those two, the use case and the class diagram, are both static. They show how the system should look. But as I said earlier, interaction diagrams allow you to record in detail how different objects interact as time passes, and also to perform just how they interact to perform a task. So we're going to talk about collaborations now. There are two kinds of interaction diagram that UML provides. There are sequence diagrams, which we had a small look at a couple of lectures ago, I think, last week. And collaboration diagrams. So we're going to look at collaboration diagrams now. So the collection of objects that take part in a single task, a single function of your program is called a collaboration. And these consist of the objects, so anything which-- any objects that you need for your system to work. Links, so the associations between-- well, they're shown like associations as class models. But we link them so we see which objects need to interact with the other objects to execute a task. Actors, just like a use case diagram. So this simple collaboration diagram, which shows no interaction. We don't have any interaction yet. But we show how this actor is linked to the library member. Our library member is linked to a copy of a book. And then we have the book there. Now these are all linked together, and this just shows how somebody can borrow a book from a library And this is our actor. These are our objects. And these are our links. So you include the class and the object name. So the object name and the actual instance of the class. Object name and class name. So now we've added interaction to the collaboration diagram. We can see how each label arrow represents how messages are sent between the actor and then all the different objects. So this book borrower here, he wants to borrow the copy. So a copy of a book, which would be this one over here. So that message is passed to the library member. The library member then checks with themselves whether that book is OK to borrow. Assuming it is OK to borrow, the library member then sends out this function here telling the copy that it should be borrowed. And then the copy goes, OK, this passes it to the book, and then the book is then borrowed. So that is how the messages are sent in this. So you send the messages just along and these little labeled arrows represent how a message is sent from an actor to different objects throughout your system. So this just describes what we call collaborations, which are the objects which interact to perform some tasks together with the links between them. Furthermore, the target object must understand the message. So there's no point sending a message to a target object that wouldn't know how to process that data. So you need to think about that. And the class of the object at the point of the arrow must provide the appropriate operation. So yeah, it'd be pointless to just point it at another object and that object not be able to execute the function. So we're back onto sequence diagrams now. They show the objects and the actors which take part in the collaboration at the top of the dash line. So sequence diagrams are different collaboration diagrams because they show how the messages are sent in real time. So they allow us to model real time, how does the system actually happen in real time. So you have the actor up here and then the objects over here. And then this dashed line represents-- so here's a better one. So this dashed line is just basic. We can say if an object has dashed line during this time, it's idle. It's not doing anything. But these actual solid bars show that something is going on during this part. So the object or actor is performing some operation in there. Now, just like the collaboration, this is doing the exact same thing as the collaboration, I should say. So the book borrower asked to borrow the copy of a book over here. So the book borrower asks the library member whether it's OK to borrow. So then the library member sends the message, OK to borrow to themselves. Assuming it is, then the library member sends this message out saying that, OK, let's allow the book member to borrow this book. Sorry, the book borrower to borrow this book. And that's sent to the copy. And then the copy sends out this to the actual book and says, this is borrowed. So exactly the same functionality as this. The only difference is this time is that you see-- now you've got time as one of your axes, I suppose. And then you can see how that changes through time. So yeah, this vertical dimension is time. And then the horizontal dimension is just your different objects that you have. And then, yeah, time seems to pass as you go further down the sequence diagram. And messages between objects are shown as solid line arrows. And their returns are shown as dashed line arrows, which-- maybe this one shows more clearly. OK. Hopefully there is one that shows the dashed line back. So as we've seen in the previous two, the library member, they send a message to themselves asking if the book is OK to be borrowed. So that's quite common in coding when you want to send an object to yourself. And that in Java is done as this. So this instance of the class should do something-- should send a message to itself. So in a collaboration diagram, you just show the link from the object, the self, and the messages pass along that link in the usual way. So just like this. And then with the sequence diagram, that is just an arrow to and from itself. So that's how you show a message being sent to itself. [SIDE CONVERSATION] So when you're doing messages from objects to yourself or to themself, every function invocation-- so every time you call a function, that is just an object sending a message. So even if it's calling a function to itself, that's sending a message. Even if you're calling your function from a different class, that is sending a message. If you do it too often, it's where interaction diagrams become quite cluttered. Not to say that your actual implementation is bad. Things need to call functions within their own classes a lot of the time. So this is just downside to the interaction diagram. So it doesn't mean bad implementation. It just means interaction diagrams aren't perfect like anything in life. [SIDE CONVERSATION] So you can omit those messages that you include with them sending objects to themselves, messages to themselves. And you can just consider it internal computation inside that object, which is just a type of abstraction. So you can imagine-- hmm. I can't think of an example. So the idea with design is that we want to do it on a high enough level so that it's easy to understand. But you also want to get enough information in there so that it's clear how the system should work or how the software should work. However, there's always that fine balance between the two. So it's sometimes a good idea to identify what things can be done in a subset of themselves. And that would be a sub-collaboration. So a collaboration is the collection of objects and links between them. Then a sub-collaboration is just a subset of that. So here we have complex collaboration to perform some function. All these objects need to take part in order for this function to be executed. And we can identify a sub-collaboration within that whole collaboration. And then we just replace that with a package instead. So instead of considering all these things that we can talk to with all these lines, we instead just draw three lines. And that's how you can simplify a collaboration to make it clearer what your code is trying to do. So the set of objects that you have available in your program, they're not always declared at the start of runtime. You're going to be creating objects and you're going to be deleting objects throughout your program. So you can do this in a collaboration diagram by adding these constraints, new and destroyed. And if the object is both created and destroyed in the same interaction, it can be labeled in transit. With the sequence diagram, you can put the box of the object. So before they were all at the top. But when it is created, you can just draw the actual object a bit further down than when time happens. And the destruction of an object is always shown by an activation ending with a logic. So I'll just show you. The collaboration diagram. So we do n equals get name. So I believe this is for a lecturer being promoted to director of studies. So we get the name, which we just called n. And so we get that lecturer's name. And then we say new director of studies. We pass the name that we just got from the lecturer. We have a brand new director of studies. And then we destroy the lecturer. The way it happens in a sequence diagram is we do just exactly the same thing. We do n equals get name. We say the new director of studies should be called n. So the lecturer, we get the lecturer name. We promote into director of studies. Sorry. And we can see that at the time of creating the director of studies, it doesn't start up here. So we don't have a director of studies yet. Then we create the director of studies. And the object appears at the time of creation. So yeah. And then when we destroy, we send just a normal message. But we cut off the dashed line at that point. And we use an x to describe that the lecturer is destroyed. So the advantage of sequence diagrams is clearly that they can show how the system interacts with each-- the software interacts with the passage of time. [INAUDIBLE] Now, we've only just really talked about the ordering of the messages being sent with our sequence diagrams. Sometimes the actual times that it takes to do something are important. And the system in which actual times are important is called the real time system. So this is how you include the time constraints on a system diagram. So from C to A-- so this is how long it should take the book borrower to get a book, apparently. So you have this point here, C. And you say, OK, this time that it takes for me to send out the message that I want to borrow the book and for this to return the message that I've been given a book, that should take less than five seconds, which is quite harsh for the library member. But remember how earlier I said, when we return-- when we return a message from another object in the sequence diagram, we use this dashed line here. So when we're sending out messages, we use a solid line, and we say what we want. And then when we return, we just do a dashed line. So same as before, the library member checks, OK, to borrow, and then we borrow the copy. And then we say here that the time it takes to borrow-- I don't know where this comma has come from, but the idea that we should-- the time it would take for this to be borrowed would need to be less than one second. So another diagram is an activity diagram, and they show how activities are coordinated. They're particularly useful when you know that an operation has to achieve a number of different things. And you also know the dependencies between two different objects or anything in your system, and you know what to do with them. Activity diagrams are very good at showing this. So when you're doing activity diagrams, you identify different use cases. But just like what use cases show, they just show the functionality of the system, not the order in which they must interact. So this is how you can turn them into something more useful by using activity diagrams as they show what use cases would have to happen first before another user comes in. Before another use case happens. The nice thing about activity diagrams as well is that they can show what two jobs can you do at the same time in parallel and what must occur sequentially. So they're state diagrams, basically. But they have extra notation. So these are the five elements of activity diagrams. An actual activity, transition, synchronization bar, a decision diamond, and then stop and start. Where does it actually start? So an activity is like a state. So what is actually going on right now? An activity edge or transition indicates where to move after that activity happens. And then synchronization bar describes how if two-- well, hopefully some-- no, it's not. OK, well then I'll just quickly explain. So there is a thick horizontal bar. If two activities have transition arrows and they enter a synchronization bar, then they must-- then one must wait for the other so that the next transition can go off. A decision diamond, just like a flow chart. So is this done, yes or no? Just go to either activity following that. And then stop and start markers, same in the state diagram. So where does it start? Where does it finish? So these are our stop and start markers. They're just black circles. But this one has another circle around it. This is our decision diagram. So if this book member is borrowing a book, they find a book on the shelf. Otherwise, if they're returning, they wait in the queue. And then they enter the synchronization bar here. This describes the responsibilities. So over here, this is all the member has to do. The member either just finds a book on the shelf or they wait in the queue. And then the librarian over here is the one doing all this complex stuff. So if the book is being returned, they enter this here where two jobs are spawned. They record the return and they put the book back on the shelf. As soon as that is done-- so both of these jobs need to be done because of the synchronization bar. Once both of those jobs are done, only then can the librarian prepare for the next member. Otherwise, if they're just borrowing a book, they just record that the book has been borrowed by the member. And then they prepare for the next item. And then the synchronization bar, again, at the bottom, can be used to say that the librarian must return back to the star and that this member can finish their activity in the activity diagram, the whole process. Notice-- so two things to notice about the synchronization bar. I think they're also called fork bars or fork nodes or whatever. Basically, you can use them to synchronize. So this queue, the librarian must be available. They must have finished all of this for the next member to either return or borrow a book. So that's how it's used in the synchronization in that both people must have finished that activity for that synchronization bar to be passed. This one here and this one here are used to describe that. You can fork two jobs off of this. So you can split off transitions from a synchronization bar, or you can join them in either way. If it's the first one where you're synchronizing, both jobs need to have been completed. And then with this one, you create two other jobs. So there's two differences between activity diagrams and state diagrams. Activity diagrams do not include events. So I'm not sure what that means. Activity is intended to proceed following the flow described by the diagram without getting stuck. Now, with state diagrams, it should be possible to get stuck and wait in a transition for an amount of time before it is available to move on. But activity diagram, you want to try and avoid that. And concurrent activities can be modeled by using synchronization bar notation. So just these two jobs split enough that the book needs to be recorded, that it's returned, and the book needs to be put back on the shelf. So you've seen collaboration diagrams and interactions on them. We've seen collaboration diagrams, sequence diagrams, and activity diagrams. We've seen that sequence diagrams can show how your system acts in real time. How you can use it to model real time. And how collaboration diagrams show the links between different actors and objects and all the links and messages that are sent between them. And activity diagrams, how they can show how the actual flow of your software can be synchronized, how you can separate jobs, and what use cases must be completed before other use cases. Thank you very much. I'll put the attendance code back on. [BANGING] [BANGING] [BEEPING] [BLANK_AUDIO]