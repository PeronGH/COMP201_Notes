[SIDE CONVERSATION] Good morning. Good morning. Today we're going to be finishing up off wrapping up Patrinet. And in the next lecture, we're going to be moving on to software design. So this is the last section when we're looking at requirements. So remember, in requirements, we've looked at use case analysis. We've looked at things like ethnography. We've discussed how we get information off people, how we structure it. And we spent quite a bit of time looking at modeling. And we looked at modeling because modeling allows us to formalize, structure our information in such a way that is unambiguous, that is clear. It makes it easier for us to describe a system. So when we looked at the traffic light by designing it as a Patrinet, we could ask certain questions about that design on whether it was safe, whether it was suitable. So whether it allowed two green lights at the same time, we could answer that question by analyzing the structure of what we had. And then we could use that as a basis for our coding because the Patrinet isn't dependent on any one computer language, could be developed in any computer language, but it's a formal description of what the code has to do in terms of behavior. And it's considerably simpler than actually looking at the code. So the same code that would have to simulate that Patrinet would look a lot more complex than the Patrinet itself. So I left you at the end of the last session with this question, with this exercise. So hopefully, maybe you've had a look at it. There were a number of questions I wanted to ask here. How many states are reachable in this Patrinet? Any idea how many possible internal states? Remember, the states is the placing of the token over the places that they're positioning. So any ideas, any thoughts? [SIDE CONVERSATION] Be brave, shout out. Anyone from the back? You could just shout out from behind your hand and everybody would know it's you. How many states are reachable? [SIDE CONVERSATION] Only five. So one, two, three. So what about in here, though, in this one? See here? When this goes round, it makes a new state that-- makes a new token there, doesn't it? Yeah. So if I go round once, I'll have how many in here? I'll have one in there, won't I? But if I go round again, I'll have two in there. If I go round again, I'll have three in there. If I go round again, I'll have four in there. If I go round again, I'll have five in there. If I go round again, I'll have six in there. Well, what are we getting to? It's a bit more than five. Keep going. It's in there. So when you think of-- it's not like-- so you could say there were a finite number of sort of states it is in terms of what's enabled and what's not enabled. But the actual states that are relevant is just this placing of the tokens over the places. So that's how you define states. So even though however many I have in this mailbox, the thing behaves the same way. That's not what we mean by states in petronets. So in another type of network, when we looked at the finite state machine, it's states was defined by these sort of places the state was defined where it jumped from one place to another. This is quite different. Statehood is defined all over the net. So it's like its state is described as spread all over it. Within a finite state machine, the state is either here or here or here. That's why it's a finite state machine. That's why it's got that F of finite. So they can be finite, but they can be infinite. Are there any deadlock states? [SIDE CONVERSATION] Not really. In this one, there isn't really any deadlock states. You could have a deadlock state. Let's not bother about that. There aren't any. That's good enough. And the next two questions I'm going to answer on the next slide. So here we've got the previous slide. And we can add in more readers and writers. Where do we add in more writers? Left or right hand side, so writers on here. So to add in a writer, just add in a little token there, because the tokens there represent the writers. So now we can have two messages that are worked on at the same time or read at the same time or very soon after one another. So this can very quickly going from beginning a message to two messages being sent. And the readers, just add them in on the right hand side. So we're moving, notice, from the pure idea of the PetriNet to just be interesting as a PetriNet to a PetriNet that's modeling a problem. That's the important thing. That's the important thing about last lecture and this lecture is we're moving from a theoretical thing to something we're using. We're using to solve a different task. The next one is how can we constrain the total number of nets that we are allowed in here. We want to constrain. We don't want them allow them to send an email if the mailbox has too many items in. So what we can do is we can add a place on here, which if it doesn't have anything in it-- so what I can do is I can put from this transition, connect to a new place, and then connect that back to the original transition for send mail. And here I can add in a couple of tokens. What difference does that make? It means this goes around here, goes around there, and one is put in here. But as it goes here, sends mail, one disappears from here. Then it goes around here again. It sends mail. Two will be here. And I can actually move those. I can show you them moving. Just move that one. OK, so I send one. One will disappear from here and end up in there. And then after sending the second mail, two will be in the mailbox. And notice nothing now will be in here. This will be disabled, can't proceed, until somebody receives a mail message. So you'll end up-- one gets generated into here. And I'll have to generate another one. One ends up down here again. So notice now, every time you send, one disappears from here and appears in there. So if this represents the number of messages in the mailbox before you've even downloaded them, what does this represent then here? Yeah, the amount of space, the amount of space left, the storage space left over. So you can see now, if I want to put a storage space with 100 messages, I just put 100 tokens in there. OK, and leave that one empty. And then we've got-- and notice, we've also changed it from an infinite state machine to a finite state machine. Because it only has a finite number of states now before it gets locked up, doesn't it? So we've changed from a standard-- the original petri net. So petri nets can be both finite state machines, as in the traffic light, or infinite state machines, like the earlier version of this until I put the constraint in. Evidently, if you want to have a system that you find it it's going to be easier to analyze. Putting in the constraints to make it a finite state machine petri net will help with that analysis, won't it? Because now you can say, well, I can draw them all and I can ask questions about it, and I know where I stand. If it's infinite, well, maybe it has some state that I don't like the look of anyway that I haven't seen yet. So at least you can see all these. It's quite useful. So that's a question that's worth asking as well. [TYPING] So we're going to have a few more examples. Some of them are a bit more artificial than others. So we can have one modeling the four seasons of the year. And we're going to have in this-- we're going to have a token to represent the current season. Funnily enough, it is currently autumn, so we've got it in the right place. And evidently, we can't move to summer until we're in spring, and we can't move to winter until we're in autumn. So the first constraint is doing that. It's a very simple model, but it was like the first question of the traffic lights. The first question is, let's get the sequence correct, and then we can see what other things we need to layer on top. So very much like a lot of these questions, they're sequential questions. They're tasks that have to be done in a given order, and then things that happen due to those tasks. So you could use a Petronet to model a process, such as software development, where you start off with the requirements analysis, then you move on to the design, and then you move on to the testing. The order of events could be controlled by a Petronet. And then we can add in extra bits to tell us what is significant about those different months. So here, as I move from autumn to winter, it's going to get cold and remain dark. Because evidently, as you can see at the moment, when you go home now after a long day at the university, it's getting quite dark, but it's still relatively warm. I mean, that's because we live in a temperate zone. The UK is not particularly harsh. If you go to the East Coast of the United States, it's probably getting seriously cold. The UK is about the same latitude as Canada, and that is getting pretty cold now. I think you'll find. The next thing we can ask is how to model things where it becomes a little bit large. We can do something called a high level Petronet. So the Petronet, if we use our current model and we do a very complex Petronet, it's going to be really hard for us to follow it. There's also, we're going to consider things like time. Remember with the traffic light, it was no use having that perfectly fair and safe traffic light if it just sat on red forever. That wasn't very useful, was it, as a traffic light. Even though in theory it could go through all the combinations, there was nothing pushing it on. So when we have the time in consideration, we will have a Petronet that we know will clock through at a given rate, and then we can ask time questions about it. So we can say, how long is the longest we'll wait at the traffic light for? OK, what's the shortest amount of time? What's the average amount of time? These are all questions. So to do this, we're going to add in something called color. We're going to add in something called time. And we're going to add in something called hierarchy. So here's a Petronet which has some of these extra characteristics. OK, so in this-- sorry, I'll just explain this. This is a Petronet explaining what happens when people arrive at hairdressers to have their hair cut. So in this case, this token here represents hairdressers ready to cut people's hair. This, these tokens sat in this place here. This represents the people waiting to have their hair cut. Evidently, if no hairdressers are available to have your hair cut, if there's nothing in here, you're going to have to wait until one's available. OK, one might be busy, but if they're not in this available state, they can't cut your hair. So this is the client waiting for their hair. And then when somebody starts to have their hair cut, this token will represent a hairdresser cutting a client's hair. So the two of them working together. Remember, in terms of what the tokens represent, they very often represent aggregation. So the two of them together, working together, that's represented by one token in this case. And then when it finishes, notice it splits up again. The hairdresser is regenerated here, and the client is regenerated here. We can obviously add in multiple hairdressers, sorry, by adding in more tokens here, easy enough to do. The hairdressers themselves can have attributes associated with them. So here we have a hairdresser, but you know that the name of the hairdresser is Harry. Harry's age is 28, so this is a series of just simple name value pairs, isn't it, yeah, name, age, and experience, two years experience. And that, in this case, is called color. OK, so color means the token itself, instead of representing any hairdresser, represents a particular hairdresser. And here for this, you've got this token represents Sally. Her age is 28. Her hair type is black. And when you add color, it means that you could have a complex simulation running, and then you could just make sure that when you're managing the simulation, you could look at a particular item in the simulation and find out information about it. You might be using a patrinette for a real world supply chain, and you could look at the three items in the supply chain that got stuck. You know, you could say, oh, well, this is for a given customer. This customer's ordered this product. I want to find out this customer's email. I'd click on the token. It would drop up the customer's name and contact details, and I could send them a message saying, your order's got stuck. OK? So you could actually add this to make the patrinette part of the user interface of the application. So not only is the patrinette used for simulation, you could use it as part of the UI. So now the transition also can have color as well. So I showed you the color for the tokens. We can add it to the transition itself. And notice when we add it to the transitions, it adds optional things which give you information about the transitions. So this helps you to spread the complexity over the network. Let's have a look at an example. Here we've got transition here. Notice I've labeled it plus. It says it produces an output, and the output is one. So you can see from the net that the output is just one token. But it tells you that the output token, the color in this example of the output token, is equal to the addition of the values of the color of the input tokens. So effectively, this is an additive. It's like an additive gate. Notice you can't add two numbers till you've got two numbers to add. OK, and that's very true. Because if you think of anything where you're designing a series of gates that connect together, there is a latency within that matrix of gates. And you can't get an output right at the far end of the gate until you've waited for the amount of time you need to wait for each gate to have a valid input. So here I've got to wait for these two for the plus operation to complete before a token is generated here. This one just negates it. So whatever comes in here-- so if 10 comes in here, minus 10 will come out here. 20 comes in there, minus 20. This one is slightly different in that this is very different. When this fires, it actually produces a token here or here. So notice this is a departure from a standard PetriNet thing. In a standard PetriNet, we would expect this to fire and it to produce a token here and here. But this doesn't do that. If a is greater than 0, a token is put here. Otherwise, then the token is put down here. And then this one is something which does the square root of a value. So if a is greater than 0, it produces a value on the output. So the important thing here is to note this won't produce an output unless this precondition is true. So all these layers adding on allow the PetriNet to do sort of complex things, like complex calculations. So I'll leave it again. This is another exercise. I think I should just leave them for you to do rather than just run through them. Add these together to use them as building blocks to make the square root of the modulus of a plus b. That means if a plus b gives you minus 9, the modulus of it will give you plus 9. And then the square root will be 3. Obviously, you can't do the square root of minus 9. Well, you can. It gives you 3i. But we're working in real numbers. So that won't allow that. It won't allow that. So it's limited in that sense. The next one I want to show you is an extension with time. A timed PetriNet has a couple of numbers, tmin and tmax. And with each transition, they are-- so with each transition, they're defined. So some of them use different notations. But we're going to just consider this tmin and tmax. tmin and tmax tell us the minimum amount of time transition will take to fire once enabled. It's a very important thing to note about this. As soon as it's enabled, the timer starts. The timer will carry on until it becomes disabled again, until it loses, until it's actually not enabled. So in this case, notice tmin is 0. And there are two tokens waiting here. And there's two tokens waiting here. Excuse me. Horrible. So when this fires-- so this will fire immediately, OK? Because tmin is 0. It must fire, because that's the minimum amount of time. In theory, it would fire twice immediately. But Petronets cannot do that. So it has to fire once at time 0, and then once a microscopic amount of time after 0 that is not 0, which is 0, isn't it? I mean, it's going to be-- it's the smallest amount of time that you can have after 0 time that is not 0 time, which is immediately afterwards. So after our time tick, this will have two tokens. And then this will be disabled. And the timer has to start again, OK? The timer will only start again when a token appears in this. Now these get in here. And after five seconds, this will fire. And it will fire twice, because it is immediately enabled. And the timer, remember, only gets reset after the thing gets disabled again. So after this fires, those two go off. And then evidently, the minimum amount of time for two of them to get finished is five seconds. After five seconds, one pops into here at time tick 5. And then this, because tmin is 0, you can see that it's going to fire immediately. And then after another five seconds, it will be finished. So after 10 seconds, it's finished all its firing. The other possibility is that it lasts three seconds before it fires. So the worst, slowest case is both these hairdressers hang around for three seconds. They're all three hours or three minutes. It doesn't have any units on this, so we're not sure. So they could last for three minutes. But they both have to start after three minutes. And then they both must finish after 10 minutes. After 13 minutes, the worst case is they're going to finish at 13 minutes. And then there will be another-- this now is enabled, because that finishes, one gets generated into there. After another three, we've got 16 minutes. And then that will finish at 10, which is 26 minutes. So notice, now we've got a petri net that you can ask questions about what are the worst and best times. You can start to do some analysis. You can add timing to your traffic light to enable it to have worst and best times. You can put constraints in it. It's useful. It's starting to become a useful model. So you can now ask questions about what's the minimum and maximum time. We've been through that to have the three people. Or what about end clients and end hairdressers? Is there a general formula for the required time? Does it make a difference? Depending, you know, if we have the same number of hairdressers to clients, I'll leave that for you to do. But it starts to get more complex. When it's more general, it gets harder. But it allows you at least to start to answer these questions. The next thing I'm going to add on is called hierarchy. And hierarchy is a complex structure where you can put in subnets into your petri net. So here we've got an example of a number of servers that are handling messages. This is when you're farming a message out to a number of handlers. Only one of them has to handle it. And there is some detail in here. Notice the subpetri net is modeled by having two boxes, two transitions, one inside the other. So the petri net itself in this context is represented by a transition. The edge of the subpetri net has to be a transition to allow a place to connect. On the other edge has to be another transition to allow the other place to connect. So this is the detail inside there. So we can then remove the hierarchy for all the depth of this whole petri net. So in H1, we can expand it. And then we've got a process here, which is the finish. So notice here we've expanded this to look inside this process. And then here we've expanded the end of this to have this beginning, pending, and end. So we're expanding all the different parts of the petri net. So we can look inside all the bits. So there was an example of sending messages where messages had to be triplicated. This is an example which is not clearly cut enough, which we're going to try and improve by applying petri nets. So here, instead of just sending a message down one channel, we'll send the message down three channels. And then depending, let's say channel one and channel two agree, we're going to accept their message. If channel three disagrees, we say there's an error. And then we accept the message from channel one and channel two. If all of them disagree, we say there's an error. We can't receive the message. If any two agree, we accept that. But if the other one's different, we say there's an error. If they all agree, we say we've received the message and there isn't an error. But it's a little bit ambiguous. What sort of message is it? If it's a binary message, just a one or a zero, you could say, well, hopefully we can just say, well, it's one-- if we get one, one, one, we know it's correct. If we get zero, zero, zero, we know it's correct. If we get zero, zero, one, we presume it's a zero and the one is in error. So you could say that it's binary. But it doesn't say here it's binary. It doesn't say it's a binary message. If it's not a binary message, what do we mean by it being correct? So we can do this as a PetriNet. So here we have the original message. And then we have a transition. And this transition splits the message into three parts. We then send this over a network. That's what this represents, sending it over a network. And here in these places, P1, P2, and P3, is the received message. Then we've got our voting. So P1 and P2 are analyzed in this voting procedure. If P1 and P2 agree, then this thing produces an output. If P1 and P3 agree, then these two produce an output. If P2 and P3 agree, then these two produce an output. Obviously, if they all agree, we just get three tokens. But they all have the same value. So that's fine. That's OK, because we can just read any one of the tokens. If we get any disagreement, we will only end up with a maximum of one token. Because if P3 disagrees, then only P2 and P1 will produce a token here. So we'll either get three tokens, one token, or no tokens. Because it's only possible for all three to agree, or for one of the pairs to agree to produce one token, or all of them not to agree, you'll get no tokens. So that's the important thing here. But it's a little bit confusing, because one token or three tokens, we've only had one message. How would that look different than getting three consecutive messages with the same value? It would look the same, wouldn't it? So it's not very clear. So to improve that, we can have a layer here called T-voting. And it has something in here which says what it's going to produce. If P1 or P2, or P2 or P3, or P1 or P3, it's going to produce a token. Otherwise, it's going to produce an error. So there's more examples of that in the book. So there is a book which shows you more of the examples. Important thing about the Petronet-- sorry, my voice is really bad today. It's not going to be better for a few days, but I'll do my best. OK, so it helps you to make the problem clearer to the programmer who's producing the problem. So I can make one Petronet model, and the programmer could use different programming languages to manifest it. And we can also do a simulation to make sure the model is behaving as we want it to. We can also move from an infinite model of a Petronet with infinite number of states to one with a finite number of states. We also added in the timing constraints so we could ask ourselves timing questions. So here's an example. Have a look at this. Imagine modeling an elevator system in a skyscraper. So we've got three elevators and 20 floors. How could we do that using that as a Petronet? So we could have people could be the tokens arriving to be moved in the carriage. The places could be the lifts themselves. Oh, thanks very much. The places can be the lifts themselves. And the transitions could be moving in and out of the lifts and also the lift moving from floor to floor. How are you going to do that? It's going to require some subnets, isn't it? Because you can imagine doing one floor, you want to extend it to 20 floors, you won't want to see all the finer detail. So have a think about how that can be done. So remember this particularly for the exam. They have the arcs, the places, transitions. They're non-deterministic. So they're useful for distributed systems because you can have things firing in different places. They have a clear semantics, so they're formal. So it's clear what they're going to do. And then the state is defined by where the tokens are spread about. So they don't have to be finite. They can be infinite state. And have a look at this. This has the elevator example in it. So that one by Mezi-- that's in the library. If you want to have a quick look at the answer to that, it's an interesting problem. It's actually a fairly complex problem. [ Silence ]