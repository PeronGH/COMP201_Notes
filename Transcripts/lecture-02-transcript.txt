[BLANK_AUDIO] Okay, the attendance code is there. I'll generally try and scribble it down on something and leave it here for future reference. If you come in late, I'll make a future session. So- >> [INAUDIBLE] >> Shh, shh, shh. Okay, just find a place just as quietly as you can. Okay, that's great. [BLANK_AUDIO] Okay, shh, shh, shh, shh, a bit quiet please. Okay, so today's session on software processes. The approach, the type of tasks you have to do and what order you do them. You repeat the tasks. Why do we do things in a particular order? We're gonna have a think about that. And we're gonna think about how that relates to other forms of engineering as well. So we're just gonna do a quick reflection on that. So start off with an example of building a house, okay? A building a house has certain similarities with building software. Apart from building a house is a lot, lot, lot, lot simpler than building software. Cuz it doesn't have as many complex elements inside it. But there's a degree of complexity. And when you build a house, you have to do things in a particular order. And if you do things in the wrong order, what you end up with is having to either redo them, go back and re-engineer something. Or you have to take a load of stuff and rip it out, remove it, and then put it back. And there are similar comparisons with building software. And we're gonna look at that. For us, building a house, I'd have a whole load of different tasks to achieve before I'd end up with a house. So the first question is, what am I gonna build? Okay, same thing with software. You've got to know what you're building. If you don't know exactly what you're building, you're gonna end up with something that may be quite a distance away from what you expected. Where to build it. In the context of building software, where to build means what operating system am I running under? What database am I using? What processor am I using if it's embedded software? How much memory I have? What if it's web-based software? Which browser am I targeting? Where to build is a question in software. It relates. It's the portability. It's what platform it sits in. That makes a lot of difference to what you can build and how you're gonna go about it. How much money you've got? Well, if you're building software or a house, you've gotta know what your budget is. You've got to decide what it's gonna cost you. You need to get the money. You need to have some funding of some sort. That might be in place already. Then you need to do some design, some detailed plans. And from that design, hopefully, you'll work out how long things are gonna take, okay? Before you reach the design stage for a complex software system, you're not really gonna work out how much it's gonna cost you. So you can think of how much money you have as a budget, but whether you're gonna be able, what you can do within that time, you have to answer that question without knowing how many classes you have, how much complexity you have, how many people you have to do. You're not gonna know how much it's gonna cost. There may be permissions associated with building a house. Certainly, you may need planning permission. But building software, you may need to use other people's software in your software. So there may be issues of getting, what are permissions called in software? I mean, you've probably heard of this. What are permissions to use or manipulate software called? Gainsworth-en-all, it's called a license, a license to use software. Okay, so whenever you buy some software, in fact, when you buy software, you don't buy the software, you don't have all the rights. You buy a license to the software, you have a right to use it. And the same with this. Start with the foundations. Very often when you're developing a lot of software systems, you have some foundations in place. You might have a class library, you might have something that you're gonna build it on. Generally, if you're working in Java, you've got the whole of Java JDK library. It's actually quite a massive foundation. So a lot of foundations are in place, but you're gonna have to work out how you're gonna build up from that. Then building up. And then fully test everything. If I'm testing a house, I have to work out whether it has to go, it has to be compliant with electrical safety, has to be compliant with building regulations, of course. Cuz otherwise they can come and ask you to knock your house back down. Don't quite get the same thing in software, but there are environments where you have to comply with certain external requirements in how you test software sometimes. So for example, if you write software for the British Health Service, there is a whole load of regulations on how that software has to be tested and what it has to comply with in terms of how it's done. And in fact, just having the right, getting yourself certified to build software for the National Health Service is quite a difficult thing in itself. And why is it such a great thing? Because they have a budget of billions and billions of pounds. And obviously if you write software for them and you have a good working company, you're minty. I mean, this is serious money, okay? So getting involved with serious customers, you have to be serious and you have to be able to test everything at that level. And then when it's all finished, you make sure it looks right. And whenever you write software, you gotta go and look at the stuff and you gotta make sure a customer is happy with your job. And if you're developing a game, it's gotta look and feel right, okay? So you can be spending all that time testing it and then it's something just not quite right. Showing it to the customer. And then you readjust it, you tweak it, you go through this process. If you look at that list, it's not really a list that's really about building. It's really about making loads of stuff, okay? So loads of stuff will require a very similar list. So does the previous list apply to software? A lot of it does, okay? And that kind of thing of having it, you know, making, doing things in a sensible order in some kind of sequence is a really important part of learning to be a proper software engineer. There is an order required when building a house. If you don't know what that is, that's called a partition wall or a dry wall. And you'll notice to put in the electrics, they have to drill through the battens, okay? And then they put in the cables, they put them through. And then somebody else has to fix on boards to that, and then it has to be skimmed. Everything has to be done in a certain way because if you forget to put some of the electrics in, and you shove all the boards up and then you batten them, you have to tear them out, it's really expensive. So evidently, there's a sense of task order. Very important that you get task order correct with software. One of the critical task orders you have to get with software is making sure you get enough of the requirements bang on correct before you start coding it up. Okay, it really saves you an awful lot of stress and upset. That doesn't mean the requirements will be perfect when you put them in place. It doesn't mean they will be complete when you first put them in place. But they will be your best go at it, okay? And the reason for that is that if you miss out some vital requirements, for example, such as use a very high scalability requirement, where you'd have to use a clustering database. It might make quite a difference to the architecture of how you put the stuff together. Might even make a difference to the language. So for example, Twitter, okay, was built using a language called Scaler, which is a highly scalable, it's a scalable language. It has a scalable API behind it. And once it was written in that, it was very relatively straightforward to keep scaling it up and scaling it up, okay, by using the correct language. The process, the life cycle consists of a process and that is a series of tasks that are done in a particular order. Okay, so for the previous example, you can't put up the drywall. You can't put up the petition without you putting in the wiring first. And for baking a cake, you've got to do things in the right order. You can't just throw, you can't just put the eggs in a tin and then cook them up. You'll just end up with a scrambled egg and whatever. So those series activities are processed. And the important thing for each process is what you're going to be doing and which order you're going to be doing them in. And why do we do it in that order? Because it's been found in the past that doing them in that correct order is effective. So the process has all the different things you're going to be doing, the tasks, the activities. So you say what the activities we're going to be executing. And for each process, there'll be resources, okay? So for example, if I'm doing the design of the software, well I need some requirements to go into that design. And then when I'm developing the software, hopefully there's some design being done because otherwise it's going to be difficult. So for example, to do the development of the software, let's say I had a 500 page spec, I had a requirements document all written up. And I had a team of 50 developers. It's going to be very difficult to work out which developers is going to do which bits of the spec without doing the design. Because when you do the design, you could break that spec into a number of classes. And then you can get the classes, each Java class and whatever, and go, this class, this class, and this class, this developer can do. Unless you've broken it up into that, just having it as requirements, one page of requirements is not going to be one developer's work. It just doesn't break down like that. Because the requirements don't list it down as software components. It lists it down as things it has to do. And some of those software components are implicit in the requirements. They're not actually, what it has to do with software is not written down exactly in the requirements, that's what it delivers at the front end. So each one can have a little sub-process and entry and exit points. And the important thing about those activities is there's some sense of sequence, what order you're going to carry them out in. There will be some constraints. It's common now to time box certain activities. Okay, so let's say you don't time box certain activities. What you can end up with is the time that you spend on things is too long, and what you end up with is not hitting the deadline of the project. While you're here at the, so in reality, most organizations, most deadlines tend to have a certain softness to them. Okay, so they're going to say, well, we're a month late, but it's still a well executed project and we're happy with what we've delivered. It's very common, of course. We know that and we know that even if something, depending on the quality of what's delivered and the cost and the extra time involved, that's common. Here at the university, your deadlines are fairly hard. They're not soft deadlines, and you really have to get things in time. So your constraints here and controls on the time that you spend on certain activities will be a lot sharper than they would be in reality. So what you learn here is to perform within very tight deadlines. So it's really good training, so it's a good starting point. So if we're building the house, we can think of each of the activities. So you think of these as being a process, an activity, so working on designing the house. And notice with these activities, some of them with designing the house, with the architect being the input, this part. You can imagine this process being fairly continuous. So you can imagine an architect working on three different houses. This doesn't have to be one house, this can be a whole new number of houses. With each of the house, the design comes out and then maybe get reviewed. When it goes to the planning permission stage, they might say, well, we don't want three floors, we want two floors, because you're overlooking other properties and it's causing problems with privacy. So we want you to bring that down and then you look at it again. So some idea of reviewing this goes in, and then we secure the funding. So that is it when we're looking at building a house. But building a software is gonna be a different set of activities. If you're building a product, okay, so that's any product, not just software. You think of the product as having something called a life cycle, okay? So when you first say it's a brand new product, it's got some requirements at the beginning, okay? And then you start to do some design work, and then you start to do some implementation of the code and testing. And at some stage, that product is hopefully released into the wild, and actually gets used by people for the real thing. So if you take a version of Windows operating system, a long time ago, there was a Windows operating system called Windows XP that was released. And that was designed, obviously, and developed, and then it was beta released, then it was sent out, and it had loads of bugs in it. And Microsoft, loads of people, mown to Microsoft, they fixed the bugs. And then it sort of gained a degree of what's called product maturity, where the product is of reasonable use and quality. And then as time went on, there was a decision that that product would actually not be supported by Microsoft. All that means is you can run it on your machine, but if there's something wrong with it, if you complain to Microsoft, they'll just go whatever, that's your problem. That end of support for any product in software is the end of its life cycle. Okay, so the software doesn't die, not unless it's like some sort of, it's got some virus in it that says I'm not gonna operate after this date or something, but any normal software does work, but it isn't supported. Why would that kill different versions of software? Have a think about that. If I had software that was web software, for example, and I didn't support the software, it could kill it. And the reason it could kill it is people re-release new versions of browsers, and your software might not work in a new browser. Might not work in a new environment. In fact, you have the same thing with games. People were complaining when people brought out, when Microsoft brought out new versions of Windows, that their computer game didn't work on Windows. Okay, the latest version, it went from XP to Windows 10. So you've got a sense of interoperability. If the software isn't supported, at some point it can die because it just can't work on the new platforms that everybody's using. So even though the software, in a sense, doesn't have a sort of inbuilt, it's not like a car, it's not gonna rust or destroy. It's certainly gonna become un-operational. At that point is the end of the software's life cycle, okay? Where it's just not of any use, okay? And if you had tax software and the tax rules change and it's not change and it's not any use, well, it comes to the end of its life. So the activities for software start off with the requirements analysis, moving on to the design, the user interface design, the detailed implementation, and then finally testing the software. But there is some other activities further on. The thing about software, and unlike other products, so for example, building bridges or televisions or cars, etc., is that when the software leaves the building, it's still something that can be changed. It is totally fluid and plastic at any one point. Okay, so it can be changed at any time. That is a good thing because then the software can be improved. If we have software for a tax system and the tax rules change, we just put in the new set of rules. But it has a number of implications in terms of how you design your software. If you design your software well, when those changes come in, you just go, we'll just upload a new set of tax rules. And they were nice formatted in XML or JSON or something like that. So you had a set of structured rules about how it worked. If you'd hardwired in a lot of those rules or those numbers or whatever, your software's really horrible and will creak and break every time these new requirements come in. So how you write your software, how flexible it is, is very important in terms of delivering your software. Not just it works for today, but it works for next year or the year after, etc. So this leads to a number of problems. Cuz the software can get more faults as people add in more codes. So the first time you coded it, it was done really well. It was like a really good team. And then people in your team changed and you got some people in a bit like, whatever, they were a bit slack or they didn't care or they hated you or whatever reason. And they just sort of, they did some modifications to the code. Maybe they weren't very well paid or something, they didn't care less or something, whatever. And you ended up with software that had faults in it. The cost is difficult to manage because you're not really sure how much the cost is of changing legacy code. This is very common. You'd have code that goes out there and then it would sit there in the real world in the wild for maybe ten years. And all the programmers who understood the code have all left. It's all written in some arcane language and then suddenly you've got to change it all. In fact, the software out there that's in banks and building status that uses assembler code. There's software out there that uses COBOL. If I even name things like COBOL, you probably sort of, you might have heard of it, but you wouldn't know what it is. It's a really horrible arcane language and when you looked at it, you'd be thinking, this is an absolute mess of code. So a lot of issues with software because the software worked, they sent it out. It didn't work out whether it looked any good or whether it's flexible or easy to change. So the first software model I want to quickly look at is the waterfall model. So in the waterfall model, which is, it's a very classical engineering model for lots of different systems. So bridge building, they'd use a waterfall model. And in this, every phase of doing the specification and development is in a separate and distinct phase. What I mean by that is that all the specifications done and then it's completed and then it's considered to be finished. Okay, absolutely finished. You can't go back and start tweaking stuff because when you start making the bridge and you're in the middle of halfway through three quarters of the way across building the bridge and somebody suddenly says, well, I'm sorry, I want to use a different metal. And you say, well, all the metals are there. Somebody spent six months welding that in. It's just cost us 20 million pounds to weld in all that metal and build it in. You can't go back and quickly fix it. Of course, with software, that's not the case. If somebody says, I've got to change these few things, it can be done. So it's used for those types. For software, we're more likely to use what's called evolutionary development. So in this, we do some of the specification, we do some of the development, but the specification is considered somewhat fluid till the product has reached at least the quality assurance stage. So you might do some specifications, some developments, some specifications, some development, and then you'll reach a point where you'll say, we've spent enough money developing this product, we'll freeze the specification, and we'll start thoroughly making sure everything works according to the requirements at that stage. So Agile and Scrum have more of an evolutionary approach, and those are the approaches most widely used in industry today. So skills and knowledge in Scrum, if you want a heads up about making yourself employable, skills in Scrum in particular are considered employability tech. It's good. You put it on your CV, you know about it. Okay, so the waterfall model starts the requirements. It then goes through the system and software design, implementation and unit testing, integration and maintenance. Notice, not until you get to the very end where you're maintaining the software, do you go back and do any of these processes again. So what that means is, is that every iteration, when the software's developed for one release, you go, I'm gonna do some of this, some of this, some of this, some of this, some of this. Then later on, let's say you're a year later and you decided you need some new things. Well, you go, we need to add some new features. We come back and we do the process again. One, two, three, four, like stepping through. You do not, when you're in the waterfall model, jump, notice, from here to here. You notice you're always jumping, falling down the waterfall. You can only go back up to the top when you've reached the end. That's the nature of it. So the problems with the waterfall model is it's very inflexible. When we're stuck in one part of the process, and the customer goes, I've just realized, there's a whole lot of features that we've got to add in. I just think it was a system for a medical system. And I've just realized that we need to, we've got a whole load of new COVID regulations because we've got this new disease called COVID. And we have to introduce new regulations about how people are vaccinated. And yeah, but they go, well, we're in the middle of our waterfall model. We can't go back until we finish testing. Just really doesn't make any sense. So as the customer requirements change, it's problematic. So for software, it's only appropriate when the final requirements are very well understood. There may be circumstances where the requirements are very, very well understood. So usually, it may be for something, for example, like a piece of firmware. If I was designing software for a DVD player, a DVD player has pretty strict requirements. You play, you rewind, you go backwards, forwards. It's probably got some menu or something to change the settings. But from one to the other to the other, it may be very, very stable. A lot of software systems are not gonna be like that. So more likely, in some embedded systems, you could get away with it. So it describes the waterfall model something called stepwise requirements. So very often working in hardware engineering, stepwise requirement, stepwise refinement means for this version of the piece of hardware for my television set, I'm 32 inches. And then the next release is gonna be 48 inches and has a different plasma and whatever, each one sort of moving forward. So the reality check for this is that no one in the software industry follows the waterfall model. Okay, so why did I bother even mentioning it? Well, those steps are really important, okay? But they're just not done in that strict way, okay? So it is important, the steps. And it's fairly easy to remember, and the sequence is important. So some things about the waterfall model are fine. Just this lock in, where you're locked into a step and you don't go back, that's the problem, okay? So what we have to do is we have to say, we're not locked into being exactly stuck on a step, we can go back. But the order is important. So before I can do something, before I can implement some code, that code should have a set of requirements, okay? The other reason why you wanna make sure you have your requirements correct is the testing is written from the requirements, okay? So if I have a load of use cases, for each of those use cases I'll have a series of tests and I can map one to the other. If I don't have those requirements and use cases, I really don't know what to test. So testing's really important for this. So the evolutionary approach rather than the waterfall approach starts off with initial implementation. Then we show it to the customer and then we improve on it step by step. So the other possibility is to do what's called exploratory development. And that is that you show the customer some type of quick knocked up prototype. So if you're working in visual languages like the Microsoft Visual Studio, you can very quickly mock up a user interface. It doesn't do anything, it's not very effective. But it's really effective at showing the customer what the thing's gonna look like. You can say, well, we're gonna have this menu, this menu, and this menu. And that exploratory development is to help the customer work out what they need. Before you then go to the requirements, then you do the requirements, and then you can do the evolutionary development afterwards. So we start off with evolutionary development with what's called an outline description. This could be fairly detailed. So that could be a 50 page spec, that original requirements. Then you go into a stage of doing some development. Once you've done some development, you show it to the customer. You produce an intermediate version, show it to the customer. The customer says, well, I don't like features one, two, three, four, five, and six, but I love seven, eight, nine, and ten. And you can drop one, and two and three, I think, could do with some tweaks. Then you do some more specification to say how it's gonna be changed. Okay, important you do the spec, do more development, then you do validation. The validation could be internal tests, so showing it to the customer. And each time you do one of those phases, you end up with another version of the code. And hopefully, you're stepping closer and closer to what the customer wants. So it's very important, this. You're moving from what is just a basic screen with a login to a completed product at the end of the day. Because the customer's seeing it all the time, it's very unlikely you're gonna be building something, hopefully, that the customer doesn't want, which is a danger in software development. So in this, we've got a bit less visibility of the process, cuz we don't know what all our requirements are beforehand. And it's also difficult to make sure that all our requirements that how long it's gonna take, for example. So time scheduling with this is difficult. Why is it difficult? Because we don't know how many times the customers kinda knock us back, do we? They might come up with some harebrained scheme at six months, yeah? So you're gonna have to have some cutoff points. You're gonna have to have some time boxing for these activities. So the reality check with all of this is that, yes, evolutionary development is used, but it's somewhat hybrid, okay? So an awful lot of the spec is written at the beginning. You don't just write two pages of spec. You write a lot of spec at the beginning with the customer. Then you work out what you're gonna develop in each of the evolutionary cycles. So you may say in phase one, we hope to develop these. Phase two, we develop these. Phase three, we develop. So we do some planning. And each of these go into what's called, in Scrum, it's called a sprint. And you do some of the development. And then you work along with the customer giving you feedback as you work. So the implementation that's used in the industry now is called agile development. So agile development, it has all the benefits of the evolutionary approach, but plus a number of extra things added in, okay? So we often use things like pair programming, where two programmers work together, one of them looks at the code while the other one codes and determines, gives them advice. You can see you get a better visibility of the code. The code's gonna be more understandable. Often they use test-driven development. So the tests for the code are written before the code. And the focus here is on the actual code development. The teams themselves are self-organized. That means as you come in in the morning as a coder, there is a whiteboard with a load of use cases on. And the whiteboard has post-it notes, stickers on. You take one off, and once it's off the board, then it's your task. And then you do some work on it. And if you haven't finished it, you put it back on the board. And tomorrow, if you are off on leave or you go on holiday, somebody else can take it off and complete it. The idea of code here is that the code can move around between the developers. Why is that good? Because it gives you broader code ownership. It means that more people understand how the system works. It's good. People who are good at a particular task will do that type of task. So with Scrum, the development is done in a series of increments. So it's very much like what I said before with the evolutionary development. You have different releases of the code. But they're broken into, each of the increments of the development is called a Scrum Sprint. So a sprint just means we all work together for two weeks, madly coding away, trying to produce another version of the code. Okay, and then you do a review, and then you see where you stand. You do some adjustments, and then you madly work again for another couple of weeks. That is how Scrum works. So each increment is gonna produce a new version of the code. The user requirements themselves, we're gonna talk about use cases in a bit, broken into a series of use cases. Each of those use cases is gonna be written on a card, or it's gonna be put in the system. You can stick it on a spreadsheet or whatever. But they're gonna be prioritized. Okay, and who's gonna do the prioritizing? The customer's gonna do the prioritizing. So you say, this is the most important thing. Why is that useful? Because it reduces something called inventory loss. Inventory loss is something where you get to the end of a project and you've run out of time. And then the customer goes, well, why didn't you do all the really important stuff I asked you to do? And you go, well, you didn't tell us which was the most important stuff. And there's a load of stuff you did that I wasn't that bothered about. And you coded that first, and you haven't got time to do all the core functions. It's very important to do things in a particular order. And in your development here, when you work on a project, prioritize your requirements so you can do them in the correct order. So you don't end up with inventory loss. That means you're coding up rubbish that you're not that bothered about, but you're missing out really important functions. So you do the development of an increment. And as you do that development for that increment, the requirements are frozen for that increment while you're doing the sprint. That means nothing can change for those two weeks while we're all coding away. That's fixed. Why is that good? Well, since you're doing this incremental approach, which includes Scrum, the customer can see the product changing and becoming more useful, more functional. If the product's getting more functional, then you're actually delivering something that the customer wants, which is good for the customer's morale, obviously makes them feel something's good. You're not just saying, well, we're working away at it. And then six months later, they go, yeah, but we've given you all this money. Where's our system? With this, you can show them after five weeks what their system's doing. After ten weeks, you can say, now it's doing this. You get that sense of progression. The early increments of the code help you to do the requirements for later on. So those early increments are what are called prototypes. They show you how the code works, and the customer gets an idea of how they're gonna change the requirements later on. Generally, if you use incremental development, the chance of the whole project doing that just is lower, okay, for total failure. And something that's very important, because it's coded first, it's gonna be tested more times. And it's tested more times because you do something called regression testing. Regression testing means if I do a login at week one, I'm gonna test that at week two, week three, week four, week five. I'm gonna keep testing it. Anything that breaks any of the early features later on is gonna be picked up because I'm testing it all the time. So in reality, nearly all software processes involve a degree of prototyping in terms of iterative building, and that enables you to keep a control on this thing and make sure you don't make the wrong product. Which process used depends on the context. That means what are we developing? So if I'm doing a nuclear power station, I'm gonna have a very formalized process because failure. You can't go, well, the first power station, that melted down, so I think we need to change the software. You can't really do it that way around, can you? You can't tweak it. You can't do it for an airplane. You say, well, the airplane crashed, so we should adjust the software. It's not gonna work that way around for that type of thing. So anything that's safety critical, you really have to get it correct in the first iteration. For some things where there is no sense of massive failure or cost in having some failure in terms of the testing process, it's a lot. It makes sense to do a degree of prototyping or iterative development. For example, web development for large websites, for large commercial environments, Scrum development is very commonly used. Because it's something where there's a high degree of user experience, isn't there, there's a complex user interface. You're gonna have to interact with people, with humans, to get it right. So there's a final question for today's lecture, okay. And I'll come back to you, I'll let you think about this rather than just sort of give you the answers. Cuz obviously thinking is what we're here for, hopefully, at the university. So you have a think about the specification, and I'll put by a long margin is the most critical phase of any software engineering project. So have a think about why I've put that up. Maybe you disagree, maybe you'll just say, well, I don't agree with that. I think it's some other phase. But anyway, have a think about why that might be the case or why it might not be the case before we go on to the next one. So we've looked at this software activities. These lecture key points are really for you to read up at a later stage rather than me to talk through. But anyway, we looked at spec design implementation. And we looked at this iterative development. So the takeaway from this is that you should be iterating nearly every process you do. So you've got group software projects next semester. You wanna be iterating everything. Your version of your spec wants to go V1, V2, V3, V4, V5. You wanna let things evolve as you move along. And that's really important, because then you'll end up with something good rather than the first idea you came up with. The first idea you come up with is never gonna be a perfect idea. It always needs a bit of work. Okay, so. [BLANK_AUDIO]