That's a good thing. It's recording. We are ready to go. Okay, good morning on this beautiful autumnal Thursday day. The season of peace and health and mellow fruitfulness, as John Keats would say. Okay, software processes. We started them last session. We'll finish, we'll wrap them up today. Not too much detail on this particular topic. As you'll notice, the subject is pretty big. So some topics get a little bit more coverage than others. We focus a lot on the requirements. We'll be looking at some case studies in a bit. Okay, but today we're just going to wrap up this thing about process. We're going to look at a little bit more detail about what's involved in the software process. So we're going to have a detailed look at requirements engineering and specs, the software design, programming, testing and debugging, and software evolution. What's required? Okay, so software spec. Very, very important. In fact, in the last lecture, I asked you to think about why the software requirements are so, so critical for any software project. Any thoughts about why the software requirements are so important? It's a very big lecture. I don't expect people to shout out. It's not very fair. You can if you like, but it's obviously a bit difficult. So, the software is written against the requirements. The requirements are wrong. The software is not going to be perfect, is it? There's going to be something up with it. If I just photocopy the requirements on some paper and leave out one page, that could be critical. And, in fact, this problem of requirements being wrong leading to other faults is often called defect amplification. And it's called that because one very small change in the requirements might make a very big significant change in the software. So, for example, if I had a page on the back of the requirements saying that this software, just one page on a 200 page document, and that page said, "This software must support as main language English, but it also must support Chinese, Vietnamese." Well, it's not Chinese. It's called Mandarin. It must support Vietnamese, must support French, German, Swedish, and, you know, a whole load of other languages. That was just one page at the back, okay? If that was left out, that one page, it would mean that that wouldn't be in the design. You wouldn't have designed all the UI design. Wouldn't take that into account. So, it would just be designed on the basis that it would be in English. It means when you coded it, there'd be a load of coding missing that did the internationalization of the languages so that you could just plug them in simply and easily. When you have to refactor the software to take that into account later on, if you add a thousand web pages, you might have to go through all those thousand web pages adding in the internationalization. It could take you weeks, and it could result in you losing a really big market of all those different countries that you hope to launch your product over because you suddenly realize you can't sell it because people don't want to buy it because it's not in their language. So, that could be a massive difference. That was just one page of a big spec. So, it's called defect amplification. A small fault in the spec leads to a bigger fault in the design, which leads to a greater fault in the product. And it's also, the specification is used as a basis for doing the testing. So, if it's not written carefully in the spec, it won't be tested properly. So, it's really important. This stage is critical. Generally, requirements break up into a number of steps, not all of them present in real world examples. So, there is initially a feasibility study at the beginning to see if it's worth doing the software. So, you're going to ask yourself, "Have we got the money? Is it something we want to spend time doing?" From that, you get a feasibility report and that says, "Yes or no, we're going to go ahead with the software." Then is the main requirements development, what's called the elicitation and analysis. That means that you're actually going to the customers, you might be talking to people, you're digging out from them the requirements, but you're not necessarily at that stage writing the document, that you would be producing a set of models. We do modeling in this module. It's an important part of our understanding. In fact, we're going to look at quite a bit of modeling in some detail. Then you have writing the requirements spec and you get all what are called the user and system requirements. We're going to break out what's different between user and system requirements. We're going to explain that in lectures. And then some final validation. You're going to get the requirements spec and you're going to send it back to the customer. They're going to say, "That's good, that's good, that's good. I don't like that, I don't like that." You're going to review it and you're going to go back and you're going to do the process a few times. You're going to iterate it and go through a few different versions. The software design and implementation is taking that spec and making it into code somehow or other. But it's more complex than that because you have to start off with, before you start implementing the code, a process of design. And why do you need to process the design before you start coding? Because code is written by more than one person. So I have to break that problem into lots of small problems. And if I have a team of ten people, I can give the first person one problem to do, second person another piece of code. And typically in an OO environment, that would be breaking it up into a number of different class definitions. And I would pass the class definitions to different people in the team and hopefully they'd work together to produce the code and integrate it together. There would also be designing the user interface. Well that's like, that's a visual problem, the user experience. Designing the database, how the website architecture is going to be, where do I click, where do I go, where do I click, where do I go. All that stuff, all that UX, that's a lot of work. There are people who just do UI/UX work, that's their job, to get a really nice interface that is a beautiful experience. Short clicking to get you there. Okay, maybe some communications, maybe some communications protocols written in with a finite state machine definition of how it's going to work. Then some coding, putting that into an executable program, typing the code in in C# or Java or Python, whatever your preferred thing is. And very often design and implementation may be interleaved together and sometimes for a lot of projects the design is done as the person codes. So they code a bit and they go, oh well I just need this class and they do a bit of this. So sometimes it's not done formally, that's the reality of life. There is a number of processes you can do depending on the size of the system. So for larger systems you need a step called architectural design which means breaking the system into subsystems. So I could have a system for doing the payment handling, I could have the system to do the marketing, I could have a system for doing order processing. So the order processing system would make a request from the payment handling system would say, well I want this order but I need to see if these credit card credentials are valid first before the order is put in the system ready for dispatch. And then just before dispatch usually you make a charge on the card and you actually take the payment. You don't take the payment immediately because you might not have the product to ship. That would be really unethical, it would be wrong. So these processes are complex between the different systems. So we're going to look at each of those. Then for each subsystem we want to specify what it does, what its interfaces are. So we want to define what the interface is and we want to know what it's going to do inside. So it's operational constraints and services provided. It might say my subsystem for payment handling has to deal with Google Pay, Apple Pay and Paypal of course. So you can see a whole load of different ones and something like Sage Pay, you just decide what you're going to plug into that, what you're going to enable it to do. Then deeper down you're designing the actual components. For OO development the components themselves are classes. Okay, so that's all that means, breaking it up into a number of classes. When you design that you have to design the interface of the class working out what methods it supports and what data it stores. Data structure design, well the two of these, component design and data structure design in OO are wrapped up into one process which is called OO analysis and design. And that's covered later on in the module in some detail. Data structure design also means getting your database right and depending on the type of database you've got, whether it's a relational database or whatever, that would be a bigger or smaller process. Very often when we work in OO we start off with our class diagram and then we use our class diagram to work out what database tables we've got. So we go look at our class diagram and it has a class called person, so we think oh well we'll have a table called person to store instances of that class. Every instance of that class is a row in this database of a person. And then I look at the attributes in class and I go well these attributes, these attributes, these attributes need storing on the database so I'll make them database fields. And there is software that will do that automatically for you, it's called object relational mapping software, things like Hibernate or N-Hibernate, the C# version, there's various ones. And they will automate some of that process of designing your database straight from your classes. You might want to design an algorithm, you might be working on that. You might not have to design any complex algorithms. If you're doing some AI you might want to work out how you're going to design your AI interface. You might be doing some image processing and for AI we're talking about training a model to understand images or to process them. That's what you'd be looking at doing, so there may be some work involved in that. So if I thought of a coffee drinks machine I could work out and think of what are the different subsystems for that. So I've got the thing that the graphical display that displays all the information to the customer. Something that deals with the cash handling, so that would be a card reader, wouldn't it, for like a proximity card reader. I would want something that handles coins, a coin handling mechanism. I would want a note handling mechanism. And then all the relevant interfacing to that. I would have a system for accounting to make sure that it knows how much coffee's gone in, how much cash went in. So the person who collects the money at the end of the day can't just put some of the money in their pocket. The system has to record the exact ins and outs so it knows where it stands. Something to handle all the different recipes so that you could get, today I can get a mocha, a skinny mocha with whatever, or a flat white whatever. And then later on the recipe handle would have to be able to add new recipes in. You'd have to be able to make that flexible. Something for handling the stock control so it computes that in three weeks time it's going to run out of certain products and it puts a pre-order back in and says an engineer has to visit me in three weeks. That's somewhat complex stock control because stock control, what it shouldn't do is you run out of coffee and the machine goes wrong and then it says, oh right, now it's time to fill me up with coffee and it spends two days just sat there not selling any coffee. What it's meant to do is it's meant to predict, it's meant to look forward and see that it might run out of coffee. And you can imagine stock control, the bigger your problem is, like a stock control in a factory where you're making a car, out of zillions of different bits, every single one of those lines needs a stock control and it's based on the forward time of the product where you're ordering from. So if something takes three weeks to start from order to get one, you're going to have to add that lead time onto the stock control algorithm. So it orders it in five weeks if it's going to run out in five weeks. So it has to look further forward in time. So it's complex and it's complex because a lot of stock control systems work on something called just in time, which means you don't want to store a lot of stock. Because that's expensive and pointless and also leaves you open to changes in currency, things like that. So this can be fairly complex stock control, it will involve quite a bit. So if we were doing the abstract specification for the cash handling, notice it's just describing what it does in basic terms. So the abstract specification says registers entry of new coins with updated balance, handles return of change, so wants to do it in such a way that it doesn't run out of change quickly, can be interfaced to a wide range of coin handling mechanisms. You could probably spec in that the names and the manufacturer of some of the ones you want to do, or you can say see appendix three and you would have them all listed out in the index, that might be even better. Interfaces with note acceptor hardware, lot mechanism. Notice this is incomplete. Maybe we should put also interfaces to these card handling mechanisms. So we can add a bit more to it. Very often the process is iterative, we go along. Then we need to design some methods. So the methods, sorry design methods, now we're going to be looking at how we're going to do that in terms of graphical models. So we're going to look at these types of models. These models describe the system, but they describe it in an abstract way. Okay, so we're going to say how the data flows in and out of the system. We're going to be looking at the relationships between our data in terms of a class diagram or a database diagram. A database diagram is called an entity relationship diagram and it's just pure data only. A class diagram, evidently because classes have both data and code, has to show the relationship between the classes and it also has to show the code that's supported in terms of the code interface. The structural model of things like the architectural model, the different parts of the system, and then an object model that shows the different instances of the class and how they relate to each other. The special thing about an object model is that shows the code running. It shows what happens when I log in, what happens when a new coin comes in. It shows an active view of the system. A lot of the other ones, they show a static view. They show I've got this database table, this database table. They have these relationships between them, so they're quite different. And then a state transition model showing the system with a series of internal states. The other thing that's important to be doing for the work is the programming and debugging. Okay, so you're taking that design and you're putting it into a program and then removing errors from that program. So, there's not a generic programming process. It usually involves people looking at the spec and working out what they're going to do and getting some sense of how they're going to test it. That's an important thing as you code it. So you have to think about that. In fact, modern programming techniques often expect you to write the test mechanisms first and then make the program to fit in with that test mechanism. Okay. There are good organizational standards to be followed. I do have a coding style document that I'll send out so you can actually have a look at a reasonable approach to getting your coding in a decent style. The programmers themselves are expected to do some program testing. And in fact, in a lot of environments such as Scrum or XP, they're expected to produce the program test before they actually write the code. Once you've done that testing and you find a fault, then you have to do some debugging. Notice there is not a one-to-one relationship between faults and bugs. You can have one bug that caused many different faults and you can have situations where you have many bugs, different bugs, some of them that don't cause faults because that code might be not called in a particular context. It's quite possible. So the bugs may emerge later on. Or you might have more than one bug that produces similar fault, which is really horrible because it means when you've debugged one, you think, "Oh, well, I haven't fixed it because the problem is still there." And you go back and you realize there's another bug that caused a fault that looked very much the same. Generally, to program well, you should do it iteratively. So you should write the smallest piece of code that does anything useful in a way. So usually the smallest piece of code that does anything useful has to do something like process a piece of input to produce a piece of output. It has to change the internal state of a class or it has to do some sort of processing. Then you work, you determine it works, you test it. So in fact, that piece of code has to be testable. And it's testable if it's associated with a method that has a return value or that changes the internal state. Obviously, if it's a void method, it doesn't return anything, does it? So in a way, you think, "Well, how can I test it?" Well, then it must cause some internal state. It must make something happen. Then you archive it. You put it in the source code control and then you add a bit more code and you test it and you archive it bit by bit by bit. So little steps. And why is that useful? Because you don't write 50 lines of code and then it all goes wrong and you go, "Which line amongst all those 50 lines I've just written is the bug in? It's really hard." Whereas if I'm writing a few lines, it's obviously easier. You've got full exposure. Generally, testing works up the different levels of the system itself in terms of the system design. So you start off with unit testing. In OO, that means testing a method of a class usually. Okay. Then we've got module testing. That's bringing a number of modules together. So this starts off with what's called component testing. As I move up, I've got a number of classes working together. So once I say one class, I've checked out all its methods. I have to have another class calling that class. And evidently, if it calls it incorrectly, like gets the arguments all the way around, that's a fault. So it's a relationship between the two classes. That's the difference between what you'd call unit testing and integration testing. Integration testing is when one class uses another class that you've developed. Okay. Unit testing is where the unit sits on its own in some way or other. Then once you've developed a whole subsystem, so you've done the payment system, you start putting some card numbers in. So you go, I'm going to use a good card number that's valid. That's good. Then I use one with an out-of-date date. Does it spit it out? I'll use one with a stolen card. Does it record it as stolen? I'll use one with an invalid card number. Does it determine that that's invalid and reject it? I'm going to use it with different card limits, et cetera. So I'm going to be working all through that. So the subsystem for the stock control, I'd work out different levels of stock and work out if it came up with the correct schedule for ordering. Then we've got, once we've integrated all the subsystems together, we do a set of system tests. For the coffee machine, that means something as simple as putting a coin in and making sure it produces some coffee. It's distinct from the acceptance test. That is where the customer says, I am happy with this product. It's a different sort of context in terms of what's happening. System testing, overall testing, but acceptance testing, the final user. So the unit testing, individual components, remember that means individual classes on their own. Module testing, groups of classes working together. Subsystem testing, so that means getting a load of modules together and seeing if they do what they're meant to do, something like the payment system. From that point, you've got a working subsystem. Then you integrate them together, testing the system as a whole. Notice it says testing of emergent properties. An example of emergent property would be response speed. How quickly does it respond? How quickly does it make a cup of coffee? That evidently you won't know until you make a cup of coffee, will you? You know, you have to actually do it with the machine. And then finally, acceptance testing, testing with the customer or the customer data, or for a game, beta testing, sending out to a load of gamers. Let's see if they like it. They may go, oh my God, why did you do that? Completely pointless. If you're mapping that to OO level, because it's quite important to think about how that works and in practice, the unit testing is individual classes and methods. The module testing is putting a number of classes together, integrating them. So that's done as you do the unit testing, obviously. Because I could have two classes working together and then I would test it by testing a method that integrates, that calls, makes an instance of the other class, so that would work together. And then subsystem testing, I'd check the card payment system worked. I'd check the SMS system worked. Typically, a subsystem on something like Java, that would be the code would be wrapped together in a jar file, but you might have an interface that's a web interface. So you might do a web interface to test it. You might test it against the web interface. If you're using something like a standard Windows package, there's something called a dynamic link library. So there's different ways that the package is wrapped up as a subsystem. And then system testing, evidently, that's the whole system. So you're working on the edge of the system. So next lecture, we're going to be looking at requirements in some detail. Okay, so this is a short session.