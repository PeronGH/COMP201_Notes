[SIDE CONVERSATION] OK. Good morning. In the last session-- the code's up there, by the way-- in the last session, we were briefly wrapping up this introduction to requirements engineering. In fact, spent quite a bit of time talking about security requirements. And the reason that, practically, a whole lecture has given way to that is they're very critical requirements. You should be thinking about them as you do things like your group software projects next semester. Keep that in mind. Also, in the last session, we talked about what the process is involved in requirements engineering. This production of a feasibility study and how we do the elicitation analysis also introduced the idea of ethnography, which allows you, remember, to study how people work without having them to explain how they work. So you just study them directly. And very important to work out which stakeholders you have. So Coursework 1.1, part of that is to identify different stakeholders. I always went through a case study in the lecture. Remember, the hotel system looked at different stakeholders and how they affect which requirements you have. So it's really useful to do it from that viewpoint that's really important. And the security also introduced you to that Cucumber-Gherkin system, which allows you to automatically generate the headings and templates for tests from data that's given in the requirements. But today's session, we're going to be focusing on system models. And in fact, system models is going to take up a bit of time over the next few lectures. And it's a way for us to describe the behavior or the structure of the systems we're working with. So when we do-- there's all sorts of ways we can model a system, from the way the data flows within it, from what processes are happening in it. We can-- shh, calm down. Quiet down for a second. We can look at concurrency in systems. So they are what are called abstract descriptions of the system. Abstract means they're a simplification of the system, but sums up some of its operational details. So they're not going to give you-- they're not going to tell you everything about the system, but the most important features. And we're going to see how and in what terms they're useful. So throughout this lecture, throughout this module, sorry, and as part of coursework two in particular, we ask you to do some system modeling. Ask you to show how the system works either externally, as part of requirements engineering, or internally. Model its internal behavior. We're going to show you some finite state machines and Petri nets to show you how you can use these in practical circumstances. In general, the user requirements are written in such a way that they can be understood by non-technical experts. And why do they have to be done by that? Because they use the requirements. Users have to understand them. If users can't understand what's going on, they're not very useful. But system requirements, which show you sometimes the detailed operational procedures within an organization-- maybe it's a factory, maybe it's an accounting company-- they show you a more technical view and a more formalized approach to the system. So they're useful to describe the system's behavior. And they're useful because they're going to hopefully give you an approach which is less ambiguous, that gives you a clear view. You can't see it one way or another. So whereas the user requirements, there may be different ways of interpreting. The system requirements should only be interpretable in one clear way, hopefully, by using something like a model. So the system modeling itself is going to help us to understand the functionality of the system we're going to produce. And the models can then be shown to the customers. And we can say to the customers, is this how it happens? And if they disagree, they can say, no, we do this process first. And we do this in a slightly different order. And these two activities can happen at the same time. This is a common thing, isn't it, where you say, well, we can do activities one, two, and three at the same time. The activity four has to follow after all they're done. So those flows of action can be shown within a system model. And the different models present the system from a different perspective. So we've already seen one example of a system model. That is your use case diagram. A use case diagram is a system model. Because it doesn't have all the details, but it shows you the use cases. And it shows you the actors who use the use cases. And then it shows some relationships between them. So in that way, a use case diagram is a system model and an external perspective system model. So sometimes they're called context diagrams. Because it shows the system running in a context, who it talks to, what's on the outside, what it does, and what everybody else does. The next type of model are behavioral models, behavioral perspective. So notice on a use case diagram, you can't see the steps inside the use case aren't shown on the diagram. It doesn't show how the use case behaves. That's done in the use case description. But a behavioral use case model would show behavior, perhaps as a series of steps with arrows between them, how you're going to show those relate together. And then you have structural diagrams showing you how the system is made up of different pieces. I've got a piece here that does the payment processing, piece here that does the order processing. So the structural perspective or the structural model is showing you how something's made up of other things. But it may show you the structural perspective of all the data. So if you did an entity relationship diagram, that would show you all the database tables that you store in the database and the relationships between them. So it's showing the structure of the data, not the structure of the system. So here's an example of a class diagram. And we do class diagrams later on. So I'm not going to go through all the notation on this diagram. But class diagrams have rectangles which represent classes. The name of the class comes at the top. And then we've got all the attributes of the class. If it's got hash here, it means it's a protected attribute. Each attribute has a name. And then it has a type. So these are all protected. Plus means it's public. These are methods, not attributes or operations. And then again, it has the signature of the method, including the return value. Notice the return value is on the right-hand side, not the left-hand side as in Java. It's just notation. So this notation we'll only cover later on. And it shows the relationship. A student extends a person. That means a student is a type of person. And then it's got relationship between the student and the course offering. There's an awful lot of detail in one diagram without actually explaining it. So if you just explain this in English, you go on for pages and pages saying it has this attribute and that attribute and these relationships. It's very quick. It's very quick to show you the view of the system. That's the point. But we do them later on. So we're not going to cover that detail today. So now we've got a thing that gives you a very quick view of an awful lot of information that hopefully is easier to understand than just reading loads and loads and loads of text. It's a bit quicker. They're not going to show you unnecessary detail for one view. So it's going to show you what the most vitally important aspects are. In that way, you can think of them as essentialists. They're going to show the essential detail, what you need to know. It has to maintain all the useful and important information. But it simplifies the system. So if I look at the previous diagram, person might have a lot more attributes. It might have a lot more methods. I've just shown the essential ones. I've shown the important ones. In fact, I could draw a diagram with just the classes on and none of the attributes, just showing you all the relationship between all the classes. And then later on, I'd have a diagram just showing you the details of the classes. So I could get a big view. If I had 50 classes on here, I wouldn't have any room to put all that fine detail in. I'd simplify it. I'd abstract it. The different models we're going to work on are going to show you a different approach to what we're going to view the system from in terms of the abstraction. Some of them will show you the data. Some of them will show you the processes. In general, system models do not model non-functional system requirements. They're focused on functional system requirements. So your non-functional system requirements have to be listed later on. And they don't tell you whether a given method's appropriate for a given problem. You can get a lot of documentation, and it can be hard to read. So you've got to decide. You've got to make a careful decision about which system model you're going to provide. Generally, the larger scale the system model, the more critical it is to produce it. So for example, if I just do an architectural model showing me the basic components of the system and how it fits together, that is generally very, very useful. As I move further down and I've got more and more class diagrams or more and more-- I get just more and more of these diagrams-- they become less relevant. The other thing to note is something like a class diagram, you can reverse engineer off the code anyway. So if the code has been well designed, you can produce a class diagram by pressing a button in Eclipse, and it will give you a class diagram. So you don't have to go just one way. You can go the other way. Sometimes there's too much detail. So it's a good idea to leave detail out if the model's getting very complex. There are these types of models. So you've got data processing models. This was a view that used to be taken in a lot of earlier development methodologies, such as Yorden and SSADM. The focus there was data was processed, and then it was sent to another process, and something happened again. And then the data flowed to another process again. Then you have compositional models, how the system's made up of different parts. So we've got a payment processing bit. We've got a marketing bit, et cetera. So the compositional model, when we think of the class diagram, showed me how the system's made up of different software components, how it's made up of different classes. The architectural model is a type of compositional model, but for the whole system. So it's showing you the different blocks of the whole system. And then the classification model, how entities have common characteristics. That's part of, again, part of class diagrams. They do classification models, because you have different classes, which are subclasses of other classes. There's classification. And then stimulus response models. When we look at finite state machines, we're going to use stimulus response models. Stimulus response models are very useful if you're designing a communications protocol. So anything where you're doing communications down a link, you can lose messages. You might be doing a cache, something where you have to repeat messages, something like that. Stimulus response models would be very useful. They're very useful for embedded systems, something like a washing machine. That would be a stimulus response model, because you press the buttons on the front, and then it would have the motor going faster, and then the heater, all those inputs and outputs. There'd be stimulus, and the system would respond. A microwave oven would be another way. You'd use that for a stimulus response model. You'd use for that type of thing. The context model shows you the boundaries of the system, the edge of the system. I showed you a context model when I did that hotel booking system. And I drew a red line around where the system was, and showed you the stuff outside and inside the system. Your use case diagram is a context model. So it shows you the boundaries of the system. So inside the context, inside the system, is the use cases. Outside the system are the actors which talk to the thing. That's a context model. So these concerns may affect where you put the actual system boundary. So I can decide whether my system is going to have the meal booking system, whether that's going to be included, depending on if the people who are running the restaurant have a computerized terminal so they can use it as well. Maybe they've got another system that they're quite happy with. So where you decide which bits you decide to computerize are very often dependent on what the organization's requirements are. So architectural model is all the system itself built up as different parts, and how other systems relate to it. So here's an architectural model for an ATM system. So in this, you can see that the ATM system is in the middle here, and these are other systems. So to actually get this ATM working, we need to be able to communicate to a system which monitors the maintenance of this, allows the ATM to say I've got a problem, logs a maintenance request. The maintenance system would then send a call off for an engineer. The engineer would come back, would log the call in the maintenance system, and then would go and fix the ATM. And in fact, the auto telesystem, you might have 200 of these connected to one maintenance system. And then the engineer will be looking up to see which ATMs needed maintenance. Then accounts databases of other systems, a security system to handle the card handling and the secure PIN numbers, et cetera. The process model shows you the thing broken up into a series of processes. In the process model, it is implied, it's implicit, that one thing completes before another process begins. So process models, if you did flow charts to say to work out what the order of events is in your code, that's really very similar to a process model, because it says this thing happens, then after some time we do this thing, then we might do these two processes. And then where they're finished, we move on to another one. So we're going to look at a process model as part of our UML notation later on. Data flow models show data flowing between processes and being transformed by those processes. So whereas a process model says we do this thing first, then we do this thing, then we do this thing, the data flow model shows a process and data comes in one side and comes out of the other side. So you might have multiple flows coming in, one flow going out. Whereas a process model implies that you're doing these things in sequence, the data flow model implies some concurrent processing, that it's all happening as we go along. So here's an example of a process model for procuring equipment. So I start off here. Notice the dot, dot, dot, dot, dot. This is the system boundary. So inside here is the system. Outside here is things people are doing just with pen and paper. They're just doing them with paper. So they would do a specify of the equipment, and then they would use the system to find a list of suppliers. Once they found the list of suppliers, they add it to the specification. And then they send it into the system, which checks the spec. The system then contacts the suppliers, gets the estimates, and then automatically chooses the supplier and places an order. And then finally, there is the delivery note, which is typed in. So let's say the equipment gets delivered. You type in the delivery note to the computer system. The computer system accepts that the equipment's been delivered. And then it's then checked that it's OK and installed, et cetera. So notice this implies one thing happens, then another thing happens, then another thing happens in sequence. So that's the system boundary. That's the edge of the system. Behavioral models show how the system behaves depending on various stimulus coming in. OK, so we've got ones that-- there's two main types of a behavioral system. I've got a clear example of the data processing model. We're going to look at an example of a coffee machine operating. So that will show you how the different bits of the coffee machine have data flowing in and out. The other one is a state machine model. And for that, I've got a case study of a microwave oven. So we're going to use that to describe how state machine models work. So you can use both of them together. So for my coffee machine, I could have a state machine model as well as a data processing model to do both of them, showing you how the system's behavior works in detail. Once that's done, I can use the machine model to do both of them in detail. Once that's done, somebody can think of coding it because I understand what it's meant to do. OK, it's really important. So an example of a data processing model is a data flow diagram. So in these, data flows in and out of the system and then in and out of processes. So it's very simple and intuitive. It's usually clearly by people who have complex systems working themselves. So if somebody works in a factory or somebody works where they have orders and they work with a production line, data flow diagrams are usually well understood by people in that context, even though they don't have any computer understanding. So here's one for order processing. This is a data flow model. So I've got order details come in. And then somebody does some-- they complete the order form. So they actually type it onto an order form. And that produces a completed order form. Then that goes into a process called validate the order. Maybe they have to work out whether it complies with the budget. Let's say it's 10,000 pounds. And they say, well, we've only got a budget of 9,000. So it's not valid. We can't bother that. But let's say they manage to get it for cheaper. Let's say it's validated. Then it's signed. It's part of that validation. It produces a signed order form. Then the order is recorded. And that order form is sent two different ways. It's sent to the supplier. And then it's sent to the-- adjust the budget. So the budget's adjusted. And it's also saved the order itself, the details of it. Then it's sent to the supplier. And then the supplier sends it and passes it through. So the data changes as we move through. Have a better example of the coffee machine. It's a bit clear. So the data-through diagrams, they show how the data is modified as it flows through the system. So it shows that data exchanges within the side of the system or between a system and other systems that it communicates to. So they're relatively simple. But as they build up, they become more complex. The idea of the data-flow diagram is as you break it up into smaller and smaller components, eventually you get a component that is small or simple enough for you to willing to code that on its own. So it's a top-down process. It's a data-flow diagram. So you start on a context diagram, which has all the processes. And then you do it layer by layer into subprocesses. So you're showing what's called a functional perspective. Because inside the circles is some process happening. Flowing in and out is the actual data. So rather than think of breaking the system up, even though it's called a data-flow diagram, you're breaking the system up into processes and then subprocesses. So here's an example. This is the case study that I talked about in terms of the data-flow diagram. Here I have a drinks machine. The drinks machine has a keypad on the side. It has controllers which control the hot water to switch the heater off and on. It has a mechanism for putting the cups, dispensing the cups down, like with a solenoid. It then has a reader to see if the solenoid is in place. It has the hot water temperature. Notice some of these are dotted lines, and some of these are solid lines. A solid line means this is discrete data. It means when I press a key on the keypad, I get one single piece of data. The dotted line here means this is a control signal, and that means this is for switching something off and on. So I've got hopper on and off, and then that says the hopper is on and off. This one, where I have a solid line and it has two arrows, means this data is continuous. So the temperature is read continuously all the time. It can read the data. So it's just some things about the notation there. So dotted lines, these are control lines. These solid lines, these are data lines. So I've got loads of things that I might want to control within here. So this is the context diagram. This means this is the thing doing all the controlling. This is our computer system. These are all the dumb things on the outside that either accept information or control. The outside stuff in your use case diagram, they would be actors. And the inside would be the system itself. Then we can go deeper down and break this problem up. So this is your level 0 DFD. You're back here. That's your context diagram. Now you've got details of how you actually control the system in some detail. So we've broken it up into parts. So now when I type on the keypad, I have key codes. If the key code is a drink code, the operational control will read that. And it will send it to this thing which makes the drink. So you can imagine you're just typing random codes in. The operational control just throw them away. It says I don't understand that. It'll say invalid code, invalid code. But if it gets a valid code, it'll take that. And it will send it here to the drink code thing. Obviously, it's got other things happening inside here as well because it connects to other different parts of the system. So we can see we've got a separate process here on its own called the temperature control, which just switches the hot water element on and off depending on the temperature to keep it to a target temperature. So we can do that. And then we can break up that process again. So this is the process control. So this is looking at-- sorry, operational control. See this circle here? What we've done is we've zoomed into here, and we've done some more processing. So we're looking at inside of there. So we've got process the key codes. This looks at the key code. If it's a valid drink code, it will send it to this thing called the drink availability checker, which looks to see if we have enough coffee or tea to make the drink. It gets the information there. And if it does, it sends an instruction here to tell it to make the drink. If it's not, it will send information. If it's not available, it'll send information to the display to say it's not available. So what you're doing is each time you go further and further into this diagram, you're producing a simpler and simpler piece of code. So this code, process key codes, is probably simple enough for somebody to just start coding that now. But if you look at this diagram, operational control, that was too complicated. It had too many different things in. We wanted to break that up into separate pieces. This is a critical part of why you do data flow diagrams and why you do a lot of these models. It's to break something very complicated into smaller and smaller pieces until each piece is easy to solve. One simple problem. So the other type of diagram you can have are state chart diagrams. So this shows how the system responds to things coming in and what it does in terms of stuff coming out. So how it responds to stimuli. So for example, if you have your phone and you're in a call and you press the red button, it stops the call. So your stimuli was you pressing the red button. And it moves the call from in go, from call running, to call terminated. It's a different state of the call. So the state chart shows the system's internal state as nodes and the events as little lines between those nodes. And the state charts are part of UML. So when we look at UML later on, we're going to show you how to do state charts in UML. The initial state where the diagram begins is a solid circle. And you don't always have it if the system's always running. And then there's a possibility of a final state. That's a state where it can't jump out of. And that's shown a solid circle with a little ring around it. And that allows you to show the essential data of the system. Each state in UML is shown by a rounded rectangle. So here's an example of a microwave oven. So I start off here, and I immediately go into a state where I'm just displaying the time. So if you switch your microwave oven on, usually it makes a beep noise or whatever. And it shows the time. And it shows it's ready to do something. You can then press a button which changes it from full power to half power. So if I'm in this waiting state and I press full power, it sets it to full power mode. If I set it to half power, it will go into half power mode. If I'm in half power mode and I press full power, it will go back up here. If I press half power and full power, it will go back down to here. Then I can press the timer to say how long I want to have the time for. So if I press timer and then I type in numbers, it will take in the time for the cooking. So now what I've got it-- I've got it in a state where I've said I want it to cook for a minute. I then can close the door on the microwave. Notice if the door is open, the microwave is disabled. If the door is closed, it is enabled. So it has a-- within this diagram is a safety concern. It cannot get to this state where it operates without being in this state enabled. It cannot, for example, jump to here-- see this state-- to here in one operation. It has to go through this enable state. The door has to close or be closed. Then I press the start button. It doesn't start immediately. I press the start button. And it starts to do the cooking. And then if the door opens-- when if I open the door in the middle of cooking it, it jumps back to the disabled state again, waiting for me to close the door. So you can see from this diagram, quite simply, the different states the microwave can be in and how you can keep it safe. There's no final state in this because, well, you've just got to keep the thing running, haven't you, as you go along. So we've got this final state where we're waiting. The microwave oven has a number of different stimuli. And this is a diagram showing you what the stimuli means. So on the diagram, it's got half power. But that means the user has pressed the half power button. So you can see we're using this diagram as a key to understand the previous diagram. The other thing the state chart can do is allow us to break up into a state into sub-models, further different parts. So now we can have a description of the actions showed by the word "do" inside the state itself, something that happens while you're doing it. So we add those to the states and the stimuli, and we have the final diagram. So if we look in this one, this is the state called operation. If I go back to this diagram, where I've got the operation of the microwave, it's here. See this here? I'm looking inside there. So while it's operating, it's checking that the microwave is functional, if there's any fault. So if there's either a meter fault or a turntable fault, it will jump to here, where it will give an alarm, and then it will go to the disabled state. So it's got to check all the time that everything's fine. If it's OK when it jumps into this state, there isn't a problem with either of these two. It's going to start cooking the thing, and it's checking the time. So this means it's going up here means it has remaining time left. This means that the time has run out. There's a time out. It makes a buzzing noise for five seconds, and then goes into a waiting state, because it's finished doing the cooking. If you press door open, notice door open drags it out of all of these states. So notice this door open signal is not attached to any of these states. It's attached to the whole of the operational state. So if you press door open motion, you go back to the disabled state. So those labels on the arcs, they allow it to move from one state to the next. And you can also add in guards to ensure that it's only allowed to move that state if that guard is true. The other thing the state can have is a little diagram inside it. And that's called a composite state. We've also seen this, haven't we? This is a composite state operation, because it's inside here. It's inside this diagram. So it's a composite state inside it. But we can see this again in some detail here. So I've got a running state of something. I've got it moving from system off to system on, but only if this guard is true. So notice the guard is a little condition inside there, inside the square brackets, running after the event. A guard is a little bit like a precondition in use cases. It must be true for you to allow to move from one state to the other. And again, these composite states, they have internal complexity within them. You can put actions after the event. So if you use a slash on a state diagram like this, so it says ink available, and then it clears the display, while it's in this out of ink state, this is for a printer, and it has more ink, you add more ink in, it's going to just clear the display. If it's in this idle state and it finds the text that the ink is low, it's going to show the error message. So notice, this is the event. This is the action. So notice the action in this doesn't happen continuously in the state, it just happens once after the event's happened. So it's good to have an idle state where the process is not active. That's often very relevant. You generally shouldn't have any deadlock. So even in an error condition, there should be a way of resetting the diagram, maybe pressing a reset button. If you find the diagrams getting too complex, you should use multiple state charts. And you don't need to use a state chart as a sub-state of another state chart. What you can do is have multiple state charts next to each other and then have the things going in between them. So here's an example of an automatic braking system. Automatic braking systems are designed to not allow wheels to lock. If the wheel is locking, it releases the brakes for a short amount of time. So it has something here called a threshold for the amount of time that the wheel-- it detects if the wheel is above or below target. If the wheel's going too fast, it applies the brake. But it's got this thing called wheel stationary. Wheel stationary means it knows the car is moving, but it detected the wheel wasn't moving. So that means that the wheel is in a lock state. The car's skidding. So if the wheel is stationary and it's above this threshold-- so there's a timing threshold for that. So it's allowed to be stationary a bit of time. It releases the brake for a short amount of time. And then it applies it again afterwards. So it requires a number of things. But notice, this also works with the dashboard control, which is checking if the brake's pressed. And it's putting in some information about what is the target speed. So instead of the brake being actually physically connected to the brake caliper, the brake pedal is being used to run a state machine which is controlling the amount of grip on the given brake. [INAUDIBLE] Finite state machines are models which show things as state, but they have particular notation that's not the same as the UML. So they're not the state charts. So in this context, the finite state machine has an end state where it's detecting certain languages. So you notice in this, it has an incoming alphabet. So here, I come in this stats here. And then it's looking for anything where I've got anything where I've got B coming in. So B is OK. Or A, A, B. Or A, A, A, A, A, A. Anything starting with a B, and then any number of As would be considered as a detected state. And anything which starts with an A, and then it can have a number of Bs inside it, and then it has an A again. So the finite state machine has a number of initial states. It has an initial alphabet, an input alphabet, and a transition function. You can use finite state machines, for example, to do the spell checking in a word processor. So think of the spell checking in a word processor. Because you type letters, it will either detect-- it knows that it could be a word. So if it knows it could be a word, it leaves it OK. So if I type the letter C, that's fine in English. If I type CA, it could be-- well, it could be a cat, so it leaves it fine. And then I type T, it knows it could be CAT, so it moves around the finite state machine, finding it's still detected a valid word. If I then type Z, it realizes it's an impossible state where it cannot detect anything. It then red underlines the thing. If I go delete again, it goes back in the finite state machine, back to the state where it was recognizing it. So finite state machines can be used for those. They can also be used for text prediction things, things like that. We have text prediction on the phone. Again, something where it's recognizing a series of symbols make up a greater symbol in terms of recognition. So again, I'll leave this as an exercise for you to do. There's the beginning state. There's the end state. You have a look and see what languages that one is recognized. So the recognition state is where you have the two arrows going. For a finite state machine, the computation starts here at the start state. And then it changes depending on the input alphabet. And then at some point, it will get to the end point, which is the recognized alphabet. So as we do the input alphabet, we move from one state to the other, depending on what the input symbols are. If we don't have an input symbol that's in that input alphabet, it stays where it is. And you also have rules and conditions that allow a state transition. So they can be externally generated, or they can be done on input internally generated. That is something like a timeout. So they've been used in the past for doing language recognizers and also data communication. So we're going to pick up on FSM a bit more in the next lecture. So this model is the abstract view of the system. We looked at some data processing models. We looked at the context model, which your use case is an example of. We looked at a data flow model when we looked at that coffee machine, looked at interpreting information going in and out. And finally, we looked at state machine models, didn't we, which enabled us to model the embedded system of the microwave. [SIDE CONVERSATIONS] [BLANK_AUDIO]