[SIDE CONVERSATIONS] Can everyone hear me? I see a thumbs up. Thank you. Right, OK. So probably some of you have met me in the labs. Others might have just seen me in that first lecture where I briefly was there to just say, hello, I'm here. My name's Henry. I'm helping say I teach this module, including lecturing as well as labs. I am here, so if anybody has any questions about the assignment outside of the lecture, you can message me on Teams as well as Seb. And that's for all the assignments as well, not just the use case one. And yeah, today we're going to be looking at design, specifically how can we identify what classes we need, what attributes, and more or less data-driven design in today's lecture. So yeah, we're looking at a hotel booking system case study, which will be fun. I was going to say something, but OK. Actually, that is something, the attendance code. That's the one thing I forgot. So I don't think this lecture will be a long one, so I'll give you about one minute to just look at the attendance code. There you go. If you can see that. More 30 seconds. I'm feeling not very nice. [SIDE CONVERSATION] OK, so I'll go back on the attendance code at the end of the lecture if anybody didn't get it. So with objects-oriented design, which I think you went through last lecture, and analysis, these are the key things you want to work out. What classes-- if you're given a problem, some requirements that you need to perform, what classes do you need, what database tables do you need as well, what attributes are required for all the above-- so what attributes does a class need for it to function properly-- and methods as well. So the same as attributes for making it work. The easiest thing is to just start with what classes you need first, and you can just create a list for all the candidates that you need so that you can start creating database tables. Most of the time, these are just classes that require persistence, so they need to be present throughout your whole code base. I can't think of the word. But yeah, what things need to always exist. So in the hotel case study, you were given-- it's on Canvas, but you were given this brief here. It explains everything that-- I can't read it up there. The hotel requires a booking database that captures all of this information. So the first thing is identifying from that whole description what classes you will need. Are you looking for the attendance code? Yeah, 201, yeah. Different lecture. So the first thing, yeah, is looking at this whole description here and identifying what classes you need, what attributes you need, all the use cases described by here, which will be used for methods, et cetera, et cetera. So the way you do this is quite simply just noun analysis. So looking at everything on there and seeing what nouns exist that you can use to make a whole class list. So if you do performant noun analysis, you'll start just listing all the nouns, really. So hotel is a noun. Database is a noun. Bookings is a noun. View is a verb and a noun. No, it's not. There it is. Rooms are a noun. And then, yeah, everything is a noun. So by doing this, you can quite quickly discover what things-- what classes you need, what attributes you need. Less so about the use cases, but you can infer that from reading the whole thing. And you can look at it and go, OK, the user has to be able to do this. The user has to be able to do that. So you can see from the use cases here is that you need to be able to view a room availability. So if you're at a hotel, you're not all going to book the same room, are you? So you need to see what rooms are available. And then if that room is available, you can create a booking. You can cancel a booking, check a guest in and out, have breakfast for a guest, et cetera, et cetera, et cetera. So I think that also ties quite well into the current use case assignment that you guys are doing, that the use cases aren't the internal workings of the whole system. It's more how does a user or different actors just interact with their system. So it doesn't mention-- well, you do view the room availability, but there isn't a separate use case for describing just the functionality of viewing the room availability by itself. So the use cases will just be how does somebody interact with the system, which might be good for your current assignment. But yeah, so there are all the use cases we've identified from this description. But that isn't tied directly into noun analysis, so we're going to move on now. So noun analysis just really helps, like I said, helps you identify the class names and the attributes and everything you need. However, as good as noun analysis is, it is just the starting point. Not every single noun will be a class. So for example, database, that's not going to be a class within your system. So it isn't good enough to just do the noun analysis and go, yeah, there's every single class I'm going to create. On the other side, not every class will be present in your noun analysis. Oh, sorry, not every single class will be present in the noun list that you create. So you need to be able to infer some classes and attributes and methods that will be a part of your requirements in your analysis. So if you need to infer it, then you need to also add some extra classes to add to your solution. So yeah, like I said here, each noun can be a class name or an attribute name, not a method name because the methods are more the use cases. But each noun can just be a class name and an attribute name. So this idea that not every single class is-- not every single class is present within the briefing, you need to infer what classes or extra classes you will need to be able to provide functionality to your solution and your design. So you can see here that you have 10 single rooms, 75 pound per room per night. This isn't important. In this case, you'll find that the room rate per night is 75 pound per night. So the word rate is not stated, so you can infer that. So just by thinking a little bit about, OK, what other things do I need to make this work, you can include, OK, well, we need a rate to be able to tell the user how much they're going to be able to spend and to make your solution nice. And this is not as complex as it needs to be. There are other attributes that you can add, but I don't think we're really going to talk about them. But yeah, you could add-- you could future proof it. So in the future, especially with global warming, we'll probably all need air conditioning soon. And a sea view is always nice to have as well. So those design decisions that you make by inferring attributes and classes that aren't present in the brief, they need to then be added to the requirements. The important thing is that you make the solution as flexible as possible. So it doesn't have to be the only way. The way you design it shouldn't be the only way it could be implemented. You could implement it. It needs to be more, OK, we could do it like this. And then if we have it like this, then this opens up opportunities to work in either these two or three ways. It just makes it easier to implement. And it means if you can implement it in multiple different ways, then you save yourself a lot of time. If it's too rigid, then you might need to change everything if you just wanted to change one thing. So after inferring all the class names and removing the class names that you don't need, then you'll end up with a noun list. So these are all the things that you've-- these are all the things that were taken from the brief that we could use for our system that we've identified in our design. So to go through every single one of them, I think hotel, we can all agree that we definitely need, and it will be a class as well. So that would just talk about the whole thing, really. But we don't need owner. We don't need that as a class or an attribute for the whole-- like, we can just remove it. Database, like I said earlier, it's outside the problem domain. This is just describing we need a database. You don't actually need to write a class called database. Room, though, room is a class. So it stores the attributes of a given room. Now, a lot of rooms will be similar. If you've ever booked a hotel room before, they've all got standard double beds, the premium double bed. So some of them will be the same. But you do need a room class so that you can quite easily differentiate what different attributes they have. So does it have a sea view? Does it have a single bed? Et cetera, et cetera. So the next thing is that if a hotel had 142 rooms, then within your hotel class, you would have 142 instances. So you would have a room with a room description. So you would have a room with two different instances of a room. Room description is an inferred class. So like I said, you're going to have multiple different rooms. Some of them are same. So you might as well just have one class for that type of room when you're talking about a room description. So if you have one class called room description, you would have four instances of this class for a single double premiere and executive rooms. Night is part of the description language, but not really an attribute or a class. So we could discard it. A guest is a class. It stores the detail about the guest. The booking describes-- is a class that stores details about the booking for the guest. We'll move more on that. And then a room booking is also an inferred class. So since a booking can consist of a whole list of room bookings-- so if you were a company and you wanted to take everybody on a nice little break in Germany or something, you could book out multiple rooms. That would be one booking. That one room booking would have multiple room bookings. So you would have multiple different rooms within one booking. So that's just a little explanation about that. So now we're going to do object-oriented analysis. So we're going to take each class out of the list. We're going to add in attributes and then work out the relationship that it has to other classes. So it's one to one, one to many, many to many, et cetera. And then we're going to add in the method and responsibilities. This is just for the rest of the lecture. So when talking about data design, you can notice the addition of unique ID. So if we were to link this to a database, this allows it to persistently be within the database. You've got a unique ID. You should really add this to every single one of your objects so that you can consistently reference a persistent object or class, an instance of a system class, constantly, and link it to your database and link it to your back-end software. So yeah, the unique ID would probably be-- well, would be the primary. So you can see a hotel has just a hotel ID and hotel name if it was a database name. You would have a room. So this has a link to the hotel. So you could take the hotel class and store it in room. And therefore, you would know that that room belongs to that hotel. And the room number, which would be unique for each room in that hotel, and then the room description as well. So like I said earlier, some rooms might have the same description. So it is many to one with room description. So there might be many rooms for one room description. And it'd be one to many with a room booking. So we could have this one room with multiple room bookings. We get on to room description. So one to many with room. So there is one room description for many rooms. And then you can see why we've done this, is because we have a description, a max occupancy, tariff in minor unit. So companies tend to do transactions in the penances or the smallest unit of their currency, because it's more accurate. And then the currency code, which is all standard currency stuff. So if this was for a single room, your description would just simply be, oh, it's a single room, max occupancy, it would be one person in there. Tariff in minor unit would be 7500 for 75 great British pounds. Should say currency code, not current code. So again, just like with all of these, they've all got their own unique ID. But the actual class itself was like a whole reference to everything in here. Now this person class has been inferred. It wasn't mentioned in the noun list, or the brief, rather. They just mentioned guest. But the nice thing about this is that it would be apparent of the class guest. So you're keeping those two parts separate. You don't want a person to-- any person to be in the hotel. You would want a guest to be in the hotel. And it would be many to one with class address. So there'd be many, many different people with-- would have one address each. [COUGHS] Sorry. So yeah, you just store their surname, their other names, and the date of birth. And the address will be what you see in the set. So the guest, one to many with class bookings. So one guest can make many bookings. One to many with class payment. You might make multiple payments for just one booking. And then one to many with class invoice. So again, you might have one guest who stayed at this hotel for a while. He's got a lot of invoices because he keeps on staying. He's in pain. So you can see that the guest here has the email and the address because that's the only two things that the hotel or the booking needs to know. But because it's inherited from person, it could get its other information, such as name. Quite commonly, what a lot of people do is they create their own class for address. Address has a lot of attributes. So you have-- we've all gotten Uber Eats. We all know what we have to type in. So we have address-- all our address lines, zip codes, country, and then that address links to the person. So you would have address here, which then links to that person. You could get the name and you could get everyone. So yeah, like it says, lots of projects use addresses as their own class because it makes-- it keeps it all nicely contained within everything. So you only need to access the class. You don't have to rewrite loads and loads of lines of code. Then we have booking. So you have one-to-many with room booking. So one booking can have multiple room bookings. One-to-one with guests. So one booking will always have one guest. So there's always the head guest that you book with. Only one person deals with the booking. And then one-to-one with invoice as well. So one booking has one invoice. Class room booking. So it allows one booking-- not book-- one booking to have multiple rooms. And that's many-to-one with booking. So many room bookings can be within one booking. Again, the idea-- oh, yeah, we always mention it then. And it's many-to-one with room as well. It says it there, and I'm going to trust it. But I think if you had-- does anyone agree with this? So you can have many-to-one room bookings with one. So if you would have multiple room bookings with one booking, then you have many-to-one with room. Wouldn't you have one-to-one with room? Does anyone agree with that? Because if you just have one room with a room booking, and then you have many room bookings for one booking, why do you then have many room bookings to one room? Does anyone get what I'm saying? Yeah. Then the room will be booked at the same time. That one room will be booked. But that's what it says. It says one room. You mean like overall, like in the whole system? Just meaning to show that it can be all the rooms in one room at the same time as that one. Many-- sorry, say it again. [INAUDIBLE] Yeah, but it would-- if you had one booking, you wouldn't want the room to be booked out multiple times at the same time. You just want that one room to be booked once. Do you get what I mean? I get what you mean as well. Anyway, sorry. I could spend all day talking about that. Hands up if you think it would be many to one with one room. And hands up if you think it would be one to one with one room. OK, three or four to-- and then about 150 abstained. But democracy is democracy. OK, so all right. Anyway, sorry. Doesn't matter. You get the idea that with a room booking, you have one booking which has multiple room bookings. And then the room bookings are tied to a room. We all get that, don't we? I see a little nod. Thank you. So then we move on to the invoice class. This one I do agree with, one to one with booking. So one booking has one invoice. So one guest makes the booking. And then that guest gets charged 300 quid or something. So you would have the date issued with the invoice class, the booking that it's linked to, how much money it is in the minimum currency unit, and then the currency code as well, ISO 4217. Then we have payment class as well. So many to one invoice. So if you paid half of it with cash and half of it with card, you can make-- sorry-- you can make multiple payments just of one invoice, just thinking on the deep level. So again, the date taken where you took the payment, the invoice that it's linked to, so what invoice you're paying. Did you use card, cash, or pay path? How much did you pay in the minimum currency unit? And then the currency code again. And finally, we have the user class. I say finally. We have multiple classes. I'm sorry. I lied. User ID. So again, everyone needs a user ID. Everyone just knows. You don't even learn this, and you just know you need the user ID. The date the account was created, username, password, email address, and then the role as well. So when talking about the whole system to access it, check bookings, make bookings, is the person a guest, hotel manager, a receptionist, or a system? So that would be an enumerated class. And then not an enumerated class, just an enum. I forget the name. Sorry. But yeah, so everybody needs to access the system, whether you're a staff member or whether you're actually just a user trying to make a booking. And then we have the login class as well. So one-to-one with user. So every time you try and log in, you record the status of if they managed to log in. If they didn't, then you can track who's trying to get into your system, whether they're nasty, evil people trying to get some data or whether they're just people just trying to get in. And you can do all your diagnostics by tracking all the login and make sure all your code's working fine. So after all that data analysis, now we're looking at methods. So like I said earlier, you generally, generally get all the methods that you need from looking at the use cases and then applying those use cases to what class seems like the most appropriate to execute that use case. So they should be associated with the correct class. They need to be able to drive or execute the use cases and all the responsibilities that we defined earlier. So we'll look at three methods. Oh, OK. Yeah, that's what I meant, methods for the use cases. We will look at three methods that we need to add. View room availability, create a booking, and cancel a booking. So checking the availability of the room is probably going to be the most complex method, even though in reality it's not that complex. So the idea is, again, with object-oriented, if you can design a nice system that everything should access only what it needs to access, everything should just work on its own things, you end up, especially with hotel bookings and everything like that, unless you're doing some complex research into algorithms and AI, your most complex method is just going to be checking the availability for a room, in this case. So the importance of designing a system very well just makes life very, very easy. But the whole complexity of this method, you'd need to do three things, really. You need to check if it was available for a range of dates. You need to check what rooms are available for those dates. And then you need to check what rooms are available for a given range of dates of a given description. So yeah, you just see Boolean available. So that's a method, returns true or false. Static Boolean room finds the rooms, all the rooms within the system that are within that time frame. And then, again, start a Boolean room, find rooms. What rooms are available for a given range of dates of a given description. So you can look at all descriptions as well. So your design of room now looks like this. So these are all private variables. That's what the minus means. I don't know if you've come across that yet. And then you've got all these public methods here. So the public methods allow any part of the system-- probably you'd only want some parts of the system-- to check whether that room is available. And then these two are separated like this. You've got your attributes, your data up here. And then down here, you would have your methods. So when designing, most of the time we know that we're going to use setters and getters-- getter-- methods for your classes. You don't need to mention that when you're designing. It avoids clutter. We all know that every single object you create should more or less set or get variables. And you should add in methods as well that define object behavior. So make sure you mention-- so take the use cases. See what they should be attributed to, what classes they should be attributed to. And then make sure that they do, in fact, define that object behavior. So now we can add these other room booking functions. We can create a room booking. And we can cancel room booking as well. So constructors room booking method of room booking. So these methods must update the database. So when you are room booking-- say on the next thing-- all classes require both empty constructors to make the object. So when you make a room booking, it's actually the constructor class of room booking. So every time you create a room booking, you need to make a new class of room booking. And therefore, you need for it to be a constructor. And when you create that constructor, it then updates the database that you've created in the background. And then down here as well, you can see we can delete room booking as well. So like I said, all classes require both empty constructors to make the object. So we need to make the object of room booking. And this is to provide a placeholder for data and with parameters. So when you do the room booking, you give it all the data you needed to give it when we saw it up there. There you go, room booking. You can see all these attributes here. Includes start date and end date. I don't think it actually included it there, did it? Oh, it did. Yeah, cool. It's just not in the same order. So yeah, everything that's required for room booking, you need to pass that data with the constructor. So what you're actually doing in this case is you're creating a room booking class. You're creating an instance of the room booking class. And therefore, it needs to be a constructor so you add all the information when you create it. I've repeated that loads of times. I'm very sorry. And then you need to do that so you can update the database because you give it a unique ID. So the design-- so these are notes on implementation, by the way. So the first one that I just said. The design should support a given implementation but not force a given approach. You'll find that this is design only. And design can always change. And you will find that after you've designed something, after you've designed something, and when you come down to actually implementing it, you find that it changes. And it will always change. And that's OK. We just need to make sure that the design is flexible as possible. Because if you make it too rigid a design and you come down to your implementation, you need to change something, you might find that you just have to redo the whole thing. That method you designed doesn't only have one approach to actually implementing. And it should, in fact, support multiple ways. And to do that, you just need to be a bit chill with how you design it. So yeah, that means a decision on how we will implement can affect the design decisions but ideally not the other way around. And then once you do all of the things that we mentioned or I mentioned, in here you'll end up with this class diagram. So you can see that a guest inherits person. And then address is part of a person. You've got zero of the homeless to many addresses for one person. Or the other way, so not many addresses for one person. But they can be multiple people and each of them have one address. You can see that the hotel, there's always one hotel, has any number of rooms. And that any number of rooms each have one room description. And a room description can go to many rooms. That there is one room for each room booking, but always you can have multiple different room bookings that each have one room. And then this idea of multiplicity is really the only thing you need to stress when doing this. But there are different methods of how to talk about this one here, which is composition, and then this one here, which is aggregation, and then inheritance. But we're not talking about that this time. But yeah, after going through your noun analysis and your use cases, you've more or less then derived the classes and attributes and the methods. Then you go through data analysis and create database tables for each class you have in each of the attributes. And once you're done with that, you then move on to implementing the methods and making sure that each class you've created has its defined behavior. And then once you've done that, you can then link it very nicely in a class diagram, which as a very high level describes how everything is linked together. So a summary after going through this case study is that you use noun analysis to help class with class list and attribute this, which I just said. Make sure you add extra classes if needed to make your solution work. Think carefully about the relations between different classes. And then finally, work from your use case list to work out the required behavior and methods associated with classes. And that's it for the lecture. Does anybody have any questions? Cool. There's the attendance code again if anybody needs it. I will see you all tomorrow.